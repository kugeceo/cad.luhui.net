/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		if (null) script.crossOrigin = null;
/******/ 		head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined") {
/******/ 				return reject(new Error("No browser support"));
/******/ 			}
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentHash = "16c0fd504c7c026d2922";
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParents = [];
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = [];
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e" &&
/******/ 				name !== "t"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		fn.t = function(value, mode) {
/******/ 			if (mode & 1) value = fn(value);
/******/ 			return __webpack_require__.t(value, mode & ~1);
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (dep === undefined) hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (dep === undefined) hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = "sketcher";
/******/ 			// eslint-disable-next-line no-lone-blocks
/******/ 			{
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (!module || module.hot._selfAccepted) continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted
/******/ 			)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/static/";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(1)(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./modules/gems/exportTextData.js":
/*!****************************************!*\
  !*** ./modules/gems/exportTextData.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (data, fileName) {
  var link = document.getElementById("downloader");
  link.href = "data:application/octet-stream;charset=utf-8;base64," + btoa(data);
  link.download = fileName;
  link.click();
});
;

/***/ }),

/***/ "./modules/gems/func.js":
/*!******************************!*\
  !*** ./modules/gems/func.js ***!
  \******************************/
/*! exports provided: NOOP, createFunctionList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NOOP", function() { return NOOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFunctionList", function() { return createFunctionList; });
var NOOP = function NOOP() {};
function createFunctionList() {
  var fnList = [];

  var add = function add(fn) {
    return fnList.push(fn);
  };

  var call = function call() {
    fnList.forEach(function (fn) {
      try {
        fn();
      } catch (e) {
        console.error(e);
      }
    });
  };

  return {
    add: add,
    call: call
  };
}

/***/ }),

/***/ "./modules/gems/iterables.js":
/*!***********************************!*\
  !*** ./modules/gems/iterables.js ***!
  \***********************************/
/*! exports provided: findDiff, flatten, indexArray, addToListInMap, addToSetInMap, removeFromSetInMap, removeInPlace, EMPTY_ARRAY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findDiff", function() { return findDiff; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return flatten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indexArray", function() { return indexArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addToListInMap", function() { return addToListInMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addToSetInMap", function() { return addToSetInMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromSetInMap", function() { return removeFromSetInMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeInPlace", function() { return removeInPlace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_ARRAY", function() { return EMPTY_ARRAY; });
function findDiff(arr1, arr2) {
  var both = [];
  var firstOnly = [];
  var secondOnly = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = arr1[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var e1 = _step.value;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = arr2[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var e2 = _step4.value;

          if (e1 === e2) {
            both.push(e1);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = arr1[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _e = _step2.value;

      if (both.indexOf(_e) === -1) {
        firstOnly.push(_e);
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = arr2[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _e2 = _step3.value;

      if (both.indexOf(_e2) === -1) {
        secondOnly.push(_e2);
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return [both, firstOnly, secondOnly];
}
function flatten(arr) {
  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var depth = arguments.length > 2 ? arguments[2] : undefined;

  var _currLevel = arguments.length > 3 ? arguments[3] : undefined;

  _currLevel = _currLevel || 1;

  for (var i = 0, length = arr.length; i < length; i++) {
    var value = arr[i];

    if (Array.isArray(value) && depth && _currLevel !== depth) {
      flatten(value, result, depth, _currLevel++);
    } else {
      result.push(value);
    }
  }

  return result;
}
function indexArray(array, getKey) {
  var getValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (v) {
    return v;
  };
  var obj = {};
  array.forEach(function (item) {
    return obj[getKey(item)] = getValue(item);
  });
  return obj;
}
function addToListInMap(map, key, value) {
  var list = map.get(key);

  if (!list) {
    list = [];
    map.set(key, list);
  }

  list.push(value);
}
function addToSetInMap(map, key, value) {
  var set = map.get(key);

  if (!set) {
    set = new Set();
    map.set(key, set);
  }

  set.add(value);
}
function removeFromSetInMap(map, key, value) {
  var set = map.get(key);

  if (set) {
    set["delete"](value);

    if (set.size === 0) {
      map["delete"](key);
    }
  }
}
function removeInPlace(arr, val) {
  var index = arr.indexOf(val);

  if (index !== -1) {
    arr.splice(index, 1);
  }

  return arr;
}
var EMPTY_ARRAY = Object.freeze([]);

/***/ }),

/***/ "./modules/lstream/base.js":
/*!*********************************!*\
  !*** ./modules/lstream/base.js ***!
  \*********************************/
/*! exports provided: StreamBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamBase", function() { return StreamBase; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var StreamBase =
/*#__PURE__*/
function () {
  function StreamBase() {
    _classCallCheck(this, StreamBase);
  }

  _createClass(StreamBase, [{
    key: "attach",
    value: function attach(observer) {}
  }, {
    key: "map",
    value: function map(fn) {
      return new MapStream(this, fn);
    }
  }, {
    key: "filter",
    value: function filter(predicate) {
      return new FilterStream(this, predicate);
    }
  }, {
    key: "pairwise",
    value: function pairwise(first) {
      return new PairwiseStream(this, first);
    }
  }, {
    key: "scan",
    value: function scan(initAccumulator) {
      return new ScanStream(this, initAccumulator);
    }
  }, {
    key: "remember",
    value: function remember(initialValue, usingStream) {
      if (!usingStream) {
        usingStream = StateStream;
      }

      var stateStream = new usingStream(initialValue);
      this.attach(function (v) {
        return stateStream.next(v);
      });
      return stateStream;
    }
  }, {
    key: "distinct",
    value: function distinct() {
      return new DistinctStream(this);
    }
  }, {
    key: "throttle",
    value: function throttle(delay, accumulator) {
      return new ThrottleStream(this, delay, accumulator);
    }
  }]);

  return StreamBase;
}();

var _require = __webpack_require__(/*! ./map */ "./modules/lstream/map.js"),
    MapStream = _require.MapStream;

var _require2 = __webpack_require__(/*! ./filter */ "./modules/lstream/filter.js"),
    FilterStream = _require2.FilterStream;

var _require3 = __webpack_require__(/*! ./state */ "./modules/lstream/state.js"),
    StateStream = _require3.StateStream;

var _require4 = __webpack_require__(/*! ./pairwise */ "./modules/lstream/pairwise.js"),
    PairwiseStream = _require4.PairwiseStream;

var _require5 = __webpack_require__(/*! ./scan */ "./modules/lstream/scan.js"),
    ScanStream = _require5.ScanStream;

var _require6 = __webpack_require__(/*! ./distinct */ "./modules/lstream/distinct.js"),
    DistinctStream = _require6.DistinctStream;

var _require7 = __webpack_require__(/*! ./throttle */ "./modules/lstream/throttle.js"),
    ThrottleStream = _require7.ThrottleStream;

/***/ }),

/***/ "./modules/lstream/combine.js":
/*!************************************!*\
  !*** ./modules/lstream/combine.js ***!
  \************************************/
/*! exports provided: CombineStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CombineStream", function() { return CombineStream; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./modules/lstream/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./modules/lstream/utils.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var CombineStream =
/*#__PURE__*/
function (_StreamBase) {
  _inherits(CombineStream, _StreamBase);

  function CombineStream(streams) {
    var _this;

    _classCallCheck(this, CombineStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CombineStream).call(this));
    _this.streams = streams;
    _this.values = _this.streams.map(function () {
      return _utils__WEBPACK_IMPORTED_MODULE_1__["NOT_INITIALIZED"];
    });
    _this.ready = false;
    return _this;
  }

  _createClass(CombineStream, [{
    key: "attach",
    value: function attach(observer) {
      var _this2 = this;

      var detachers = new Array(this.streams.length);
      this.streams.forEach(function (s, i) {
        detachers[i] = s.attach(function (value) {
          _this2.values[i] = value;

          if (!_this2.ready) {
            _this2.ready = _this2.isReady();
          }

          if (_this2.ready) {
            observer(_this2.values);
          }
        });
      });
      return function () {
        return detachers.forEach(function (d) {
          return d();
        });
      };
    }
  }, {
    key: "isReady",
    value: function isReady() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var val = _step.value;

          if (val === _utils__WEBPACK_IMPORTED_MODULE_1__["NOT_INITIALIZED"]) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return true;
    }
  }]);

  return CombineStream;
}(_base__WEBPACK_IMPORTED_MODULE_0__["StreamBase"]);

/***/ }),

/***/ "./modules/lstream/constant.js":
/*!*************************************!*\
  !*** ./modules/lstream/constant.js ***!
  \*************************************/
/*! exports provided: ConstantStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConstantStream", function() { return ConstantStream; });
/* harmony import */ var _emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./emitter */ "./modules/lstream/emitter.js");
/* harmony import */ var _gems_func__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gems/func */ "./modules/gems/func.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var ConstantStream =
/*#__PURE__*/
function (_Emitter) {
  _inherits(ConstantStream, _Emitter);

  function ConstantStream(value) {
    var _this;

    _classCallCheck(this, ConstantStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConstantStream).call(this));
    _this._value = value;
    return _this;
  }

  _createClass(ConstantStream, [{
    key: "attach",
    value: function attach(observer) {
      observer(this._value);
      return _gems_func__WEBPACK_IMPORTED_MODULE_1__["NOOP"];
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    }
  }]);

  return ConstantStream;
}(_emitter__WEBPACK_IMPORTED_MODULE_0__["Emitter"]);

/***/ }),

/***/ "./modules/lstream/distinct.js":
/*!*************************************!*\
  !*** ./modules/lstream/distinct.js ***!
  \*************************************/
/*! exports provided: DistinctStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DistinctStream", function() { return DistinctStream; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./modules/lstream/base.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


var DistinctStream =
/*#__PURE__*/
function (_StreamBase) {
  _inherits(DistinctStream, _StreamBase);

  function DistinctStream(stream) {
    var _this;

    _classCallCheck(this, DistinctStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DistinctStream).call(this));
    _this.stream = stream;
    _this.latest = undefined;
    return _this;
  }

  _createClass(DistinctStream, [{
    key: "attach",
    value: function attach(observer) {
      var _this2 = this;

      return this.stream.attach(function (v) {
        if (_this2.latest !== v) {
          observer(v);
          _this2.latest = v;
        }
      });
    }
  }]);

  return DistinctStream;
}(_base__WEBPACK_IMPORTED_MODULE_0__["StreamBase"]);

/***/ }),

/***/ "./modules/lstream/emitter.js":
/*!************************************!*\
  !*** ./modules/lstream/emitter.js ***!
  \************************************/
/*! exports provided: Emitter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Emitter", function() { return Emitter; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./modules/lstream/base.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


var READY = 0;
var EMITTING = 1;
var Emitter =
/*#__PURE__*/
function (_StreamBase) {
  _inherits(Emitter, _StreamBase);

  function Emitter() {
    var _this;

    _classCallCheck(this, Emitter);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Emitter).call(this));
    _this.observers = [];
    _this.state = READY;
    return _this;
  }

  _createClass(Emitter, [{
    key: "attach",
    value: function attach(observer) {
      var _this2 = this;

      this.observers.push(observer);
      return function () {
        return _this2.detach(observer);
      };
    }
  }, {
    key: "detach",
    value: function detach(callback) {
      for (var i = this.observers.length - 1; i >= 0; i--) {
        if (this.observers[i] === callback) {
          this.observers.splice(i, 1);
        }
      }
    }
  }, {
    key: "next",
    value: function next(value) {
      if (this.state === EMITTING) {
        console.warn('recursive dispatch');
        return;
      }

      try {
        this.state = EMITTING;

        for (var i = 0; i < this.observers.length; i++) {
          this.observers[i](value);
        }
      } finally {
        this.state = READY;
      }
    }
  }]);

  return Emitter;
}(_base__WEBPACK_IMPORTED_MODULE_0__["StreamBase"]);

/***/ }),

/***/ "./modules/lstream/external.js":
/*!*************************************!*\
  !*** ./modules/lstream/external.js ***!
  \*************************************/
/*! exports provided: ExternalStateStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExternalStateStream", function() { return ExternalStateStream; });
/* harmony import */ var _emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./emitter */ "./modules/lstream/emitter.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


var ExternalStateStream =
/*#__PURE__*/
function (_Emitter) {
  _inherits(ExternalStateStream, _Emitter);

  function ExternalStateStream(get, set) {
    var _this;

    _classCallCheck(this, ExternalStateStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ExternalStateStream).call(this));
    _this.get = get;
    _this.set = set;
    return _this;
  }

  _createClass(ExternalStateStream, [{
    key: "next",
    value: function next(v) {
      this.set(v);

      _get(_getPrototypeOf(ExternalStateStream.prototype), "next", this).call(this, v);
    }
  }, {
    key: "update",
    value: function update(updater) {
      this.value = updater(this.value);
    }
  }, {
    key: "mutate",
    value: function mutate(mutator) {
      mutator(this.value);
      this.next(this.value);
    }
  }, {
    key: "attach",
    value: function attach(observer) {
      observer(this.value);
      return _get(_getPrototypeOf(ExternalStateStream.prototype), "attach", this).call(this, observer);
    }
  }, {
    key: "value",
    get: function get() {
      return this.get();
    },
    set: function set(v) {
      this.next(v);
    }
  }]);

  return ExternalStateStream;
}(_emitter__WEBPACK_IMPORTED_MODULE_0__["Emitter"]);

/***/ }),

/***/ "./modules/lstream/filter.js":
/*!***********************************!*\
  !*** ./modules/lstream/filter.js ***!
  \***********************************/
/*! exports provided: FilterStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FilterStream", function() { return FilterStream; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./modules/lstream/base.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


var FilterStream =
/*#__PURE__*/
function (_StreamBase) {
  _inherits(FilterStream, _StreamBase);

  function FilterStream(stream, predicate) {
    var _this;

    _classCallCheck(this, FilterStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(FilterStream).call(this));
    _this.stream = stream;
    _this.predicate = predicate;
    return _this;
  }

  _createClass(FilterStream, [{
    key: "attach",
    value: function attach(observer) {
      var _this2 = this;

      return this.stream.attach(function (val) {
        if (_this2.predicate(val)) {
          observer(val);
        }
      });
    }
  }]);

  return FilterStream;
}(_base__WEBPACK_IMPORTED_MODULE_0__["StreamBase"]);

/***/ }),

/***/ "./modules/lstream/index.js":
/*!**********************************!*\
  !*** ./modules/lstream/index.js ***!
  \**********************************/
/*! exports provided: stream, eventStream, combine, merge, state, distinctState, externalState, never, constant, map, filter, merger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stream", function() { return stream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eventStream", function() { return eventStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combine", function() { return combine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "state", function() { return state; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distinctState", function() { return distinctState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "externalState", function() { return externalState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "never", function() { return never; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "constant", function() { return constant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return filter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merger", function() { return merger; });
/* harmony import */ var _combine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./combine */ "./modules/lstream/combine.js");
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./state */ "./modules/lstream/state.js");
/* harmony import */ var _emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./emitter */ "./modules/lstream/emitter.js");
/* harmony import */ var _external__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./external */ "./modules/lstream/external.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./merge */ "./modules/lstream/merge.js");
/* harmony import */ var _never__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./never */ "./modules/lstream/never.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constant */ "./modules/lstream/constant.js");
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./map */ "./modules/lstream/map.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./filter */ "./modules/lstream/filter.js");









function stream() {
  return new _emitter__WEBPACK_IMPORTED_MODULE_2__["Emitter"]();
}
var eventStream = stream;
function combine() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  return new _combine__WEBPACK_IMPORTED_MODULE_0__["CombineStream"](streams);
}
function merge() {
  for (var _len2 = arguments.length, streams = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    streams[_key2] = arguments[_key2];
  }

  return new _merge__WEBPACK_IMPORTED_MODULE_4__["MergeStream"](streams);
}
function state(initialValue) {
  return new _state__WEBPACK_IMPORTED_MODULE_1__["StateStream"](initialValue);
}
function distinctState(initialValue) {
  return new _state__WEBPACK_IMPORTED_MODULE_1__["DistinctStateStream"](initialValue);
}
function externalState(get, set) {
  return new _external__WEBPACK_IMPORTED_MODULE_3__["ExternalStateStream"](get, set);
}
function never() {
  return _never__WEBPACK_IMPORTED_MODULE_5__["NeverStream"].INSTANCE;
}
function constant(value) {
  return new _constant__WEBPACK_IMPORTED_MODULE_6__["ConstantStream"](value);
}
var map = function map(stream, fn) {
  return new _map__WEBPACK_IMPORTED_MODULE_7__["MapStream"](stream, fn);
};
var filter = function filter(stream, predicate) {
  return new _filter__WEBPACK_IMPORTED_MODULE_8__["FilterStream"](stream, predicate);
};
var merger = function merger(states) {
  return states.reduce(function (acc, v) {
    return Object.assign(acc, v);
  }, {});
};

/***/ }),

/***/ "./modules/lstream/map.js":
/*!********************************!*\
  !*** ./modules/lstream/map.js ***!
  \********************************/
/*! exports provided: MapStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MapStream", function() { return MapStream; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./modules/lstream/base.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


var MapStream =
/*#__PURE__*/
function (_StreamBase) {
  _inherits(MapStream, _StreamBase);

  function MapStream(stream, fn) {
    var _this;

    _classCallCheck(this, MapStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MapStream).call(this));
    _this.stream = stream;
    _this.fn = fn;
    return _this;
  }

  _createClass(MapStream, [{
    key: "attach",
    value: function attach(observer) {
      var _this2 = this;

      return this.stream.attach(function (v) {
        return observer(_this2.fn(v));
      });
    }
  }]);

  return MapStream;
}(_base__WEBPACK_IMPORTED_MODULE_0__["StreamBase"]);

/***/ }),

/***/ "./modules/lstream/merge.js":
/*!**********************************!*\
  !*** ./modules/lstream/merge.js ***!
  \**********************************/
/*! exports provided: MergeStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MergeStream", function() { return MergeStream; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./modules/lstream/base.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


var MergeStream =
/*#__PURE__*/
function (_StreamBase) {
  _inherits(MergeStream, _StreamBase);

  function MergeStream(streams) {
    var _this;

    _classCallCheck(this, MergeStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MergeStream).call(this));
    _this.streams = streams;
    return _this;
  }

  _createClass(MergeStream, [{
    key: "attach",
    value: function attach(observer) {
      var detachers = new Array(this.streams.length);
      this.streams.forEach(function (s, i) {
        detachers[i] = s.attach(observer);
      });
      return function () {
        return detachers.forEach(function (d) {
          return d();
        });
      };
    }
  }]);

  return MergeStream;
}(_base__WEBPACK_IMPORTED_MODULE_0__["StreamBase"]);

/***/ }),

/***/ "./modules/lstream/never.js":
/*!**********************************!*\
  !*** ./modules/lstream/never.js ***!
  \**********************************/
/*! exports provided: NeverStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverStream", function() { return NeverStream; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./modules/lstream/base.js");
/* harmony import */ var _gems_func__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gems/func */ "./modules/gems/func.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var NeverStream =
/*#__PURE__*/
function (_StreamBase) {
  _inherits(NeverStream, _StreamBase);

  function NeverStream() {
    _classCallCheck(this, NeverStream);

    return _possibleConstructorReturn(this, _getPrototypeOf(NeverStream).apply(this, arguments));
  }

  _createClass(NeverStream, [{
    key: "attach",
    value: function attach(observer) {
      return _gems_func__WEBPACK_IMPORTED_MODULE_1__["NOOP"];
    }
  }]);

  return NeverStream;
}(_base__WEBPACK_IMPORTED_MODULE_0__["StreamBase"]);
NeverStream.INSTANCE = new NeverStream();

/***/ }),

/***/ "./modules/lstream/pairwise.js":
/*!*************************************!*\
  !*** ./modules/lstream/pairwise.js ***!
  \*************************************/
/*! exports provided: PairwiseStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PairwiseStream", function() { return PairwiseStream; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./modules/lstream/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./modules/lstream/utils.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var PairwiseStream =
/*#__PURE__*/
function (_StreamBase) {
  _inherits(PairwiseStream, _StreamBase);

  function PairwiseStream(stream, first) {
    var _this;

    _classCallCheck(this, PairwiseStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PairwiseStream).call(this));
    _this.stream = stream;
    _this.latest = first === undefined ? _utils__WEBPACK_IMPORTED_MODULE_1__["NOT_INITIALIZED"] : first;
    return _this;
  }

  _createClass(PairwiseStream, [{
    key: "attach",
    value: function attach(observer) {
      var _this2 = this;

      return this.stream.attach(function (v) {
        if (_this2.latest !== _utils__WEBPACK_IMPORTED_MODULE_1__["NOT_INITIALIZED"]) {
          observer([_this2.latest, v]);
        }

        _this2.latest = v;
      });
    }
  }]);

  return PairwiseStream;
}(_base__WEBPACK_IMPORTED_MODULE_0__["StreamBase"]);

/***/ }),

/***/ "./modules/lstream/scan.js":
/*!*********************************!*\
  !*** ./modules/lstream/scan.js ***!
  \*********************************/
/*! exports provided: ScanStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScanStream", function() { return ScanStream; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./modules/lstream/base.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


var ScanStream =
/*#__PURE__*/
function (_StreamBase) {
  _inherits(ScanStream, _StreamBase);

  function ScanStream(stream, initAccumulator) {
    var _this;

    _classCallCheck(this, ScanStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScanStream).call(this));
    _this.stream = stream;
    _this.acc = initAccumulator;
    return _this;
  }

  _createClass(ScanStream, [{
    key: "attach",
    value: function attach(observer) {
      var _this2 = this;

      return this.stream.attach(function (v) {
        return _this2.acc = observer(_this2.acc, v);
      });
    }
  }]);

  return ScanStream;
}(_base__WEBPACK_IMPORTED_MODULE_0__["StreamBase"]);

/***/ }),

/***/ "./modules/lstream/state.js":
/*!**********************************!*\
  !*** ./modules/lstream/state.js ***!
  \**********************************/
/*! exports provided: StateStream, DistinctStateStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StateStream", function() { return StateStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DistinctStateStream", function() { return DistinctStateStream; });
/* harmony import */ var _emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./emitter */ "./modules/lstream/emitter.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


var StateStream =
/*#__PURE__*/
function (_Emitter) {
  _inherits(StateStream, _Emitter);

  function StateStream(initialValue) {
    var _this;

    _classCallCheck(this, StateStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(StateStream).call(this));
    _this._value = initialValue;
    return _this;
  }

  _createClass(StateStream, [{
    key: "next",
    value: function next(v) {
      this._value = v;

      _get(_getPrototypeOf(StateStream.prototype), "next", this).call(this, v);
    }
  }, {
    key: "update",
    value: function update(updater) {
      this.value = updater(this._value);
    }
  }, {
    key: "mutate",
    value: function mutate(mutator) {
      mutator(this._value);
      this.next(this._value);
    }
  }, {
    key: "attach",
    value: function attach(observer) {
      observer(this._value);
      return _get(_getPrototypeOf(StateStream.prototype), "attach", this).call(this, observer);
    }
  }, {
    key: "value",
    get: function get() {
      return this._value;
    },
    set: function set(v) {
      this.next(v);
    }
  }]);

  return StateStream;
}(_emitter__WEBPACK_IMPORTED_MODULE_0__["Emitter"]);
var DistinctStateStream =
/*#__PURE__*/
function (_StateStream) {
  _inherits(DistinctStateStream, _StateStream);

  function DistinctStateStream() {
    _classCallCheck(this, DistinctStateStream);

    return _possibleConstructorReturn(this, _getPrototypeOf(DistinctStateStream).apply(this, arguments));
  }

  _createClass(DistinctStateStream, [{
    key: "next",
    value: function next(v) {
      if (this._value === v) {
        return;
      }

      _get(_getPrototypeOf(DistinctStateStream.prototype), "next", this).call(this, v);
    }
  }]);

  return DistinctStateStream;
}(StateStream);

/***/ }),

/***/ "./modules/lstream/throttle.js":
/*!*************************************!*\
  !*** ./modules/lstream/throttle.js ***!
  \*************************************/
/*! exports provided: ThrottleStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ThrottleStream", function() { return ThrottleStream; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./modules/lstream/base.js");
/* harmony import */ var _emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./emitter */ "./modules/lstream/emitter.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var ThrottleStream =
/*#__PURE__*/
function (_StreamBase) {
  _inherits(ThrottleStream, _StreamBase);

  function ThrottleStream(stream) {
    var _this;

    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var accumulator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (v) {
      return v;
    };

    _classCallCheck(this, ThrottleStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ThrottleStream).call(this));
    _this.stream = stream;
    _this.delay = delay;
    _this.accumulator = accumulator;
    return _this;
  }

  _createClass(ThrottleStream, [{
    key: "attach",
    value: function attach(observer) {
      var _this2 = this;

      var scheduled = false;
      var value = undefined;
      this.stream.attach(function (val) {
        value = _this2.accumulator(val);

        if (!scheduled) {
          setTimeout(function () {
            scheduled = false;
            observer(value);
          });
        }
      }, this.delay);
    }
  }]);

  return ThrottleStream;
}(_base__WEBPACK_IMPORTED_MODULE_0__["StreamBase"]);

/***/ }),

/***/ "./modules/lstream/utils.js":
/*!**********************************!*\
  !*** ./modules/lstream/utils.js ***!
  \**********************************/
/*! exports provided: NOT_INITIALIZED, propsChangeTracker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NOT_INITIALIZED", function() { return NOT_INITIALIZED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "propsChangeTracker", function() { return propsChangeTracker; });
var NOT_INITIALIZED = Object.freeze({});
function propsChangeTracker(props, onChange) {
  var values = props.map(function () {
    return NOT_INITIALIZED;
  });
  return function (obj) {
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      var prevValue = values[i];
      var currValue = obj[prop];

      if (prevValue !== currValue) {
        onChange(obj, prop, currValue, prevValue);
      }
    }
  };
}

/***/ }),

/***/ "./modules/math/vector.js":
/*!********************************!*\
  !*** ./modules/math/vector.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Vector =
/*#__PURE__*/
function () {
  function Vector(x, y, z) {
    _classCallCheck(this, Vector);

    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
  }

  _createClass(Vector, [{
    key: "set",
    value: function set(x, y, z) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      return this;
    }
  }, {
    key: "set3",
    value: function set3(data) {
      this.x = data[0] || 0;
      this.y = data[1] || 0;
      this.z = data[2] || 0;
      return this;
    }
  }, {
    key: "setV",
    value: function setV(data) {
      this.x = data.x;
      this.y = data.y;
      this.z = data.z;
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply(scalar) {
      return new Vector(this.x * scalar, this.y * scalar, this.z * scalar);
    }
  }, {
    key: "_multiply",
    value: function _multiply(scalar) {
      return this.set(this.x * scalar, this.y * scalar, this.z * scalar);
    }
  }, {
    key: "divide",
    value: function divide(scalar) {
      return new Vector(this.x / scalar, this.y / scalar, this.z / scalar);
    }
  }, {
    key: "_divide",
    value: function _divide(scalar) {
      return this.set(this.x / scalar, this.y / scalar, this.z / scalar);
    }
  }, {
    key: "dot",
    value: function dot(vector) {
      return this.x * vector.x + this.y * vector.y + this.z * vector.z;
    }
  }, {
    key: "copy",
    value: function copy() {
      return new Vector(this.x, this.y, this.z);
    }
  }, {
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
  }, {
    key: "lengthSquared",
    value: function lengthSquared() {
      return this.dot(this);
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(a) {
      return this.minus(a).lengthSquared();
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(a) {
      return Math.sqrt(this.distanceToSquared(a));
    }
  }, {
    key: "minus",
    value: function minus(vector) {
      return new Vector(this.x - vector.x, this.y - vector.y, this.z - vector.z);
    }
  }, {
    key: "_minus",
    value: function _minus(vector) {
      this.x -= vector.x;
      this.y -= vector.y;
      this.z -= vector.z;
      return this;
    }
  }, {
    key: "_minusXYZ",
    value: function _minusXYZ(x, y, z) {
      this.x -= x;
      this.y -= y;
      this.z -= z;
      return this;
    }
  }, {
    key: "plusXYZ",
    value: function plusXYZ(x, y, z) {
      return new Vector(this.x + x, this.y + y, this.z + z);
    }
  }, {
    key: "plus",
    value: function plus(vector) {
      return new Vector(this.x + vector.x, this.y + vector.y, this.z + vector.z);
    }
  }, {
    key: "_plus",
    value: function _plus(vector) {
      this.x += vector.x;
      this.y += vector.y;
      this.z += vector.z;
      return this;
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var mag = this.length();

      if (mag === 0.0) {
        return new Vector(0.0, 0.0, 0.0);
      }

      return new Vector(this.x / mag, this.y / mag, this.z / mag);
    }
  }, {
    key: "_normalize",
    value: function _normalize() {
      var mag = this.length();

      if (mag === 0.0) {
        return this.set(0, 0, 0);
      }

      return this.set(this.x / mag, this.y / mag, this.z / mag);
    }
  }, {
    key: "cross",
    value: function cross(a) {
      return this.copy()._cross(a);
    }
  }, {
    key: "_cross",
    value: function _cross(a) {
      return this.set(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x);
    }
  }, {
    key: "negate",
    value: function negate() {
      return this.multiply(-1);
    }
  }, {
    key: "_negate",
    value: function _negate() {
      return this._multiply(-1);
    }
  }, {
    key: "_perpXY",
    value: function _perpXY() {
      return this.set(-this.y, this.x, this.z);
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return [this.x, this.y, this.z];
    }
  }, {
    key: "copyToData",
    value: function copyToData(data) {
      data[0] = this.x;
      data[1] = this.y;
      data[2] = this.z;
    }
  }], [{
    key: "fromData",
    value: function fromData(arr) {
      return new Vector().set3(arr);
    }
  }]);

  return Vector;
}();


Vector.prototype.data = Vector.prototype.toArray;
Vector.prototype.unit = Vector.prototype.normalize;
Vector.prototype._unit = Vector.prototype._normalize;
Vector.prototype.scale = Vector.prototype.multiply;
Vector.prototype._scale = Vector.prototype._multiply;

/***/ }),

/***/ "./node_modules/babel-polyfill/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/babel-polyfill/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(/*! core-js/shim */ "./node_modules/babel-polyfill/node_modules/core-js/shim.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js");

__webpack_require__(/*! core-js/fn/regexp/escape */ "./node_modules/babel-polyfill/node_modules/core-js/fn/regexp/escape.js");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/fn/regexp/escape.js":
/*!******************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/fn/regexp/escape.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/core.regexp.escape */ "./node_modules/babel-polyfill/node_modules/core-js/modules/core.regexp.escape.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_core.js").RegExp.escape;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-number-value.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_a-number-value.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_cof.js");
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_add-to-unscopables.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_add-to-unscopables.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(/*! ./_hide */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js")(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-instance.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_an-instance.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-copy-within.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_array-copy-within.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-absolute-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-fill.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_array-fill.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-absolute-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-from-iterable.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_array-from-iterable.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_for-of.js");

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-includes.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_array-includes.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-methods.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_array-methods.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ctx.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iobject.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var asc = __webpack_require__(/*! ./_array-species-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-species-create.js");
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-reduce.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_array-reduce.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-species-constructor.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_array-species-constructor.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-array.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-species-create.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_array-species-create.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_bind.js":
/*!***************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_bind.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_invoke.js");
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_classof.js":
/*!******************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_classof.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_cof.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_cof.js":
/*!**************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_cof.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_collection-strong.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_collection-strong.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js").f;
var create = __webpack_require__(/*! ./_object-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-create.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine-all.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ctx.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_for-of.js");
var $iterDefine = __webpack_require__(/*! ./_iter-define */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-define.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-step.js");
var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-species.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js");
var fastKey = __webpack_require__(/*! ./_meta */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_meta.js").fastKey;
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_validate-collection.js");
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_collection-to-json.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_collection-to-json.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_classof.js");
var from = __webpack_require__(/*! ./_array-from-iterable */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-from-iterable.js");
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_collection-weak.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_collection-weak.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine-all.js");
var getWeak = __webpack_require__(/*! ./_meta */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_meta.js").getWeak;
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_for-of.js");
var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-methods.js");
var $has = __webpack_require__(/*! ./_has */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_has.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_validate-collection.js");
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_collection.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_collection.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine-all.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_meta.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_for-of.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-instance.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");
var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-detect.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-to-string-tag.js");
var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_inherit-if-required.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_core.js":
/*!***************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_core.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_create-property.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_create-property.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ctx.js":
/*!**************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_ctx.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_date-to-iso-string.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_date-to-iso-string.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_date-to-primitive.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_date-to-primitive.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-primitive.js");
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_defined.js":
/*!******************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_defined.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_dom-create.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_dom-create.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_enum-bug-keys.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_enum-bug-keys.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_enum-keys.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_enum-keys.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-pie.js");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_core.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ctx.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails-is-regexp.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_fails-is-regexp.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js":
/*!****************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fix-re-wks.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_fix-re-wks.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_defined.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js");

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_flags.js":
/*!****************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_flags.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_flatten-into-array.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_flatten-into-array.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-array.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ctx.js");
var IS_CONCAT_SPREADABLE = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_for-of.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_for-of.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ctx.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-array-iter.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/babel-polyfill/node_modules/core-js/modules/core.get-iterator-method.js");
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_has.js":
/*!**************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_has.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js":
/*!***************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_html.js":
/*!***************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_html.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ie8-dom-define.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_ie8-dom-define.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_inherit-if-required.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_inherit-if-required.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var setPrototypeOf = __webpack_require__(/*! ./_set-proto */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-proto.js").set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_invoke.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_invoke.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iobject.js":
/*!******************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_iobject.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-array-iter.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_is-array-iter.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iterators.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-array.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_is-array.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-integer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_is-integer.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-regexp.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_is-regexp.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_cof.js");
var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-call.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-call.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-create.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-create.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-create.js");
var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_property-desc.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(/*! ./_hide */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-define.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-define.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_library.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iterators.js");
var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-create.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gpo.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-detect.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-detect.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-step.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-step.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iterators.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_iterators.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_library.js":
/*!******************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_library.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-expm1.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_math-expm1.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-fround.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_math-fround.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(/*! ./_math-sign */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-sign.js");
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-log1p.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_math-log1p.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-scale.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_math-scale.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-sign.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_math-sign.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_meta.js":
/*!***************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_meta.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_uid.js")('meta');
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_has.js");
var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_metadata.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_metadata.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Map = __webpack_require__(/*! ./es6.map */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.map.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var shared = __webpack_require__(/*! ./_shared */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_shared.js")('metadata');
var store = shared.store || (shared.store = new (__webpack_require__(/*! ./es6.weak-map */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.weak-map.js"))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_microtask.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_microtask.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var macrotask = __webpack_require__(/*! ./_task */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_task.js").set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_new-promise-capability.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_new-promise-capability.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-assign.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-assign.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-pie.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iobject.js");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-create.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-create.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dps.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(/*! ./_html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dps.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dps.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-forced-pam.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-forced-pam.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Forced replacement prototype accessors methods
module.exports = __webpack_require__(/*! ./_library */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_library.js") || !__webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js")[K];
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopd.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopd.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-pie.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_property-desc.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-primitive.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ie8-dom-define.js");
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopn-ext.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopn-ext.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-iobject.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopn.js").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopn.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopn.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-keys-internal.js");
var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gops.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gops.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gpo.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gpo.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_has.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-keys-internal.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-keys-internal.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_has.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-keys.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-keys.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-pie.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-pie.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-sap.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-sap.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_core.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-to-array.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_object-to-array.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-keys.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-iobject.js");
var isEnum = __webpack_require__(/*! ./_object-pie */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-pie.js").f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_own-keys.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_own-keys.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopn.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gops.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var Reflect = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js").Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_parse-float.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_parse-float.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js").parseFloat;
var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-trim.js").trim;

module.exports = 1 / $parseFloat(__webpack_require__(/*! ./_string-ws */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-ws.js") + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_parse-int.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_parse-int.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js").parseInt;
var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-trim.js").trim;
var ws = __webpack_require__(/*! ./_string-ws */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-ws.js");
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_perform.js":
/*!******************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_perform.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_promise-resolve.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_promise-resolve.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_property-desc.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_property-desc.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine-all.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine-all.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js");
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_has.js");
var SRC = __webpack_require__(/*! ./_uid */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_uid.js")('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(/*! ./_core */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_replacer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_replacer.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_same-value.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_same-value.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-collection-from.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_set-collection-from.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ctx.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_for-of.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-collection-of.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_set-collection-of.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-proto.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_set-proto.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ctx.js")(Function.call, __webpack_require__(/*! ./_object-gopd */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-species.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_set-species.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-to-string-tag.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_set-to-string-tag.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js").f;
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_has.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_shared-key.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_shared-key.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_shared.js")('keys');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_shared.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_shared.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_library.js") ? 'pure' : 'global',
  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_species-constructor.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_species-constructor.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_strict-method.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_strict-method.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-at.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_string-at.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-integer.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-context.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_string-context.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-regexp.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_defined.js");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_defined.js");
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-pad.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_string-pad.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var repeat = __webpack_require__(/*! ./_string-repeat */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-repeat.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_defined.js");

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-repeat.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_string-repeat.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-integer.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_defined.js");

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-trim.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_string-trim.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_defined.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");
var spaces = __webpack_require__(/*! ./_string-ws */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-ws.js");
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-ws.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_string-ws.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_task.js":
/*!***************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_task.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ctx.js");
var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_invoke.js");
var html = __webpack_require__(/*! ./_html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_html.js");
var cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_dom-create.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(/*! ./_cof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_cof.js")(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-absolute-index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_to-absolute-index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_to-index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-integer.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-integer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_to-integer.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-iobject.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_to-iobject.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iobject.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-primitive.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_to-primitive.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-array.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-array.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js")) {
  var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_library.js");
  var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
  var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");
  var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
  var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed.js");
  var $buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-buffer.js");
  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ctx.js");
  var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-instance.js");
  var propertyDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_property-desc.js");
  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js");
  var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine-all.js");
  var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-integer.js");
  var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
  var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-index.js");
  var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-absolute-index.js");
  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-primitive.js");
  var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_has.js");
  var classof = __webpack_require__(/*! ./_classof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_classof.js");
  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
  var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-array-iter.js");
  var create = __webpack_require__(/*! ./_object-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-create.js");
  var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gpo.js");
  var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopn.js").f;
  var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/babel-polyfill/node_modules/core-js/modules/core.get-iterator-method.js");
  var uid = __webpack_require__(/*! ./_uid */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_uid.js");
  var wks = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js");
  var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-methods.js");
  var createArrayIncludes = __webpack_require__(/*! ./_array-includes */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-includes.js");
  var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_species-constructor.js");
  var ArrayIterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.iterator.js");
  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iterators.js");
  var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-detect.js");
  var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-species.js");
  var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-fill.js");
  var arrayCopyWithin = __webpack_require__(/*! ./_array-copy-within */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-copy-within.js");
  var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js");
  var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopd.js");
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-buffer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-buffer.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js");
var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_library.js");
var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine-all.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-instance.js");
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-integer.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-index.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopn.js").f;
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js").f;
var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-fill.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-to-string-tag.js");
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed.js":
/*!****************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_typed.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js");
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_uid.js");
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_uid.js":
/*!**************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_uid.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_user-agent.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_user-agent.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_validate-collection.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_validate-collection.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks-define.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_wks-define.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_core.js");
var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_library.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks-ext.js");
var defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks-ext.js":
/*!******************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_wks-ext.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js");


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js":
/*!**************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_shared.js")('wks');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_uid.js");
var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/core.get-iterator-method.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/core.get-iterator-method.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_classof.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('iterator');
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iterators.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/core.regexp.escape.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/core.regexp.escape.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/benjamingr/RexExp.escape
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $re = __webpack_require__(/*! ./_replacer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_replacer.js")(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.copy-within.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.copy-within.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', { copyWithin: __webpack_require__(/*! ./_array-copy-within */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-copy-within.js") });

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_add-to-unscopables.js")('copyWithin');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.every.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.every.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $every = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-methods.js")(4);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_strict-method.js")([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.fill.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.fill.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', { fill: __webpack_require__(/*! ./_array-fill */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-fill.js") });

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_add-to-unscopables.js")('fill');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.filter.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.filter.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $filter = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-methods.js")(2);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_strict-method.js")([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.find-index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.find-index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $find = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-methods.js")(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_add-to-unscopables.js")(KEY);


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.find.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.find.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $find = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-methods.js")(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_add-to-unscopables.js")(KEY);


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.for-each.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.for-each.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $forEach = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-methods.js")(0);
var STRICT = __webpack_require__(/*! ./_strict-method */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_strict-method.js")([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.from.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.from.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ctx.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-array-iter.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_create-property.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/babel-polyfill/node_modules/core-js/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-detect.js")(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.index-of.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.index-of.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $indexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-includes.js")(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.is-array.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.is-array.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Array', { isArray: __webpack_require__(/*! ./_is-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-array.js") });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.iterator.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.iterator.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_add-to-unscopables.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-step.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iterators.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.join.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.join.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.13 Array.prototype.join(separator)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-iobject.js");
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (__webpack_require__(/*! ./_iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iobject.js") != Object || !__webpack_require__(/*! ./_strict-method */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_strict-method.js")(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.last-index-of.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.last-index-of.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-iobject.js");
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-integer.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.map.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.map.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $map = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-methods.js")(1);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_strict-method.js")([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.of.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.of.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_create-property.js");

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.reduce-right.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.reduce-right.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_strict-method.js")([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.reduce.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.reduce.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_strict-method.js")([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.slice.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.slice.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var html = __webpack_require__(/*! ./_html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_html.js");
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_cof.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-absolute-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.some.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.some.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $some = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-methods.js")(3);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_strict-method.js")([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.sort.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.sort.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(/*! ./_strict-method */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_strict-method.js")($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.species.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.species.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_set-species */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-species.js")('Array');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.now.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.now.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.to-iso-string.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.to-iso-string.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var toISOString = __webpack_require__(/*! ./_date-to-iso-string */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_date-to-iso-string.js");

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.to-json.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.to-json.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-primitive.js");

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.to-primitive.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.to-primitive.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) __webpack_require__(/*! ./_hide */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js")(proto, TO_PRIMITIVE, __webpack_require__(/*! ./_date-to-primitive */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_date-to-primitive.js"));


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.to-string.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.to-string.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js")(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.function.bind.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.function.bind.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.P, 'Function', { bind: __webpack_require__(/*! ./_bind */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_bind.js") });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.function.has-instance.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.function.has-instance.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gpo.js");
var HAS_INSTANCE = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js").f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.function.name.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.function.name.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js").f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js") && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.map.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.map.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_collection-strong.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_validate-collection.js");
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_collection.js")(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.acosh.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.acosh.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var log1p = __webpack_require__(/*! ./_math-log1p */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-log1p.js");
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.asinh.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.asinh.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.atanh.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.atanh.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.cbrt.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.cbrt.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var sign = __webpack_require__(/*! ./_math-sign */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-sign.js");

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.clz32.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.clz32.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.cosh.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.cosh.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.expm1.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.expm1.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-expm1.js");

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.fround.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.fround.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', { fround: __webpack_require__(/*! ./_math-fround */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-fround.js") });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.hypot.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.hypot.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.imul.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.imul.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.log10.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.log10.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.log1p.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.log1p.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', { log1p: __webpack_require__(/*! ./_math-log1p */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-log1p.js") });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.log2.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.log2.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.sign.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.sign.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', { sign: __webpack_require__(/*! ./_math-sign */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-sign.js") });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.sinh.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.sinh.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-expm1.js");
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.tanh.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.tanh.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-expm1.js");
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.trunc.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.trunc.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.constructor.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.constructor.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_has.js");
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_cof.js");
var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_inherit-if-required.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-primitive.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopn.js").f;
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopd.js").f;
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js").f;
var $trim = __webpack_require__(/*! ./_string-trim */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-trim.js").trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__(/*! ./_object-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-create.js")(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js") ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(/*! ./_redefine */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js")(global, NUMBER, $Number);
}


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.epsilon.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.epsilon.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.is-finite.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.is-finite.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var _isFinite = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js").isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.is-integer.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.is-integer.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', { isInteger: __webpack_require__(/*! ./_is-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-integer.js") });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.is-nan.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.is-nan.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.is-safe-integer.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.is-safe-integer.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var isInteger = __webpack_require__(/*! ./_is-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-integer.js");
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.max-safe-integer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.max-safe-integer.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.min-safe-integer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.min-safe-integer.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.parse-float.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.parse-float.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $parseFloat = __webpack_require__(/*! ./_parse-float */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_parse-float.js");
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.parse-int.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.parse-int.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $parseInt = __webpack_require__(/*! ./_parse-int */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_parse-int.js");
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.to-fixed.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.to-fixed.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-integer.js");
var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-number-value.js");
var repeat = __webpack_require__(/*! ./_string-repeat */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-repeat.js");
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.to-precision.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.to-precision.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");
var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-number-value.js");
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.assign.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.assign.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-assign.js") });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.create.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.create.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(/*! ./_object-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-create.js") });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.define-properties.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.define-properties.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js"), 'Object', { defineProperties: __webpack_require__(/*! ./_object-dps */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dps.js") });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.define-property.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.define-property.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js").f });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.freeze.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.freeze.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-sap.js")('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.get-own-property-descriptor.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-iobject.js");
var $getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopd.js").f;

__webpack_require__(/*! ./_object-sap */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-sap.js")('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.get-own-property-names.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.get-own-property-names.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(/*! ./_object-sap */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-sap.js")('getOwnPropertyNames', function () {
  return __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopn-ext.js").f;
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.get-prototype-of.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.get-prototype-of.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var $getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gpo.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-sap.js")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.is-extensible.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.is-extensible.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-sap.js")('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.is-frozen.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.is-frozen.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-sap.js")('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.is-sealed.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.is-sealed.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-sap.js")('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.is.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.is.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
$export($export.S, 'Object', { is: __webpack_require__(/*! ./_same-value */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_same-value.js") });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.keys.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.keys.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.prevent-extensions.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.prevent-extensions.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-sap.js")('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.seal.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.seal.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-sap.js")('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.set-prototype-of.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.set-prototype-of.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(/*! ./_set-proto */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-proto.js").set });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.to-string.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.to-string.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_classof.js");
var test = {};
test[__webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(/*! ./_redefine */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js")(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.parse-float.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.parse-float.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $parseFloat = __webpack_require__(/*! ./_parse-float */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_parse-float.js");
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.parse-int.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.parse-int.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $parseInt = __webpack_require__(/*! ./_parse-int */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_parse-int.js");
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.promise.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.promise.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_library.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_ctx.js");
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_classof.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_for-of.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_species-constructor.js");
var task = __webpack_require__(/*! ./_task */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_task.js").set;
var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_microtask.js")();
var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_new-promise-capability.js");
var perform = __webpack_require__(/*! ./_perform */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_perform.js");
var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_user-agent.js");
var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_promise-resolve.js");
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-to-string-tag.js")($Promise, PROMISE);
__webpack_require__(/*! ./_set-species */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-species.js")(PROMISE);
Wrapper = __webpack_require__(/*! ./_core */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_core.js")[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.apply.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.apply.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var rApply = (__webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js").Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.construct.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.construct.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var create = __webpack_require__(/*! ./_object-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-create.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");
var bind = __webpack_require__(/*! ./_bind */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_bind.js");
var rConstruct = (__webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js").Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.define-property.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.define-property.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-primitive.js");

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.delete-property.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.delete-property.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopd.js").f;
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.enumerate.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.enumerate.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 26.1.5 Reflect.enumerate(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
__webpack_require__(/*! ./_iter-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-create.js")(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopd.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.get-prototype-of.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.get-prototype-of.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var getProto = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gpo.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.get.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.get.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopd.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gpo.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_has.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.has.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.has.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.is-extensible.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.is-extensible.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.own-keys.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.own-keys.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(/*! ./_own-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_own-keys.js") });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.prevent-extensions.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.prevent-extensions.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.set-prototype-of.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.set-prototype-of.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var setProto = __webpack_require__(/*! ./_set-proto */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-proto.js");

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.set.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.set.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js");
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopd.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gpo.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_has.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_property-desc.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.constructor.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.constructor.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_inherit-if-required.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js").f;
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopn.js").f;
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-regexp.js");
var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_flags.js");
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js") && (!CORRECT_NEW || __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  re2[__webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(/*! ./_redefine */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js")(global, 'RegExp', $RegExp);
}

__webpack_require__(/*! ./_set-species */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-species.js")('RegExp');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.flags.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.flags.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js") && /./g.flags != 'g') __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js").f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(/*! ./_flags */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_flags.js")
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.match.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.match.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// @@match logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fix-re-wks.js")('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.replace.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.replace.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// @@replace logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fix-re-wks.js")('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.search.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.search.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// @@search logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fix-re-wks.js")('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.split.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.split.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// @@split logic
__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fix-re-wks.js")('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-regexp.js");
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.to-string.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.to-string.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(/*! ./es6.regexp.flags */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.flags.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_flags.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js");
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js")(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.set.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.set.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_collection-strong.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_validate-collection.js");
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_collection.js")(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.anchor.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.anchor.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)
__webpack_require__(/*! ./_string-html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js")('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.big.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.big.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.3 String.prototype.big()
__webpack_require__(/*! ./_string-html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js")('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.blink.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.blink.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.4 String.prototype.blink()
__webpack_require__(/*! ./_string-html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js")('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.bold.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.bold.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.5 String.prototype.bold()
__webpack_require__(/*! ./_string-html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js")('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.code-point-at.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.code-point-at.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-at.js")(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.ends-with.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.ends-with.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var context = __webpack_require__(/*! ./_string-context */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-context.js");
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails-is-regexp.js")(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.fixed.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.fixed.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.6 String.prototype.fixed()
__webpack_require__(/*! ./_string-html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js")('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.fontcolor.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.fontcolor.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.7 String.prototype.fontcolor(color)
__webpack_require__(/*! ./_string-html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js")('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.fontsize.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.fontsize.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.8 String.prototype.fontsize(size)
__webpack_require__(/*! ./_string-html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js")('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.from-code-point.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.from-code-point.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-absolute-index.js");
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.includes.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.includes.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var context = __webpack_require__(/*! ./_string-context */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-context.js");
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails-is-regexp.js")(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.italics.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.italics.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.9 String.prototype.italics()
__webpack_require__(/*! ./_string-html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js")('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.iterator.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.iterator.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-at.js")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(/*! ./_iter-define */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.link.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.link.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.10 String.prototype.link(url)
__webpack_require__(/*! ./_string-html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js")('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.raw.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.raw.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.repeat.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.repeat.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(/*! ./_string-repeat */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-repeat.js")
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.small.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.small.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.11 String.prototype.small()
__webpack_require__(/*! ./_string-html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js")('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.starts-with.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.starts-with.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var context = __webpack_require__(/*! ./_string-context */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-context.js");
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails-is-regexp.js")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.strike.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.strike.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.12 String.prototype.strike()
__webpack_require__(/*! ./_string-html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js")('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.sub.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.sub.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.13 String.prototype.sub()
__webpack_require__(/*! ./_string-html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js")('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.sup.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.sup.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.14 String.prototype.sup()
__webpack_require__(/*! ./_string-html */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-html.js")('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.trim.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.trim.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.1.3.25 String.prototype.trim()
__webpack_require__(/*! ./_string-trim */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-trim.js")('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.symbol.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.symbol.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_has.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js");
var META = __webpack_require__(/*! ./_meta */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_meta.js").KEY;
var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");
var shared = __webpack_require__(/*! ./_shared */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_shared.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-to-string-tag.js");
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_uid.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks-ext.js");
var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks-define.js");
var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_enum-keys.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-array.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-primitive.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_property-desc.js");
var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-create.js");
var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopn-ext.js");
var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopd.js");
var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-keys.js");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-pie.js").f = $propertyIsEnumerable;
  __webpack_require__(/*! ./_object-gops */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gops.js").f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.array-buffer.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.array-buffer.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed.js");
var buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-buffer.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-absolute-index.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var ArrayBuffer = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js").ArrayBuffer;
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_species-constructor.js");
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

__webpack_require__(/*! ./_set-species */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-species.js")(ARRAY_BUFFER);


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.data-view.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.data-view.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
$export($export.G + $export.W + $export.F * !__webpack_require__(/*! ./_typed */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed.js").ABV, {
  DataView: __webpack_require__(/*! ./_typed-buffer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-buffer.js").DataView
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.float32-array.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.float32-array.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-array.js")('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.float64-array.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.float64-array.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-array.js")('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.int16-array.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.int16-array.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-array.js")('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.int32-array.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.int32-array.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-array.js")('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.int8-array.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.int8-array.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-array.js")('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.uint16-array.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.uint16-array.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-array.js")('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.uint32-array.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.uint32-array.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-array.js")('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.uint8-array.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.uint8-array.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.uint8-clamped-array.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.weak-map.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.weak-map.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var each = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-methods.js")(0);
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_meta.js");
var assign = __webpack_require__(/*! ./_object-assign */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-assign.js");
var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_collection-weak.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-object.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_fails.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_validate-collection.js");
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_collection.js")(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.weak-set.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es6.weak-set.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_collection-weak.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_validate-collection.js");
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(/*! ./_collection */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_collection.js")(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.array.flat-map.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.array.flat-map.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_flatten-into-array.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");
var arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_add-to-unscopables.js")('flatMap');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.array.flatten.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.array.flatten.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_flatten-into-array.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-integer.js");
var arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_add-to-unscopables.js")('flatten');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.array.includes.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.array.includes.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $includes = __webpack_require__(/*! ./_array-includes */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-includes.js")(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_add-to-unscopables.js")('includes');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.asap.js":
/*!******************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.asap.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_microtask.js")();
var process = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js").process;
var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_cof.js")(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.error.is-error.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.error.is-error.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_cof.js");

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.global.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.global.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.G, { global: __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js") });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.map.from.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.map.from.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-collection-from.js")('Map');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.map.of.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.map.of.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-collection-of.js")('Map');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.map.to-json.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.map.to-json.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(/*! ./_collection-to-json */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_collection-to-json.js")('Map') });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.clamp.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.clamp.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.deg-per-rad.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.deg-per-rad.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.degrees.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.degrees.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.fscale.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.fscale.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var scale = __webpack_require__(/*! ./_math-scale */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-scale.js");
var fround = __webpack_require__(/*! ./_math-fround */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-fround.js");

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.iaddh.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.iaddh.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.imulh.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.imulh.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.isubh.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.isubh.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.rad-per-deg.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.rad-per-deg.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.radians.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.radians.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.scale.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.scale.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', { scale: __webpack_require__(/*! ./_math-scale */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_math-scale.js") });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.signbit.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.signbit.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// http://jfbastien.github.io/papers/Math.signbit.html
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.umulh.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.umulh.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.define-getter.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.define-getter.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");
var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js");

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.define-setter.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.define-setter.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");
var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-dp.js");

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.entries.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.entries.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $entries = __webpack_require__(/*! ./_object-to-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-to-array.js")(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.get-own-property-descriptors.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var ownKeys = __webpack_require__(/*! ./_own-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_own-keys.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-iobject.js");
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopd.js");
var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_create-property.js");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.lookup-getter.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.lookup-getter.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-primitive.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gpo.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopd.js").f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.lookup-setter.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.lookup-setter.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-object.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-primitive.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gpo.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gopd.js").f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_descriptors.js") && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-forced-pam.js"), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.values.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.values.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $values = __webpack_require__(/*! ./_object-to-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-to-array.js")(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.observable.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.observable.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/zenparsing/es-observable
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_core.js");
var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_microtask.js")();
var OBSERVABLE = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js")('observable');
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-instance.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine-all.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_for-of.js");
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

__webpack_require__(/*! ./_set-species */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-species.js")('Observable');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.promise.finally.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.promise.finally.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_species-constructor.js");
var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.promise.try.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.promise.try.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_new-promise-capability.js");
var perform = __webpack_require__(/*! ./_perform */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_perform.js");

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.define-metadata.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.define-metadata.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_metadata.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.delete-metadata.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.delete-metadata.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_metadata.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.get-metadata-keys.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.get-metadata-keys.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(/*! ./es6.set */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.set.js");
var from = __webpack_require__(/*! ./_array-from-iterable */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_array-from-iterable.js");
var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_metadata.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gpo.js");
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.get-metadata.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.get-metadata.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_metadata.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gpo.js");
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_metadata.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.get-own-metadata.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.get-own-metadata.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_metadata.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.has-metadata.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.has-metadata.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_metadata.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-gpo.js");
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.has-own-metadata.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.has-own-metadata.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_metadata.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.metadata.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.metadata.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $metadata = __webpack_require__(/*! ./_metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_metadata.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_an-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_a-function.js");
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.set.from.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.set.from.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-collection-from.js")('Set');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.set.of.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.set.of.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-collection-of.js")('Set');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.set.to-json.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.set.to-json.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(/*! ./_collection-to-json */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_collection-to-json.js")('Set') });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.at.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.at.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/mathiasbynens/String.prototype.at
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-at.js")(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.match-all.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.match-all.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/String.prototype.matchAll/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_defined.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_to-length.js");
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_is-regexp.js");
var getFlags = __webpack_require__(/*! ./_flags */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_flags.js");
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

__webpack_require__(/*! ./_iter-create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iter-create.js")($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.pad-end.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.pad-end.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $pad = __webpack_require__(/*! ./_string-pad */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-pad.js");
var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_user-agent.js");

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.pad-start.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.pad-start.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $pad = __webpack_require__(/*! ./_string-pad */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-pad.js");
var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_user-agent.js");

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.trim-left.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.trim-left.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(/*! ./_string-trim */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-trim.js")('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.trim-right.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.trim-right.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(/*! ./_string-trim */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_string-trim.js")('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.symbol.async-iterator.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.symbol.async-iterator.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks-define.js")('asyncIterator');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.symbol.observable.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.symbol.observable.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks-define.js")('observable');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.system.global.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.system.global.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'System', { global: __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js") });


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.weak-map.from.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.weak-map.from.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-collection-from.js")('WeakMap');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.weak-map.of.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.weak-map.of.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-collection-of.js")('WeakMap');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.weak-set.from.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.weak-set.from.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-collection-from.js")('WeakSet');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.weak-set.of.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/es7.weak-set.of.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_set-collection-of.js")('WeakSet');


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/web.dom.iterable.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/web.dom.iterable.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.iterator.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_object-keys.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_redefine.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_iterators.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_wks.js");
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/web.immediate.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/web.immediate.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var $task = __webpack_require__(/*! ./_task */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_task.js");
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/modules/web.timers.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/modules/web.timers.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_global.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_export.js");
var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_user-agent.js");
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/core-js/shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/core-js/shim.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./modules/es6.symbol */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.symbol.js");
__webpack_require__(/*! ./modules/es6.object.create */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.create.js");
__webpack_require__(/*! ./modules/es6.object.define-property */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.define-property.js");
__webpack_require__(/*! ./modules/es6.object.define-properties */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.define-properties.js");
__webpack_require__(/*! ./modules/es6.object.get-own-property-descriptor */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.get-own-property-descriptor.js");
__webpack_require__(/*! ./modules/es6.object.get-prototype-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.get-prototype-of.js");
__webpack_require__(/*! ./modules/es6.object.keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.keys.js");
__webpack_require__(/*! ./modules/es6.object.get-own-property-names */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.get-own-property-names.js");
__webpack_require__(/*! ./modules/es6.object.freeze */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.freeze.js");
__webpack_require__(/*! ./modules/es6.object.seal */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.seal.js");
__webpack_require__(/*! ./modules/es6.object.prevent-extensions */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.prevent-extensions.js");
__webpack_require__(/*! ./modules/es6.object.is-frozen */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.is-frozen.js");
__webpack_require__(/*! ./modules/es6.object.is-sealed */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.is-sealed.js");
__webpack_require__(/*! ./modules/es6.object.is-extensible */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.is-extensible.js");
__webpack_require__(/*! ./modules/es6.object.assign */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.assign.js");
__webpack_require__(/*! ./modules/es6.object.is */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.is.js");
__webpack_require__(/*! ./modules/es6.object.set-prototype-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.set-prototype-of.js");
__webpack_require__(/*! ./modules/es6.object.to-string */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.object.to-string.js");
__webpack_require__(/*! ./modules/es6.function.bind */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.function.bind.js");
__webpack_require__(/*! ./modules/es6.function.name */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.function.name.js");
__webpack_require__(/*! ./modules/es6.function.has-instance */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.function.has-instance.js");
__webpack_require__(/*! ./modules/es6.parse-int */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.parse-int.js");
__webpack_require__(/*! ./modules/es6.parse-float */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.parse-float.js");
__webpack_require__(/*! ./modules/es6.number.constructor */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.constructor.js");
__webpack_require__(/*! ./modules/es6.number.to-fixed */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.to-fixed.js");
__webpack_require__(/*! ./modules/es6.number.to-precision */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.to-precision.js");
__webpack_require__(/*! ./modules/es6.number.epsilon */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.epsilon.js");
__webpack_require__(/*! ./modules/es6.number.is-finite */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.is-finite.js");
__webpack_require__(/*! ./modules/es6.number.is-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.is-integer.js");
__webpack_require__(/*! ./modules/es6.number.is-nan */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.is-nan.js");
__webpack_require__(/*! ./modules/es6.number.is-safe-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.is-safe-integer.js");
__webpack_require__(/*! ./modules/es6.number.max-safe-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.max-safe-integer.js");
__webpack_require__(/*! ./modules/es6.number.min-safe-integer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.min-safe-integer.js");
__webpack_require__(/*! ./modules/es6.number.parse-float */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.parse-float.js");
__webpack_require__(/*! ./modules/es6.number.parse-int */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.number.parse-int.js");
__webpack_require__(/*! ./modules/es6.math.acosh */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.acosh.js");
__webpack_require__(/*! ./modules/es6.math.asinh */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.asinh.js");
__webpack_require__(/*! ./modules/es6.math.atanh */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.atanh.js");
__webpack_require__(/*! ./modules/es6.math.cbrt */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.cbrt.js");
__webpack_require__(/*! ./modules/es6.math.clz32 */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.clz32.js");
__webpack_require__(/*! ./modules/es6.math.cosh */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.cosh.js");
__webpack_require__(/*! ./modules/es6.math.expm1 */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.expm1.js");
__webpack_require__(/*! ./modules/es6.math.fround */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.fround.js");
__webpack_require__(/*! ./modules/es6.math.hypot */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.hypot.js");
__webpack_require__(/*! ./modules/es6.math.imul */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.imul.js");
__webpack_require__(/*! ./modules/es6.math.log10 */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.log10.js");
__webpack_require__(/*! ./modules/es6.math.log1p */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.log1p.js");
__webpack_require__(/*! ./modules/es6.math.log2 */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.log2.js");
__webpack_require__(/*! ./modules/es6.math.sign */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.sign.js");
__webpack_require__(/*! ./modules/es6.math.sinh */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.sinh.js");
__webpack_require__(/*! ./modules/es6.math.tanh */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.tanh.js");
__webpack_require__(/*! ./modules/es6.math.trunc */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.math.trunc.js");
__webpack_require__(/*! ./modules/es6.string.from-code-point */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.from-code-point.js");
__webpack_require__(/*! ./modules/es6.string.raw */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.raw.js");
__webpack_require__(/*! ./modules/es6.string.trim */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.trim.js");
__webpack_require__(/*! ./modules/es6.string.iterator */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.iterator.js");
__webpack_require__(/*! ./modules/es6.string.code-point-at */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.code-point-at.js");
__webpack_require__(/*! ./modules/es6.string.ends-with */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.ends-with.js");
__webpack_require__(/*! ./modules/es6.string.includes */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.includes.js");
__webpack_require__(/*! ./modules/es6.string.repeat */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.repeat.js");
__webpack_require__(/*! ./modules/es6.string.starts-with */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.starts-with.js");
__webpack_require__(/*! ./modules/es6.string.anchor */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.anchor.js");
__webpack_require__(/*! ./modules/es6.string.big */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.big.js");
__webpack_require__(/*! ./modules/es6.string.blink */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.blink.js");
__webpack_require__(/*! ./modules/es6.string.bold */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.bold.js");
__webpack_require__(/*! ./modules/es6.string.fixed */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.fixed.js");
__webpack_require__(/*! ./modules/es6.string.fontcolor */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.fontcolor.js");
__webpack_require__(/*! ./modules/es6.string.fontsize */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.fontsize.js");
__webpack_require__(/*! ./modules/es6.string.italics */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.italics.js");
__webpack_require__(/*! ./modules/es6.string.link */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.link.js");
__webpack_require__(/*! ./modules/es6.string.small */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.small.js");
__webpack_require__(/*! ./modules/es6.string.strike */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.strike.js");
__webpack_require__(/*! ./modules/es6.string.sub */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.sub.js");
__webpack_require__(/*! ./modules/es6.string.sup */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.string.sup.js");
__webpack_require__(/*! ./modules/es6.date.now */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.now.js");
__webpack_require__(/*! ./modules/es6.date.to-json */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.to-json.js");
__webpack_require__(/*! ./modules/es6.date.to-iso-string */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.to-iso-string.js");
__webpack_require__(/*! ./modules/es6.date.to-string */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.to-string.js");
__webpack_require__(/*! ./modules/es6.date.to-primitive */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.date.to-primitive.js");
__webpack_require__(/*! ./modules/es6.array.is-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.is-array.js");
__webpack_require__(/*! ./modules/es6.array.from */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.from.js");
__webpack_require__(/*! ./modules/es6.array.of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.of.js");
__webpack_require__(/*! ./modules/es6.array.join */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.join.js");
__webpack_require__(/*! ./modules/es6.array.slice */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.slice.js");
__webpack_require__(/*! ./modules/es6.array.sort */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.sort.js");
__webpack_require__(/*! ./modules/es6.array.for-each */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.for-each.js");
__webpack_require__(/*! ./modules/es6.array.map */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.map.js");
__webpack_require__(/*! ./modules/es6.array.filter */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.filter.js");
__webpack_require__(/*! ./modules/es6.array.some */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.some.js");
__webpack_require__(/*! ./modules/es6.array.every */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.every.js");
__webpack_require__(/*! ./modules/es6.array.reduce */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.reduce.js");
__webpack_require__(/*! ./modules/es6.array.reduce-right */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.reduce-right.js");
__webpack_require__(/*! ./modules/es6.array.index-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.index-of.js");
__webpack_require__(/*! ./modules/es6.array.last-index-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.last-index-of.js");
__webpack_require__(/*! ./modules/es6.array.copy-within */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.copy-within.js");
__webpack_require__(/*! ./modules/es6.array.fill */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.fill.js");
__webpack_require__(/*! ./modules/es6.array.find */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.find.js");
__webpack_require__(/*! ./modules/es6.array.find-index */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.find-index.js");
__webpack_require__(/*! ./modules/es6.array.species */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.species.js");
__webpack_require__(/*! ./modules/es6.array.iterator */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.array.iterator.js");
__webpack_require__(/*! ./modules/es6.regexp.constructor */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.constructor.js");
__webpack_require__(/*! ./modules/es6.regexp.to-string */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.to-string.js");
__webpack_require__(/*! ./modules/es6.regexp.flags */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.flags.js");
__webpack_require__(/*! ./modules/es6.regexp.match */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.match.js");
__webpack_require__(/*! ./modules/es6.regexp.replace */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.replace.js");
__webpack_require__(/*! ./modules/es6.regexp.search */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.search.js");
__webpack_require__(/*! ./modules/es6.regexp.split */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.regexp.split.js");
__webpack_require__(/*! ./modules/es6.promise */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.promise.js");
__webpack_require__(/*! ./modules/es6.map */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.map.js");
__webpack_require__(/*! ./modules/es6.set */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.set.js");
__webpack_require__(/*! ./modules/es6.weak-map */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.weak-map.js");
__webpack_require__(/*! ./modules/es6.weak-set */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.weak-set.js");
__webpack_require__(/*! ./modules/es6.typed.array-buffer */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.array-buffer.js");
__webpack_require__(/*! ./modules/es6.typed.data-view */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.data-view.js");
__webpack_require__(/*! ./modules/es6.typed.int8-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.int8-array.js");
__webpack_require__(/*! ./modules/es6.typed.uint8-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.uint8-array.js");
__webpack_require__(/*! ./modules/es6.typed.uint8-clamped-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.uint8-clamped-array.js");
__webpack_require__(/*! ./modules/es6.typed.int16-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.int16-array.js");
__webpack_require__(/*! ./modules/es6.typed.uint16-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.uint16-array.js");
__webpack_require__(/*! ./modules/es6.typed.int32-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.int32-array.js");
__webpack_require__(/*! ./modules/es6.typed.uint32-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.uint32-array.js");
__webpack_require__(/*! ./modules/es6.typed.float32-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.float32-array.js");
__webpack_require__(/*! ./modules/es6.typed.float64-array */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.typed.float64-array.js");
__webpack_require__(/*! ./modules/es6.reflect.apply */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.apply.js");
__webpack_require__(/*! ./modules/es6.reflect.construct */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.construct.js");
__webpack_require__(/*! ./modules/es6.reflect.define-property */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.define-property.js");
__webpack_require__(/*! ./modules/es6.reflect.delete-property */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.delete-property.js");
__webpack_require__(/*! ./modules/es6.reflect.enumerate */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.enumerate.js");
__webpack_require__(/*! ./modules/es6.reflect.get */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.get.js");
__webpack_require__(/*! ./modules/es6.reflect.get-own-property-descriptor */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js");
__webpack_require__(/*! ./modules/es6.reflect.get-prototype-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.get-prototype-of.js");
__webpack_require__(/*! ./modules/es6.reflect.has */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.has.js");
__webpack_require__(/*! ./modules/es6.reflect.is-extensible */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.is-extensible.js");
__webpack_require__(/*! ./modules/es6.reflect.own-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.own-keys.js");
__webpack_require__(/*! ./modules/es6.reflect.prevent-extensions */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.prevent-extensions.js");
__webpack_require__(/*! ./modules/es6.reflect.set */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.set.js");
__webpack_require__(/*! ./modules/es6.reflect.set-prototype-of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es6.reflect.set-prototype-of.js");
__webpack_require__(/*! ./modules/es7.array.includes */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.array.includes.js");
__webpack_require__(/*! ./modules/es7.array.flat-map */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.array.flat-map.js");
__webpack_require__(/*! ./modules/es7.array.flatten */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.array.flatten.js");
__webpack_require__(/*! ./modules/es7.string.at */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.at.js");
__webpack_require__(/*! ./modules/es7.string.pad-start */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.pad-start.js");
__webpack_require__(/*! ./modules/es7.string.pad-end */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.pad-end.js");
__webpack_require__(/*! ./modules/es7.string.trim-left */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.trim-left.js");
__webpack_require__(/*! ./modules/es7.string.trim-right */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.trim-right.js");
__webpack_require__(/*! ./modules/es7.string.match-all */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.string.match-all.js");
__webpack_require__(/*! ./modules/es7.symbol.async-iterator */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.symbol.async-iterator.js");
__webpack_require__(/*! ./modules/es7.symbol.observable */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.symbol.observable.js");
__webpack_require__(/*! ./modules/es7.object.get-own-property-descriptors */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.get-own-property-descriptors.js");
__webpack_require__(/*! ./modules/es7.object.values */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.values.js");
__webpack_require__(/*! ./modules/es7.object.entries */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.entries.js");
__webpack_require__(/*! ./modules/es7.object.define-getter */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.define-getter.js");
__webpack_require__(/*! ./modules/es7.object.define-setter */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.define-setter.js");
__webpack_require__(/*! ./modules/es7.object.lookup-getter */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.lookup-getter.js");
__webpack_require__(/*! ./modules/es7.object.lookup-setter */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.object.lookup-setter.js");
__webpack_require__(/*! ./modules/es7.map.to-json */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.map.to-json.js");
__webpack_require__(/*! ./modules/es7.set.to-json */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.set.to-json.js");
__webpack_require__(/*! ./modules/es7.map.of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.map.of.js");
__webpack_require__(/*! ./modules/es7.set.of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.set.of.js");
__webpack_require__(/*! ./modules/es7.weak-map.of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.weak-map.of.js");
__webpack_require__(/*! ./modules/es7.weak-set.of */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.weak-set.of.js");
__webpack_require__(/*! ./modules/es7.map.from */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.map.from.js");
__webpack_require__(/*! ./modules/es7.set.from */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.set.from.js");
__webpack_require__(/*! ./modules/es7.weak-map.from */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.weak-map.from.js");
__webpack_require__(/*! ./modules/es7.weak-set.from */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.weak-set.from.js");
__webpack_require__(/*! ./modules/es7.global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.global.js");
__webpack_require__(/*! ./modules/es7.system.global */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.system.global.js");
__webpack_require__(/*! ./modules/es7.error.is-error */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.error.is-error.js");
__webpack_require__(/*! ./modules/es7.math.clamp */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.clamp.js");
__webpack_require__(/*! ./modules/es7.math.deg-per-rad */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.deg-per-rad.js");
__webpack_require__(/*! ./modules/es7.math.degrees */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.degrees.js");
__webpack_require__(/*! ./modules/es7.math.fscale */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.fscale.js");
__webpack_require__(/*! ./modules/es7.math.iaddh */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.iaddh.js");
__webpack_require__(/*! ./modules/es7.math.isubh */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.isubh.js");
__webpack_require__(/*! ./modules/es7.math.imulh */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.imulh.js");
__webpack_require__(/*! ./modules/es7.math.rad-per-deg */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.rad-per-deg.js");
__webpack_require__(/*! ./modules/es7.math.radians */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.radians.js");
__webpack_require__(/*! ./modules/es7.math.scale */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.scale.js");
__webpack_require__(/*! ./modules/es7.math.umulh */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.umulh.js");
__webpack_require__(/*! ./modules/es7.math.signbit */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.math.signbit.js");
__webpack_require__(/*! ./modules/es7.promise.finally */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.promise.finally.js");
__webpack_require__(/*! ./modules/es7.promise.try */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.promise.try.js");
__webpack_require__(/*! ./modules/es7.reflect.define-metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.define-metadata.js");
__webpack_require__(/*! ./modules/es7.reflect.delete-metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.delete-metadata.js");
__webpack_require__(/*! ./modules/es7.reflect.get-metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.get-metadata.js");
__webpack_require__(/*! ./modules/es7.reflect.get-metadata-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.get-metadata-keys.js");
__webpack_require__(/*! ./modules/es7.reflect.get-own-metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.get-own-metadata.js");
__webpack_require__(/*! ./modules/es7.reflect.get-own-metadata-keys */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js");
__webpack_require__(/*! ./modules/es7.reflect.has-metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.has-metadata.js");
__webpack_require__(/*! ./modules/es7.reflect.has-own-metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.has-own-metadata.js");
__webpack_require__(/*! ./modules/es7.reflect.metadata */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.reflect.metadata.js");
__webpack_require__(/*! ./modules/es7.asap */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.asap.js");
__webpack_require__(/*! ./modules/es7.observable */ "./node_modules/babel-polyfill/node_modules/core-js/modules/es7.observable.js");
__webpack_require__(/*! ./modules/web.timers */ "./node_modules/babel-polyfill/node_modules/core-js/modules/web.timers.js");
__webpack_require__(/*! ./modules/web.immediate */ "./node_modules/babel-polyfill/node_modules/core-js/modules/web.immediate.js");
__webpack_require__(/*! ./modules/web.dom.iterable */ "./node_modules/babel-polyfill/node_modules/core-js/modules/web.dom.iterable.js");
module.exports = __webpack_require__(/*! ./modules/_core */ "./node_modules/babel-polyfill/node_modules/core-js/modules/_core.js");


/***/ }),

/***/ "./node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-polyfill/node_modules/regenerator-runtime/runtime.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/css-loader/index.js?-url!./node_modules/less-loader/dist/cjs.js!./web/css/app.less":
/*!************************************************************************************************!*\
  !*** ./node_modules/css-loader?-url!./node_modules/less-loader/dist/cjs.js!./web/css/app.less ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(undefined);
// imports


// module
exports.push([module.i, "body {\n  font-family: sans-serif;\n  font-size: 11px;\n  overflow: hidden;\n}\nhtml,\nbody {\n  background: gray;\n  height: 100%;\n  padding: 0;\n  margin: 0;\n}\n.helvetica {\n  font-family: 'Helvetica Neue Light', HelveticaNeue-Light, 'Helvetica Neue', Helvetica, sans-serif;\n}\n.mono {\n  font-family: Monaco, monospace;\n}\n.sans-serif {\n  font-family: sans-serif;\n}\n.logo {\n  color: #bbb;\n  font-size: 16px;\n  padding: 8px 0 0 10px;\n  cursor: alias;\n}\n.logo sup {\n  font-size: 9px;\n  font-style: italic;\n}\n.panel {\n  background: #444;\n  border: 0px solid black;\n}\n.b-top {\n  border-top-width: 1px;\n}\n.b-bot {\n  border-bottom-width: 1px;\n}\n.b-left {\n  border-left-width: 1px;\n}\n.b-right {\n  border-right-width: 5px;\n  border-color: #222222;\n}\n.btn:hover {\n  background-color: #808080;\n  border-color: #ccc;\n}\n.btn {\n  border: 1px solid #808080;\n  background: #606060 no-repeat center;\n  border-radius: 4px;\n  color: white;\n  vertical-align: top;\n}\n#dock {\n  color: #fff;\n}\n.dock-btn {\n  padding: 1px 5px 1px 5px;\n  border: 0 solid black;\n  background: #606060 no-repeat center;\n  border-radius: 4px;\n  cursor: pointer;\n  margin: 1px 4px 1px 4px;\n}\n.dock-btn:hover {\n  background-color: #808080;\n}\n.dock-btn .txt {\n  padding-left: 5px;\n}\n.selected {\n  background-color: #333;\n  color: #ccc;\n}\n.sbtn {\n  min-width: 20px;\n  height: 20px;\n  line-height: 1.1;\n  border-color: #999;\n  padding: 1px 3px;\n  font-size: 14px;\n}\n.rbtn {\n  width: 37px;\n  height: 37px;\n  margin: 2px 6px;\n  font-size: 22px;\n  line-height: 1.1;\n}\n.tbtn {\n  width: 31px;\n  height: 31px;\n  margin: 2px 2px;\n  font-size: 20px;\n  padding: 0;\n}\n.tlist {\n  list-style-type: none;\n  padding: 0px;\n  margin: 0;\n  color: #fff;\n  font-size: 13px;\n}\n.tlist li {\n  border-bottom: 1px solid #777;\n  padding: 2px 3px 2px  15px;\n  cursor: pointer;\n}\n.tlist li:hover {\n  background: #222;\n}\n.tool-caption {\n  font-weight: bold;\n  color: #fff;\n  padding: 2px 0 2px 3px;\n  background: #333;\n}\n.no-top-border {\n  border-top: 0;\n}\n.tool-caption .btn {\n  width: 14px;\n  height: 14px;\n  font-size: 10px;\n  line-height: 11px;\n  margin-top: -1px;\n}\n.tool-caption .fa {\n  font-size: 11px;\n}\n.tool-caption .txt {\n  padding-right: 3px;\n}\n.tlist .btn {\n  font-size: 11px;\n  border: 0;\n}\n.tlist .rm {\n  visibility: hidden;\n  padding: 0 5px 0 5px;\n}\n.tlist li:hover .rm {\n  visibility: visible;\n}\n.scroll {\n  overflow-y: auto;\n  overflow-x: hidden;\n}\n.scroll::-webkit-scrollbar {\n  width: 4px;\n}\n.scroll::-webkit-scrollbar-track {\n  background: white;\n}\n.scroll::-webkit-scrollbar-thumb {\n  background: steelblue;\n}\n.scroll::-webkit-scrollbar-thumb:hover {\n  background: royalblue;\n}\n.win {\n  position: absolute;\n  min-width: 100px;\n  min-height: 20px;\n  left: 100px;\n  top: 300px;\n  background: #666;\n  border: 5px solid #444444;\n  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);\n}\n.win .content {\n  font-family: sans-serif;\n  color: #fff;\n  padding: 7px;\n  height: calc(100% - 19px);\n}\n.win .tool-caption {\n  cursor: default;\n  height: 15px;\n}\n.win .tool-caption .rm {\n  border: 0;\n  border-radius: 0px;\n  color: white;\n  font-size: 16px;\n  height: 17px;\n  padding-left: 5px;\n}\n.sep {\n  margin-right: 13px;\n}\n.pseudo-btn:hover {\n  background-color: #808080;\n}\n.pseudo-btn {\n  background-color: #606060;\n  color: white;\n  width: 18px;\n  text-align: center;\n  cursor: pointer;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.pseudo-btn a {\n  color: white;\n  text-decoration: none;\n}\n#layerSelection label {\n  color: #fff;\n}\n#layersList {\n  background-color: #ddd;\n  margin: 10px;\n}\n.tc-ctrl {\n  border-left: 0;\n}\n.tc-ctrl input[type=text],\n.tc-ctrl select {\n  color: #fff;\n}\n#commands {\n  font-family: Monaco, monospace;\n}\n#commands .content {\n  color: #C4E1A4;\n  font-size: 11px;\n}\n.terminal-output-area {\n  height: calc(100% - 30px);\n  display: flex;\n  flex-direction: column;\n}\n.terminal-output {\n  flex: 1;\n}\n.terminal-pusher {\n  height: 100%;\n}\n.terminal-input {\n  height: 30px;\n}\n.terminal-input input {\n  color: #C4E1A4;\n  background: inherit;\n  outline: none;\n  border: 0;\n  margin-top: 4px;\n  padding: 3px;\n  width: 100%;\n  box-sizing: border-box;\n  padding-left: 0;\n}\n.terminal-input input::-webkit-input-placeholder {\n  color: #777777;\n  font-style: italic;\n}\n.terminal-commandText {\n  color: #777777;\n}\n.autocomplete-area {\n  font-style: italic;\n}\ninput[type=checkbox],\ninput[type=radio] {\n  vertical-align: middle;\n}\n#status {\n  font-family: 'Helvetica Neue Light', HelveticaNeue-Light, 'Helvetica Neue', Helvetica, sans-serif;\n  color: #fff;\n  font-size: 11px;\n  padding-top: 4px;\n}\n#status .coordinates-info {\n  font-style: italic;\n  color: #fff;\n}\n.status-item {\n  padding-right: 5px;\n  padding-left: 5px;\n  float: right;\n  color: #bbb;\n}\n#viewer-container .tool-hint {\n  font-family: 'Helvetica Neue Light', HelveticaNeue-Light, 'Helvetica Neue', Helvetica, sans-serif;\n  color: #000;\n  font-size: 11px;\n  cursor: default;\n  pointer-events: none;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/diff-match-patch/index.js":
/*!************************************************!*\
  !*** ./node_modules/diff-match-patch/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close do
  // the contents have to be to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  // The number of bits in an int.
  this.Match_MaxBits = 32;
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/** @typedef {{0: number, 1: string}} */
diff_match_patch.Diff;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff.
 * @param {number} opt_deadline Optional time when the diff should be complete
 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
 *     instead.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
    opt_deadline) {
  // Set a deadline by which time the diff must be complete.
  if (typeof opt_deadline == 'undefined') {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
    }
  }
  var deadline = opt_deadline;

  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute_(text1, text2, checklines, deadline);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
    deadline) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }

  return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  // Scan the text on a line-by-line basis first.
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;

  var diffs = this.diff_main(text1, text2, false, deadline);

  // Convert the diff back to original text.
  this.diff_charsToLines_(diffs, linearray);
  // Eliminate freak matches (e.g. blank lines)
  this.diff_cleanupSemantic(diffs);

  // Rediff any replacement blocks, this time character-by-character.
  // Add a dummy entry at the end.
  diffs.push([DIFF_EQUAL, '']);
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete >= 1 && count_insert >= 1) {
          // Delete the offending records and add the merged ones.
          diffs.splice(pointer - count_delete - count_insert,
                       count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          var a = this.diff_main(text_delete, text_insert, false, deadline);
          for (var j = a.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, a[j]);
          }
          pointer = pointer + a.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
    pointer++;
  }
  diffs.pop();  // Remove the dummy entry at the end.

  return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Bail out if deadline is reached.
    if ((new Date()).getTime() > deadline) {
      break;
    }

    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
    deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);

  return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge_(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge_(text1);
  var chars2 = diff_linesToCharsMunge_(text2);
  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  // Eliminate the null case.
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  // Truncate the longer string.
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  // Quick check for the worst case.
  if (text1 == text2) {
    return text_length;
  }

  // Start by looking for a single character match
  // and increase length until no match is found.
  // Performance analysis: http://neil.fraser.name/news/2010/11/04/
  var best = 0;
  var length = 1;
  while (true) {
    var pattern = text1.substring(text_length - length);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length += found;
    if (found == 0 || text1.substring(text_length - length) ==
        text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    // Don't risk returning a non-optimal diff if we have unlimited time.
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      // Eliminate an equality that is smaller or equal to the edits on both
      // sides of it.
      if (lastequality && (lastequality.length <=
          Math.max(length_insertions1, length_deletions1)) &&
          (lastequality.length <= Math.max(length_insertions2,
                                           length_deletions2))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;  // Reset the counters.
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }

  // Normalize the diff.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);

  // Find any overlaps between deletions and insertions.
  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
  //   -> <del>abc</del>xxx<ins>def</ins>
  // e.g: <del>xxxabc</del><ins>defxxx</ins>
  //   -> <ins>def</ins>xxx<del>abc</del>
  // Only extract an overlap if it is as big as the edit ahead or behind it.
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE &&
        diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 ||
            overlap_length1 >= insertion.length / 2) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
          diffs[pointer - 1][1] =
              deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 ||
            overlap_length2 >= insertion.length / 2) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] =
              insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] =
              deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 6 (best) to 0 (worst).
   * Closure, but does not reference any external variables.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   * @private
   */
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 6;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
    var whitespace1 = nonAlphaNumeric1 &&
        char1.match(diff_match_patch.whitespaceRegex_);
    var whitespace2 = nonAlphaNumeric2 &&
        char2.match(diff_match_patch.whitespaceRegex_);
    var lineBreak1 = whitespace1 &&
        char1.match(diff_match_patch.linebreakRegex_);
    var lineBreak2 = whitespace2 &&
        char2.match(diff_match_patch.linebreakRegex_);
    var blankLine1 = lineBreak1 &&
        one.match(diff_match_patch.blanklineEndRegex_);
    var blankLine2 = lineBreak2 &&
        two.match(diff_match_patch.blanklineStartRegex_);

    if (blankLine1 || blankLine2) {
      // Five points for blank lines.
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      // Four points for line breaks.
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      // Three points for end of sentences.
      return 3;
    } else if (whitespace1 || whitespace2) {
      // Two points for whitespace.
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      // One point for non-alphanumeric.
      return 1;
    }
    return 0;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
          diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) +
            diff_cleanupSemanticScore_(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};

// Define some regex patterns for matching boundaries.
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = null;
      }
      post_ins = post_del = false;
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastequality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = null;
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality.
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
        break;
      case DIFF_DELETE:
        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
        break;
      case DIFF_EQUAL:
        html[x] = '<span>' + text + '</span>';
        break;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap_(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet_(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore_(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore_(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = /** @type {string} */(a);
    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new diff_match_patch.patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new diff_match_patch.patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = patch.diffs[y].slice();
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[x];
    // Remove the big old patch.
    patches.splice(x--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = '';
    while (bigpatch.diffs.length !== 0) {
      // Create one of several smaller patches.
      var patch = new diff_match_patch.patch_obj();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== '') {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push([DIFF_EQUAL, precontext]);
      }
      while (bigpatch.diffs.length !== 0 &&
             patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          // Insertions are harmless.
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                   patch.diffs[0][0] == DIFF_EQUAL &&
                   diff_text.length > 2 * patch_size) {
          // This is a large deletion.  Let it pass in one chunk.
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push([diff_type, diff_text]);
          bigpatch.diffs.shift();
        } else {
          // Deletion or equality.  Only take as much as we can stomach.
          diff_text = diff_text.substring(0,
              patch_size - patch.length1 - this.Patch_Margin);
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push([diff_type, diff_text]);
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      // Compute the head context for the next patch.
      precontext = this.diff_text2(patch.diffs);
      precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
      // Append the end context for this patch.
      var postcontext = this.diff_text1(bigpatch.diffs)
                            .substring(0, this.Patch_Margin);
      if (postcontext !== '') {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push([DIFF_EQUAL, postcontext]);
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text = textline.split('\n');
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text.length) {
    var m = text[textPointer].match(patchHeader);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new diff_match_patch.patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.patch_obj = function() {
  /** @type {!Array.<!diff_match_patch.Diff>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
};


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  return text.join('').replace(/%20/g, ' ');
};


// The following export code was added by @ForbesLindesay
module.exports = diff_match_patch;
module.exports['diff_match_patch'] = diff_match_patch;
module.exports['DIFF_DELETE'] = DIFF_DELETE;
module.exports['DIFF_INSERT'] = DIFF_INSERT;
module.exports['DIFF_EQUAL'] = DIFF_EQUAL;


/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.4.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code, options ) {
		DOMEval( code, { nonce: options && options.nonce } );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

				// Support: IE 8 only
				// Exclude object elements
				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 && rdescend.test( selector ) ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( typeof elem.contentDocument !== "undefined" ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								} );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	// Support: IE 9-11 only
	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
	// We use getClientRects() to check for hidden/disconnected.
	// In those cases, the computed value can be trusted to be border-box
	if ( ( !support.boxSizingReliable() && isBorderBox ||
		val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url, options ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/mousetrap/mousetrap.js":
/*!*********************************************!*\
  !*** ./node_modules/mousetrap/mousetrap.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */
/**
 * Copyright 2012-2017 Craig Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Mousetrap is a simple keyboard shortcut library for Javascript with
 * no external dependencies
 *
 * @version 1.6.1
 * @url craig.is/killing/mice
 */
(function(window, document, undefined) {

    // Check if mousetrap is used inside browser, if not, return
    if (!window) {
        return;
    }

    /**
     * mapping of special keycodes to their corresponding keys
     *
     * everything in this dictionary cannot use keypress events
     * so it has to be here to map to the correct keycodes for
     * keyup/keydown events
     *
     * @type {Object}
     */
    var _MAP = {
        8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'ctrl',
        18: 'alt',
        20: 'capslock',
        27: 'esc',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        45: 'ins',
        46: 'del',
        91: 'meta',
        93: 'meta',
        224: 'meta'
    };

    /**
     * mapping for special characters so they can support
     *
     * this dictionary is only used incase you want to bind a
     * keyup or keydown event to one of these keys
     *
     * @type {Object}
     */
    var _KEYCODE_MAP = {
        106: '*',
        107: '+',
        109: '-',
        110: '.',
        111 : '/',
        186: ';',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: ']',
        222: '\''
    };

    /**
     * this is a mapping of keys that require shift on a US keypad
     * back to the non shift equivelents
     *
     * this is so you can use keyup events with these keys
     *
     * note that this will only work reliably on US keyboards
     *
     * @type {Object}
     */
    var _SHIFT_MAP = {
        '~': '`',
        '!': '1',
        '@': '2',
        '#': '3',
        '$': '4',
        '%': '5',
        '^': '6',
        '&': '7',
        '*': '8',
        '(': '9',
        ')': '0',
        '_': '-',
        '+': '=',
        ':': ';',
        '\"': '\'',
        '<': ',',
        '>': '.',
        '?': '/',
        '|': '\\'
    };

    /**
     * this is a list of special strings you can use to map
     * to modifier keys when you specify your keyboard shortcuts
     *
     * @type {Object}
     */
    var _SPECIAL_ALIASES = {
        'option': 'alt',
        'command': 'meta',
        'return': 'enter',
        'escape': 'esc',
        'plus': '+',
        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
    };

    /**
     * variable to store the flipped version of _MAP from above
     * needed to check if we should use keypress or not when no action
     * is specified
     *
     * @type {Object|undefined}
     */
    var _REVERSE_MAP;

    /**
     * loop through the f keys, f1 to f19 and add them to the map
     * programatically
     */
    for (var i = 1; i < 20; ++i) {
        _MAP[111 + i] = 'f' + i;
    }

    /**
     * loop through to map numbers on the numeric keypad
     */
    for (i = 0; i <= 9; ++i) {

        // This needs to use a string cause otherwise since 0 is falsey
        // mousetrap will never fire for numpad 0 pressed as part of a keydown
        // event.
        //
        // @see https://github.com/ccampbell/mousetrap/pull/258
        _MAP[i + 96] = i.toString();
    }

    /**
     * cross browser add event method
     *
     * @param {Element|HTMLDocument} object
     * @param {string} type
     * @param {Function} callback
     * @returns void
     */
    function _addEvent(object, type, callback) {
        if (object.addEventListener) {
            object.addEventListener(type, callback, false);
            return;
        }

        object.attachEvent('on' + type, callback);
    }

    /**
     * takes the event and returns the key character
     *
     * @param {Event} e
     * @return {string}
     */
    function _characterFromEvent(e) {

        // for keypress events we should return the character as is
        if (e.type == 'keypress') {
            var character = String.fromCharCode(e.which);

            // if the shift key is not pressed then it is safe to assume
            // that we want the character to be lowercase.  this means if
            // you accidentally have caps lock on then your key bindings
            // will continue to work
            //
            // the only side effect that might not be desired is if you
            // bind something like 'A' cause you want to trigger an
            // event when capital A is pressed caps lock will no longer
            // trigger the event.  shift+a will though.
            if (!e.shiftKey) {
                character = character.toLowerCase();
            }

            return character;
        }

        // for non keypress events the special maps are needed
        if (_MAP[e.which]) {
            return _MAP[e.which];
        }

        if (_KEYCODE_MAP[e.which]) {
            return _KEYCODE_MAP[e.which];
        }

        // if it is not in the special map

        // with keydown and keyup events the character seems to always
        // come in as an uppercase character whether you are pressing shift
        // or not.  we should make sure it is always lowercase for comparisons
        return String.fromCharCode(e.which).toLowerCase();
    }

    /**
     * checks if two arrays are equal
     *
     * @param {Array} modifiers1
     * @param {Array} modifiers2
     * @returns {boolean}
     */
    function _modifiersMatch(modifiers1, modifiers2) {
        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
    }

    /**
     * takes a key event and figures out what the modifiers are
     *
     * @param {Event} e
     * @returns {Array}
     */
    function _eventModifiers(e) {
        var modifiers = [];

        if (e.shiftKey) {
            modifiers.push('shift');
        }

        if (e.altKey) {
            modifiers.push('alt');
        }

        if (e.ctrlKey) {
            modifiers.push('ctrl');
        }

        if (e.metaKey) {
            modifiers.push('meta');
        }

        return modifiers;
    }

    /**
     * prevents default for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _preventDefault(e) {
        if (e.preventDefault) {
            e.preventDefault();
            return;
        }

        e.returnValue = false;
    }

    /**
     * stops propogation for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _stopPropagation(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
            return;
        }

        e.cancelBubble = true;
    }

    /**
     * determines if the keycode specified is a modifier key or not
     *
     * @param {string} key
     * @returns {boolean}
     */
    function _isModifier(key) {
        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
    }

    /**
     * reverses the map lookup so that we can look for specific keys
     * to see what can and can't use keypress
     *
     * @return {Object}
     */
    function _getReverseMap() {
        if (!_REVERSE_MAP) {
            _REVERSE_MAP = {};
            for (var key in _MAP) {

                // pull out the numeric keypad from here cause keypress should
                // be able to detect the keys from the character
                if (key > 95 && key < 112) {
                    continue;
                }

                if (_MAP.hasOwnProperty(key)) {
                    _REVERSE_MAP[_MAP[key]] = key;
                }
            }
        }
        return _REVERSE_MAP;
    }

    /**
     * picks the best action based on the key combination
     *
     * @param {string} key - character for key
     * @param {Array} modifiers
     * @param {string=} action passed in
     */
    function _pickBestAction(key, modifiers, action) {

        // if no action was picked in we should try to pick the one
        // that we think would work best for this key
        if (!action) {
            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
        }

        // modifier keys don't work as expected with keypress,
        // switch to keydown
        if (action == 'keypress' && modifiers.length) {
            action = 'keydown';
        }

        return action;
    }

    /**
     * Converts from a string key combination to an array
     *
     * @param  {string} combination like "command+shift+l"
     * @return {Array}
     */
    function _keysFromString(combination) {
        if (combination === '+') {
            return ['+'];
        }

        combination = combination.replace(/\+{2}/g, '+plus');
        return combination.split('+');
    }

    /**
     * Gets info for a specific key combination
     *
     * @param  {string} combination key combination ("command+s" or "a" or "*")
     * @param  {string=} action
     * @returns {Object}
     */
    function _getKeyInfo(combination, action) {
        var keys;
        var key;
        var i;
        var modifiers = [];

        // take the keys from this pattern and figure out what the actual
        // pattern is all about
        keys = _keysFromString(combination);

        for (i = 0; i < keys.length; ++i) {
            key = keys[i];

            // normalize key names
            if (_SPECIAL_ALIASES[key]) {
                key = _SPECIAL_ALIASES[key];
            }

            // if this is not a keypress event then we should
            // be smart about using shift keys
            // this will only work for US keyboards however
            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
                key = _SHIFT_MAP[key];
                modifiers.push('shift');
            }

            // if this key is a modifier then add it to the list of modifiers
            if (_isModifier(key)) {
                modifiers.push(key);
            }
        }

        // depending on what the key combination is
        // we will try to pick the best event for it
        action = _pickBestAction(key, modifiers, action);

        return {
            key: key,
            modifiers: modifiers,
            action: action
        };
    }

    function _belongsTo(element, ancestor) {
        if (element === null || element === document) {
            return false;
        }

        if (element === ancestor) {
            return true;
        }

        return _belongsTo(element.parentNode, ancestor);
    }

    function Mousetrap(targetElement) {
        var self = this;

        targetElement = targetElement || document;

        if (!(self instanceof Mousetrap)) {
            return new Mousetrap(targetElement);
        }

        /**
         * element to attach key events to
         *
         * @type {Element}
         */
        self.target = targetElement;

        /**
         * a list of all the callbacks setup via Mousetrap.bind()
         *
         * @type {Object}
         */
        self._callbacks = {};

        /**
         * direct map of string combinations to callbacks used for trigger()
         *
         * @type {Object}
         */
        self._directMap = {};

        /**
         * keeps track of what level each sequence is at since multiple
         * sequences can start out with the same sequence
         *
         * @type {Object}
         */
        var _sequenceLevels = {};

        /**
         * variable to store the setTimeout call
         *
         * @type {null|number}
         */
        var _resetTimer;

        /**
         * temporary state where we will ignore the next keyup
         *
         * @type {boolean|string}
         */
        var _ignoreNextKeyup = false;

        /**
         * temporary state where we will ignore the next keypress
         *
         * @type {boolean}
         */
        var _ignoreNextKeypress = false;

        /**
         * are we currently inside of a sequence?
         * type of action ("keyup" or "keydown" or "keypress") or false
         *
         * @type {boolean|string}
         */
        var _nextExpectedAction = false;

        /**
         * resets all sequence counters except for the ones passed in
         *
         * @param {Object} doNotReset
         * @returns void
         */
        function _resetSequences(doNotReset) {
            doNotReset = doNotReset || {};

            var activeSequences = false,
                key;

            for (key in _sequenceLevels) {
                if (doNotReset[key]) {
                    activeSequences = true;
                    continue;
                }
                _sequenceLevels[key] = 0;
            }

            if (!activeSequences) {
                _nextExpectedAction = false;
            }
        }

        /**
         * finds all callbacks that match based on the keycode, modifiers,
         * and action
         *
         * @param {string} character
         * @param {Array} modifiers
         * @param {Event|Object} e
         * @param {string=} sequenceName - name of the sequence we are looking for
         * @param {string=} combination
         * @param {number=} level
         * @returns {Array}
         */
        function _getMatches(character, modifiers, e, sequenceName, combination, level) {
            var i;
            var callback;
            var matches = [];
            var action = e.type;

            // if there are no events related to this keycode
            if (!self._callbacks[character]) {
                return [];
            }

            // if a modifier key is coming up on its own we should allow it
            if (action == 'keyup' && _isModifier(character)) {
                modifiers = [character];
            }

            // loop through all callbacks for the key that was pressed
            // and see if any of them match
            for (i = 0; i < self._callbacks[character].length; ++i) {
                callback = self._callbacks[character][i];

                // if a sequence name is not specified, but this is a sequence at
                // the wrong level then move onto the next match
                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
                    continue;
                }

                // if the action we are looking for doesn't match the action we got
                // then we should keep going
                if (action != callback.action) {
                    continue;
                }

                // if this is a keypress event and the meta key and control key
                // are not pressed that means that we need to only look at the
                // character, otherwise check the modifiers as well
                //
                // chrome will not fire a keypress if meta or control is down
                // safari will fire a keypress if meta or meta+shift is down
                // firefox will fire a keypress if meta or control is down
                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {

                    // when you bind a combination or sequence a second time it
                    // should overwrite the first one.  if a sequenceName or
                    // combination is specified in this call it does just that
                    //
                    // @todo make deleting its own method?
                    var deleteCombo = !sequenceName && callback.combo == combination;
                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
                    if (deleteCombo || deleteSequence) {
                        self._callbacks[character].splice(i, 1);
                    }

                    matches.push(callback);
                }
            }

            return matches;
        }

        /**
         * actually calls the callback function
         *
         * if your callback function returns false this will use the jquery
         * convention - prevent default and stop propogation on the event
         *
         * @param {Function} callback
         * @param {Event} e
         * @returns void
         */
        function _fireCallback(callback, e, combo, sequence) {

            // if this event should not happen stop here
            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
                return;
            }

            if (callback(e, combo) === false) {
                _preventDefault(e);
                _stopPropagation(e);
            }
        }

        /**
         * handles a character key event
         *
         * @param {string} character
         * @param {Array} modifiers
         * @param {Event} e
         * @returns void
         */
        self._handleKey = function(character, modifiers, e) {
            var callbacks = _getMatches(character, modifiers, e);
            var i;
            var doNotReset = {};
            var maxLevel = 0;
            var processedSequenceCallback = false;

            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence
            for (i = 0; i < callbacks.length; ++i) {
                if (callbacks[i].seq) {
                    maxLevel = Math.max(maxLevel, callbacks[i].level);
                }
            }

            // loop through matching callbacks for this key event
            for (i = 0; i < callbacks.length; ++i) {

                // fire for all sequence callbacks
                // this is because if for example you have multiple sequences
                // bound such as "g i" and "g t" they both need to fire the
                // callback for matching g cause otherwise you can only ever
                // match the first one
                if (callbacks[i].seq) {

                    // only fire callbacks for the maxLevel to prevent
                    // subsequences from also firing
                    //
                    // for example 'a option b' should not cause 'option b' to fire
                    // even though 'option b' is part of the other sequence
                    //
                    // any sequences that do not match here will be discarded
                    // below by the _resetSequences call
                    if (callbacks[i].level != maxLevel) {
                        continue;
                    }

                    processedSequenceCallback = true;

                    // keep a list of which sequences were matches for later
                    doNotReset[callbacks[i].seq] = 1;
                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);
                    continue;
                }

                // if there were no sequence matches but we are still here
                // that means this is a regular match so we should fire that
                if (!processedSequenceCallback) {
                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
                }
            }

            // if the key you pressed matches the type of sequence without
            // being a modifier (ie "keyup" or "keypress") then we should
            // reset all sequences that were not matched by this event
            //
            // this is so, for example, if you have the sequence "h a t" and you
            // type "h e a r t" it does not match.  in this case the "e" will
            // cause the sequence to reset
            //
            // modifier keys are ignored because you can have a sequence
            // that contains modifiers such as "enter ctrl+space" and in most
            // cases the modifier key will be pressed before the next key
            //
            // also if you have a sequence such as "ctrl+b a" then pressing the
            // "b" key will trigger a "keypress" and a "keydown"
            //
            // the "keydown" is expected when there is a modifier, but the
            // "keypress" ends up matching the _nextExpectedAction since it occurs
            // after and that causes the sequence to reset
            //
            // we ignore keypresses in a sequence that directly follow a keydown
            // for the same character
            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;
            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
                _resetSequences(doNotReset);
            }

            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
        };

        /**
         * handles a keydown event
         *
         * @param {Event} e
         * @returns void
         */
        function _handleKeyEvent(e) {

            // normalize e.which for key events
            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
            if (typeof e.which !== 'number') {
                e.which = e.keyCode;
            }

            var character = _characterFromEvent(e);

            // no character found then stop
            if (!character) {
                return;
            }

            // need to use === for the character check because the character can be 0
            if (e.type == 'keyup' && _ignoreNextKeyup === character) {
                _ignoreNextKeyup = false;
                return;
            }

            self.handleKey(character, _eventModifiers(e), e);
        }

        /**
         * called to set a 1 second timeout on the specified sequence
         *
         * this is so after each key press in the sequence you have 1 second
         * to press the next key before you have to start over
         *
         * @returns void
         */
        function _resetSequenceTimer() {
            clearTimeout(_resetTimer);
            _resetTimer = setTimeout(_resetSequences, 1000);
        }

        /**
         * binds a key sequence to an event
         *
         * @param {string} combo - combo specified in bind call
         * @param {Array} keys
         * @param {Function} callback
         * @param {string=} action
         * @returns void
         */
        function _bindSequence(combo, keys, callback, action) {

            // start off by adding a sequence level record for this combination
            // and setting the level to 0
            _sequenceLevels[combo] = 0;

            /**
             * callback to increase the sequence level for this sequence and reset
             * all other sequences that were active
             *
             * @param {string} nextAction
             * @returns {Function}
             */
            function _increaseSequence(nextAction) {
                return function() {
                    _nextExpectedAction = nextAction;
                    ++_sequenceLevels[combo];
                    _resetSequenceTimer();
                };
            }

            /**
             * wraps the specified callback inside of another function in order
             * to reset all sequence counters as soon as this sequence is done
             *
             * @param {Event} e
             * @returns void
             */
            function _callbackAndReset(e) {
                _fireCallback(callback, e, combo);

                // we should ignore the next key up if the action is key down
                // or keypress.  this is so if you finish a sequence and
                // release the key the final key will not trigger a keyup
                if (action !== 'keyup') {
                    _ignoreNextKeyup = _characterFromEvent(e);
                }

                // weird race condition if a sequence ends with the key
                // another sequence begins with
                setTimeout(_resetSequences, 10);
            }

            // loop through keys one at a time and bind the appropriate callback
            // function.  for any key leading up to the final one it should
            // increase the sequence. after the final, it should reset all sequences
            //
            // if an action is specified in the original bind call then that will
            // be used throughout.  otherwise we will pass the action that the
            // next key in the sequence should match.  this allows a sequence
            // to mix and match keypress and keydown events depending on which
            // ones are better suited to the key provided
            for (var i = 0; i < keys.length; ++i) {
                var isFinal = i + 1 === keys.length;
                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
                _bindSingle(keys[i], wrappedCallback, action, combo, i);
            }
        }

        /**
         * binds a single keyboard combination
         *
         * @param {string} combination
         * @param {Function} callback
         * @param {string=} action
         * @param {string=} sequenceName - name of sequence if part of sequence
         * @param {number=} level - what part of the sequence the command is
         * @returns void
         */
        function _bindSingle(combination, callback, action, sequenceName, level) {

            // store a direct mapped reference for use with Mousetrap.trigger
            self._directMap[combination + ':' + action] = callback;

            // make sure multiple spaces in a row become a single space
            combination = combination.replace(/\s+/g, ' ');

            var sequence = combination.split(' ');
            var info;

            // if this pattern is a sequence of keys then run through this method
            // to reprocess each pattern one key at a time
            if (sequence.length > 1) {
                _bindSequence(combination, sequence, callback, action);
                return;
            }

            info = _getKeyInfo(combination, action);

            // make sure to initialize array if this is the first time
            // a callback is added for this key
            self._callbacks[info.key] = self._callbacks[info.key] || [];

            // remove an existing match if there is one
            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);

            // add this call back to the array
            // if it is a sequence put it at the beginning
            // if not put it at the end
            //
            // this is important because the way these are processed expects
            // the sequence ones to come first
            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
                callback: callback,
                modifiers: info.modifiers,
                action: info.action,
                seq: sequenceName,
                level: level,
                combo: combination
            });
        }

        /**
         * binds multiple combinations to the same callback
         *
         * @param {Array} combinations
         * @param {Function} callback
         * @param {string|undefined} action
         * @returns void
         */
        self._bindMultiple = function(combinations, callback, action) {
            for (var i = 0; i < combinations.length; ++i) {
                _bindSingle(combinations[i], callback, action);
            }
        };

        // start!
        _addEvent(targetElement, 'keypress', _handleKeyEvent);
        _addEvent(targetElement, 'keydown', _handleKeyEvent);
        _addEvent(targetElement, 'keyup', _handleKeyEvent);
    }

    /**
     * binds an event to mousetrap
     *
     * can be a single key, a combination of keys separated with +,
     * an array of keys, or a sequence of keys separated by spaces
     *
     * be sure to list the modifier keys first to make sure that the
     * correct key ends up getting bound (the last key in the pattern)
     *
     * @param {string|Array} keys
     * @param {Function} callback
     * @param {string=} action - 'keypress', 'keydown', or 'keyup'
     * @returns void
     */
    Mousetrap.prototype.bind = function(keys, callback, action) {
        var self = this;
        keys = keys instanceof Array ? keys : [keys];
        self._bindMultiple.call(self, keys, callback, action);
        return self;
    };

    /**
     * unbinds an event to mousetrap
     *
     * the unbinding sets the callback function of the specified key combo
     * to an empty function and deletes the corresponding key in the
     * _directMap dict.
     *
     * TODO: actually remove this from the _callbacks dictionary instead
     * of binding an empty function
     *
     * the keycombo+action has to be exactly the same as
     * it was defined in the bind method
     *
     * @param {string|Array} keys
     * @param {string} action
     * @returns void
     */
    Mousetrap.prototype.unbind = function(keys, action) {
        var self = this;
        return self.bind.call(self, keys, function() {}, action);
    };

    /**
     * triggers an event that has already been bound
     *
     * @param {string} keys
     * @param {string=} action
     * @returns void
     */
    Mousetrap.prototype.trigger = function(keys, action) {
        var self = this;
        if (self._directMap[keys + ':' + action]) {
            self._directMap[keys + ':' + action]({}, keys);
        }
        return self;
    };

    /**
     * resets the library back to its initial state.  this is useful
     * if you want to clear out the current keyboard shortcuts and bind
     * new ones - for example if you switch to another page
     *
     * @returns void
     */
    Mousetrap.prototype.reset = function() {
        var self = this;
        self._callbacks = {};
        self._directMap = {};
        return self;
    };

    /**
     * should we stop this event before firing off callbacks
     *
     * @param {Event} e
     * @param {Element} element
     * @return {boolean}
     */
    Mousetrap.prototype.stopCallback = function(e, element) {
        var self = this;

        // if the element has the class "mousetrap" then no need to stop
        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
            return false;
        }

        if (_belongsTo(element, self.target)) {
            return false;
        }

        // stop for input, select, and textarea
        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
    };

    /**
     * exposes _handleKey publicly so it can be overwritten by extensions
     */
    Mousetrap.prototype.handleKey = function() {
        var self = this;
        return self._handleKey.apply(self, arguments);
    };

    /**
     * allow custom key mappings
     */
    Mousetrap.addKeycodes = function(object) {
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                _MAP[key] = object[key];
            }
        }
        _REVERSE_MAP = null;
    };

    /**
     * Init the global mousetrap functions
     *
     * This method is needed to allow the global mousetrap functions to work
     * now that mousetrap is a constructor function.
     */
    Mousetrap.init = function() {
        var documentMousetrap = Mousetrap(document);
        for (var method in documentMousetrap) {
            if (method.charAt(0) !== '_') {
                Mousetrap[method] = (function(method) {
                    return function() {
                        return documentMousetrap[method].apply(documentMousetrap, arguments);
                    };
                } (method));
            }
        }
    };

    Mousetrap.init();

    // expose mousetrap to the global object
    window.Mousetrap = Mousetrap;

    // expose as a common js module
    if ( true && module.exports) {
        module.exports = Mousetrap;
    }

    // expose mousetrap as an AMD module
    if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
            return Mousetrap;
        }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);


/***/ }),

/***/ "./node_modules/numeric/numeric-1.2.6.js":
/*!***********************************************!*\
  !*** ./node_modules/numeric/numeric-1.2.6.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var numeric = ( false)?(undefined):(exports);
if(typeof global !== "undefined") { global.numeric = numeric; }

numeric.version = "1.2.6";

// 1. Utility functions
numeric.bench = function bench (f,interval) {
    var t1,t2,n,i;
    if(typeof interval === "undefined") { interval = 15; }
    n = 0.5;
    t1 = new Date();
    while(1) {
        n*=2;
        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
        while(i>0) { f(); i--; }
        t2 = new Date();
        if(t2-t1 > interval) break;
    }
    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
    while(i>0) { f(); i--; }
    t2 = new Date();
    return 1000*(3*n-1)/(t2-t1);
}

numeric._myIndexOf = (function _myIndexOf(w) {
    var n = this.length,k;
    for(k=0;k<n;++k) if(this[k]===w) return k;
    return -1;
});
numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;

numeric.prettyPrint = function prettyPrint(x) {
    function fmtnum(x) {
        if(x === 0) { return '0'; }
        if(isNaN(x)) { return 'NaN'; }
        if(x<0) { return '-'+fmtnum(-x); }
        if(isFinite(x)) {
            var scale = Math.floor(Math.log(x) / Math.log(10));
            var normalized = x / Math.pow(10,scale);
            var basic = normalized.toPrecision(numeric.precision);
            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
            return parseFloat(basic).toString()+'e'+scale.toString();
        }
        return 'Infinity';
    }
    var ret = [];
    function foo(x) {
        var k;
        if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
        if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
        if(typeof x === "boolean") { ret.push(x.toString()); return false; }
        if(typeof x === "number") {
            var a = fmtnum(x);
            var b = x.toPrecision(numeric.precision);
            var c = parseFloat(x.toString()).toString();
            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
            return false;
        }
        if(x === null) { ret.push("null"); return false; }
        if(typeof x === "function") { 
            ret.push(x.toString());
            var flag = false;
            for(k in x) { if(x.hasOwnProperty(k)) { 
                if(flag) ret.push(',\n');
                else ret.push('\n{');
                flag = true; 
                ret.push(k); 
                ret.push(': \n'); 
                foo(x[k]); 
            } }
            if(flag) ret.push('}\n');
            return true;
        }
        if(x instanceof Array) {
            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
            var flag = false;
            ret.push('[');
            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
            ret.push(']');
            return true;
        }
        ret.push('{');
        var flag = false;
        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
        ret.push('}');
        return true;
    }
    foo(x);
    return ret.join('');
}

numeric.parseDate = function parseDate(d) {
    function foo(d) {
        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
        if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseFloat = function parseFloat_(d) {
    function foo(d) {
        if(typeof d === 'string') { return parseFloat(d); }
        if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
        var ret = [],k;
        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
        return ret;
    }
    return foo(d);
}

numeric.parseCSV = function parseCSV(t) {
    var foo = t.split('\n');
    var j,k;
    var ret = [];
    var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
    var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
    var stripper = function(n) { return n.substr(0,n.length-1); }
    var count = 0;
    for(k=0;k<foo.length;k++) {
      var bar = (foo[k]+",").match(pat),baz;
      if(bar.length>0) {
          ret[count] = [];
          for(j=0;j<bar.length;j++) {
              baz = stripper(bar[j]);
              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
              else ret[count][j] = baz;
          }
          count++;
      }
    }
    return ret;
}

numeric.toCSV = function toCSV(A) {
    var s = numeric.dim(A);
    var i,j,m,n,row,ret;
    m = s[0];
    n = s[1];
    ret = [];
    for(i=0;i<m;i++) {
        row = [];
        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
        ret[i] = row.join(', ');
    }
    return ret.join('\n')+'\n';
}

numeric.getURL = function getURL(url) {
    var client = new XMLHttpRequest();
    client.open("GET",url,false);
    client.send();
    return client;
}

numeric.imageURL = function imageURL(img) {
    function base64(A) {
        var n = A.length, i,x,y,z,p,q,r,s;
        var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var ret = "";
        for(i=0;i<n;i+=3) {
            x = A[i];
            y = A[i+1];
            z = A[i+2];
            p = x >> 2;
            q = ((x & 3) << 4) + (y >> 4);
            r = ((y & 15) << 2) + (z >> 6);
            s = z & 63;
            if(i+1>=n) { r = s = 64; }
            else if(i+2>=n) { s = 64; }
            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
        return ret;
    }
    function crc32Array (a,from,to) {
        if(typeof from === "undefined") { from = 0; }
        if(typeof to === "undefined") { to = a.length; }
        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 
                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 
                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 
                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 
                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 
                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 
                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 
                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 
                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 
                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 
                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 
                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 
                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 
                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 
                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 
                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 
                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 
                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 
                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 
                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 
                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 
                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 
                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 
                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 
                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 
                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 
                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];
     
        var crc = -1, y = 0, n = a.length,i;

        for (i = from; i < to; i++) {
            y = (crc ^ a[i]) & 0xFF;
            crc = (crc >>> 8) ^ table[y];
        }
     
        return crc ^ (-1);
    }

    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
    var stream = [
                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                  0,0,0,13,                                                  //  8: IHDR Chunk length
                  73, 72, 68, 82,                                            // 12: "IHDR" 
                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                  8,                                                         // 24: bit depth
                  2,                                                         // 25: RGB
                  0,                                                         // 26: deflate
                  0,                                                         // 27: no filter
                  0,                                                         // 28: no interlace
                  -1,-2,-3,-4,                                               // 29: CRC
                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                  73, 68, 65, 84,                                            // 37: "IDAT"
                  // RFC 1950 header starts here
                  8,                                                         // 41: RFC1950 CMF
                  29                                                         // 42: RFC1950 FLG
                  ];
    crc32 = crc32Array(stream,12,29);
    stream[29] = (crc32>>24)&255;
    stream[30] = (crc32>>16)&255;
    stream[31] = (crc32>>8)&255;
    stream[32] = (crc32)&255;
    s1 = 1;
    s2 = 0;
    for(i=0;i<h;i++) {
        if(i<h-1) { stream.push(0); }
        else { stream.push(1); }
        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
        stream.push(a); stream.push(b);
        stream.push((~a)&255); stream.push((~b)&255);
        if(i===0) stream.push(0);
        for(j=0;j<w;j++) {
            for(k=0;k<3;k++) {
                a = img[k][i][j];
                if(a>255) a = 255;
                else if(a<0) a=0;
                else a = Math.round(a);
                s1 = (s1 + a )%65521;
                s2 = (s2 + s1)%65521;
                stream.push(a);
            }
        }
        stream.push(0);
    }
    adler32 = (s2<<16)+s1;
    stream.push((adler32>>24)&255);
    stream.push((adler32>>16)&255);
    stream.push((adler32>>8)&255);
    stream.push((adler32)&255);
    length = stream.length - 41;
    stream[33] = (length>>24)&255;
    stream[34] = (length>>16)&255;
    stream[35] = (length>>8)&255;
    stream[36] = (length)&255;
    crc32 = crc32Array(stream,37);
    stream.push((crc32>>24)&255);
    stream.push((crc32>>16)&255);
    stream.push((crc32>>8)&255);
    stream.push((crc32)&255);
    stream.push(0);
    stream.push(0);
    stream.push(0);
    stream.push(0);
//    a = stream.length;
    stream.push(73);  // I
    stream.push(69);  // E
    stream.push(78);  // N
    stream.push(68);  // D
    stream.push(174); // CRC1
    stream.push(66);  // CRC2
    stream.push(96);  // CRC3
    stream.push(130); // CRC4
    return 'data:image/png;base64,'+base64(stream);
}

// 2. Linear algebra with Arrays.
numeric._dim = function _dim(x) {
    var ret = [];
    while(typeof x === "object") { ret.push(x.length); x = x[0]; }
    return ret;
}

numeric.dim = function dim(x) {
    var y,z;
    if(typeof x === "object") {
        y = x[0];
        if(typeof y === "object") {
            z = y[0];
            if(typeof z === "object") {
                return numeric._dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

numeric.mapreduce = function mapreduce(body,init) {
    return Function('x','accum','_s','_k',
            'if(typeof accum === "undefined") accum = '+init+';\n'+
            'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i,xi;\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) {\n'+
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
            '    }'+
            '    return accum;\n'+
            '}\n'+
            'for(i=_n-1;i>=1;i-=2) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '    xi = x[i-1];\n'+
            '    '+body+';\n'+
            '}\n'+
            'if(i === 0) {\n'+
            '    xi = x[i];\n'+
            '    '+body+'\n'+
            '}\n'+
            'return accum;'
            );
}
numeric.mapreduce2 = function mapreduce2(body,setup) {
    return Function('x',
            'var n = x.length;\n'+
            'var i,xi;\n'+setup+';\n'+
            'for(i=n-1;i!==-1;--i) { \n'+
            '    xi = x[i];\n'+
            '    '+body+';\n'+
            '}\n'+
            'return accum;'
            );
}


numeric.same = function same(x,y) {
    var i,n;
    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
    n = x.length;
    if(n !== y.length) { return false; }
    for(i=0;i<n;i++) {
        if(x[i] === y[i]) { continue; }
        if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
        else { return false; }
    }
    return true;
}

numeric.rep = function rep(s,v,k) {
    if(typeof k === "undefined") { k=0; }
    var n = s[k], ret = Array(n), i;
    if(k === s.length-1) {
        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
        if(i===-1) { ret[0] = v; }
        return ret;
    }
    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
    return ret;
}


numeric.dotMMsmall = function dotMMsmall(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
    p = x.length; q = y.length; r = y[0].length;
    ret = Array(p);
    for(i=p-1;i>=0;i--) {
        foo = Array(r);
        bar = x[i];
        for(k=r-1;k>=0;k--) {
            woo = bar[q-1]*y[q-1][k];
            for(j=q-2;j>=1;j-=2) {
                i0 = j-1;
                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
            }
            if(j===0) { woo += bar[0]*y[0][k]; }
            foo[k] = woo;
        }
        ret[i] = foo;
    }
    return ret;
}
numeric._getCol = function _getCol(A,j,x) {
    var n = A.length, i;
    for(i=n-1;i>0;--i) {
        x[i] = A[i][j];
        --i;
        x[i] = A[i][j];
    }
    if(i===0) x[0] = A[0][j];
}
numeric.dotMMbig = function dotMMbig(x,y){
    var gc = numeric._getCol, p = y.length, v = Array(p);
    var m = x.length, n = y[0].length, A = new Array(m), xj;
    var VV = numeric.dotVV;
    var i,j,k,z;
    --p;
    --m;
    for(i=m;i!==-1;--i) A[i] = Array(n);
    --n;
    for(i=n;i!==-1;--i) {
        gc(y,i,v);
        for(j=m;j!==-1;--j) {
            z=0;
            xj = x[j];
            A[j][i] = VV(xj,v);
        }
    }
    return A;
}

numeric.dotMV = function dotMV(x,y) {
    var p = x.length, q = y.length,i;
    var ret = Array(p), dotVV = numeric.dotVV;
    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
    return ret;
}

numeric.dotVM = function dotVM(x,y) {
    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
    p = x.length; q = y[0].length;
    ret = Array(q);
    for(k=q-1;k>=0;k--) {
        woo = x[p-1]*y[p-1][k];
        for(j=p-2;j>=1;j-=2) {
            i0 = j-1;
            woo += x[j]*y[j][k] + x[i0]*y[i0][k];
        }
        if(j===0) { woo += x[0]*y[0][k]; }
        ret[k] = woo;
    }
    return ret;
}

numeric.dotVV = function dotVV(x,y) {
    var i,n=x.length,i1,ret = x[n-1]*y[n-1];
    for(i=n-2;i>=1;i-=2) {
        i1 = i-1;
        ret += x[i]*y[i] + x[i1]*y[i1];
    }
    if(i===0) { ret += x[0]*y[0]; }
    return ret;
}

numeric.dot = function dot(x,y) {
    var d = numeric.dim;
    switch(d(x).length*1000+d(y).length) {
    case 2002:
        if(y.length < 10) return numeric.dotMMsmall(x,y);
        else return numeric.dotMMbig(x,y);
    case 2001: return numeric.dotMV(x,y);
    case 1002: return numeric.dotVM(x,y);
    case 1001: return numeric.dotVV(x,y);
    case 1000: return numeric.mulVS(x,y);
    case 1: return numeric.mulSV(x,y);
    case 0: return x*y;
    default: throw new Error('numeric.dot only works on vectors and matrices');
    }
}

numeric.diag = function diag(d) {
    var i,i1,j,n = d.length, A = Array(n), Ai;
    for(i=n-1;i>=0;i--) {
        Ai = Array(n);
        i1 = i+2;
        for(j=n-1;j>=i1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j>i) { Ai[j] = 0; }
        Ai[i] = d[i];
        for(j=i-1;j>=1;j-=2) {
            Ai[j] = 0;
            Ai[j-1] = 0;
        }
        if(j===0) { Ai[0] = 0; }
        A[i] = Ai;
    }
    return A;
}
numeric.getDiag = function(A) {
    var n = Math.min(A.length,A[0].length),i,ret = Array(n);
    for(i=n-1;i>=1;--i) {
        ret[i] = A[i][i];
        --i;
        ret[i] = A[i][i];
    }
    if(i===0) {
        ret[0] = A[0][0];
    }
    return ret;
}

numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
numeric.pointwise = function pointwise(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = '_s';
    fun[params.length+1] = '_k';
    fun[params.length+2] = (
            'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
            'if(typeof _k === "undefined") _k = 0;\n'+
            'var _n = _s[_k];\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            'if(_k < _s.length-1) {\n'+
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
            '    return ret;\n'+
            '}\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            '    '+body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric.pointwise2 = function pointwise2(params,body,setup) {
    if(typeof setup === "undefined") { setup = ""; }
    var fun = [];
    var k;
    var avec = /\[i\]$/,p,thevec = '';
    var haveret = false;
    for(k=0;k<params.length;k++) {
        if(avec.test(params[k])) {
            p = params[k].substring(0,params[k].length-3);
            thevec = p;
        } else { p = params[k]; }
        if(p==='ret') haveret = true;
        fun.push(p);
    }
    fun[params.length] = (
            'var _n = '+thevec+'.length;\n'+
            'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
            setup+'\n'+
            'for(i=_n-1;i!==-1;--i) {\n'+
            body+'\n'+
            '}\n'+
            'return ret;'
            );
    return Function.apply(null,fun);
}
numeric._biforeach = (function _biforeach(x,y,s,k,f) {
    if(k === s.length-1) { f(x,y); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
});
numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
    if(k === s.length-1) { return f(x,y); }
    var i,n=s[k],ret = Array(n);
    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
    return ret;
});
numeric._foreach = (function _foreach(x,s,k,f) {
    if(k === s.length-1) { f(x); return; }
    var i,n=s[k];
    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
});
numeric._foreach2 = (function _foreach2(x,s,k,f) {
    if(k === s.length-1) { return f(x); }
    var i,n=s[k], ret = Array(n);
    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
    return ret;
});

/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or:  '||',
        eq:  '===',
        neq: '!==',
        lt:  '<',
        gt:  '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
};
numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
};
numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
                    'exp','floor','log','round','sin','sqrt','tan',
                    'isNaN','isFinite'];
numeric.mathfuns2 = ['atan2','pow','max','min'];
numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
};
numeric.mapreducers = {
        any: ['if(xi) return true;','var accum = false;'],
        all: ['if(!xi) return false;','var accum = true;'],
        sum: ['accum += xi;','var accum = 0;'],
        prod: ['accum *= xi;','var accum = 1;'],
        norm2Squared: ['accum += xi*xi;','var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
};

(function () {
    var i,o;
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        numeric.ops2[o] = o;
    }
    for(i in numeric.ops2) {
        if(numeric.ops2.hasOwnProperty(i)) {
            o = numeric.ops2[i];
            var code, codeeq, setup = '';
            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                setup = 'var '+o+' = Math.'+o+';\n';
                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
            } else {
                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                if(numeric.opseq.hasOwnProperty(i+'eq')) {
                    codeeq = function(x,y) { return x+' '+o+'= '+y; };
                } else {
                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    
                }
            }
            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
            numeric[i] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                    'var dim = numeric.dim;\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof x === "object") {\n'+
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                    '  else '+codeeq('x','y')+'\n'+
                    '}\nreturn x;\n');
            numeric[o] = numeric[i];
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
            numeric[i+'eq'] = Function(
                    'var n = arguments.length, i, x = arguments[0], y;\n'+
                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                    'var s = numeric.dim(x);\n'+
                    'for(i=1;i!==n;++i) { \n'+
                    '  y = arguments[i];\n'+
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                    '  else numeric._biforeach(x,y,s,0,S);\n'+
                    '}\nreturn x;\n');
        }
    }
    for(i=0;i<numeric.mathfuns2.length;++i) {
        o = numeric.mathfuns2[i];
        delete numeric.ops2[o];
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        numeric.ops1[o] = o;
    }
    for(i in numeric.ops1) {
        if(numeric.ops1.hasOwnProperty(i)) {
            setup = '';
            o = numeric.ops1[i];
            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
            }
            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
            numeric[i+'eq'] = Function('x',
                    'if(typeof x !== "object") return '+o+'x\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'eqV;\n'+
                    'var s = numeric.dim(x);\n'+
                    'numeric._foreach(x,s,0,V);\n'+
                    'return x;\n');
            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
            numeric[i] = Function('x',
                    'if(typeof x !== "object") return '+o+'(x)\n'+
                    'var i;\n'+
                    'var V = numeric.'+i+'V;\n'+
                    'var s = numeric.dim(x);\n'+
                    'return numeric._foreach2(x,s,0,V);\n');
        }
    }
    for(i=0;i<numeric.mathfuns.length;++i) {
        o = numeric.mathfuns[i];
        delete numeric.ops1[o];
    }
    for(i in numeric.mapreducers) {
        if(numeric.mapreducers.hasOwnProperty(i)) {
            o = numeric.mapreducers[i];
            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
            numeric[i] = Function('x','s','k',
                    o[1]+
                    'if(typeof x !== "object") {'+
                    '    xi = x;\n'+
                    o[0]+';\n'+
                    '    return accum;\n'+
                    '}'+
                    'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                    'if(typeof k === "undefined") k = 0;\n'+
                    'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                    'var xi;\n'+
                    'var n = x.length, i;\n'+
                    'for(i=n-1;i!==-1;--i) {\n'+
                    '   xi = arguments.callee(x[i]);\n'+
                    o[0]+';\n'+
                    '}\n'+
                    'return accum;\n');
        }
    }
}());

numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
numeric.trunc = function trunc(x,y) {
    if(typeof x === "object") {
        if(typeof y === "object") return numeric.truncVV(x,y);
        return numeric.truncVS(x,y);
    }
    if (typeof y === "object") return numeric.truncSV(x,y);
    return Math.round(x/y)*y;
}

numeric.inv = function inv(x) {
    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
    var A = numeric.clone(x), Ai, Aj;
    var I = numeric.identity(m), Ii, Ij;
    var i,j,k,x;
    for(j=0;j<n;++j) {
        var i0 = -1;
        var v0 = -1;
        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
        x = Aj[j];
        for(k=j;k!==n;++k)    Aj[k] /= x; 
        for(k=n-1;k!==-1;--k) Ij[k] /= x;
        for(i=m-1;i!==-1;--i) {
            if(i!==j) {
                Ai = A[i];
                Ii = I[i];
                x = Ai[j];
                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                if(k===0) Ii[0] -= Ij[0]*x;
            }
        }
    }
    return I;
}

numeric.det = function det(x) {
    var s = numeric.dim(x);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
    for(j=0;j<n-1;j++) {
        k=j;
        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
        if(k !== j) {
            temp = A[k]; A[k] = A[j]; A[j] = temp;
            ret *= -1;
        }
        Aj = A[j];
        for(i=j+1;i<n;i++) {
            Ai = A[i];
            alpha = Ai[j]/Aj[j];
            for(k=j+1;k<n-1;k+=2) {
                k1 = k+1;
                Ai[k] -= Aj[k]*alpha;
                Ai[k1] -= Aj[k1]*alpha;
            }
            if(k!==n) { Ai[k] -= Aj[k]*alpha; }
        }
        if(Aj[j] === 0) { return 0; }
        ret *= Aj[j];
    }
    return ret*A[j][j];
}

numeric.transpose = function transpose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
            --j;
            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = A0[j];
            --j;
            ret[j][0] = A0[j];
        }
        if(j===0) { ret[0][0] = A0[0]; }
    }
    return ret;
}
numeric.negtranspose = function negtranspose(x) {
    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
    for(j=0;j<n;j++) ret[j] = Array(m);
    for(i=m-1;i>=1;i-=2) {
        A1 = x[i];
        A0 = x[i-1];
        for(j=n-1;j>=1;--j) {
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
            --j;
            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
        }
        if(j===0) {
            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
        }
    }
    if(i===0) {
        A0 = x[0];
        for(j=n-1;j>=1;--j) {
            ret[j][0] = -A0[j];
            --j;
            ret[j][0] = -A0[j];
        }
        if(j===0) { ret[0][0] = -A0[0]; }
    }
    return ret;
}

numeric._random = function _random(s,k) {
    var i,n=s[k],ret=Array(n), rnd;
    if(k === s.length-1) {
        rnd = Math.random;
        for(i=n-1;i>=1;i-=2) {
            ret[i] = rnd();
            ret[i-1] = rnd();
        }
        if(i===0) { ret[0] = rnd(); }
        return ret;
    }
    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
    return ret;
}
numeric.random = function random(s) { return numeric._random(s,0); }

numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

numeric.linspace = function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}

numeric.getBlock = function getBlock(x,from,to) {
    var s = numeric.dim(x);
    function foo(x,k) {
        var i,a = from[k], n = to[k]-a, ret = Array(n);
        if(k === s.length-1) {
            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
            return ret;
        }
        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
        return ret;
    }
    return foo(x,0);
}

numeric.setBlock = function setBlock(x,from,to,B) {
    var s = numeric.dim(x);
    function foo(x,y,k) {
        var i,a = from[k], n = to[k]-a;
        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
    }
    foo(x,B,0);
    return x;
}

numeric.getRange = function getRange(A,I,J) {
    var m = I.length, n = J.length;
    var i,j;
    var B = Array(m), Bi, AI;
    for(i=m-1;i!==-1;--i) {
        B[i] = Array(n);
        Bi = B[i];
        AI = A[I[i]];
        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
    }
    return B;
}

numeric.blockMatrix = function blockMatrix(X) {
    var s = numeric.dim(X);
    if(s.length<4) return numeric.blockMatrix([X]);
    var m=s[0],n=s[1],M,N,i,j,Xij;
    M = 0; N = 0;
    for(i=0;i<m;++i) M+=X[i][0].length;
    for(j=0;j<n;++j) N+=X[0][j][0].length;
    var Z = Array(M);
    for(i=0;i<M;++i) Z[i] = Array(N);
    var I=0,J,ZI,k,l,Xijk;
    for(i=0;i<m;++i) {
        J=N;
        for(j=n-1;j!==-1;--j) {
            Xij = X[i][j];
            J -= Xij[0].length;
            for(k=Xij.length-1;k!==-1;--k) {
                Xijk = Xij[k];
                ZI = Z[I+k];
                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
            }
        }
        I += X[i][0].length;
    }
    return Z;
}

numeric.tensor = function tensor(x,y) {
    if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
    var s1 = numeric.dim(x), s2 = numeric.dim(y);
    if(s1.length !== 1 || s2.length !== 1) {
        throw new Error('numeric: tensor product is only defined for vectors');
    }
    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
    for(i=m-1;i>=0;i--) {
        Ai = Array(n);
        xi = x[i];
        for(j=n-1;j>=3;--j) {
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
            --j;
            Ai[j] = xi * y[j];
        }
        while(j>=0) { Ai[j] = xi * y[j]; --j; }
        A[i] = Ai;
    }
    return A;
}

// 3. The Tensor type T
numeric.T = function T(x,y) { this.x = x; this.y = y; }
numeric.t = function t(x,y) { return new numeric.T(x,y); }

numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
    var io = numeric.indexOf;
    if(typeof setup !== "string") {
        var k;
        setup = '';
        for(k in numeric) {
            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                setup += 'var '+k+' = numeric.'+k+';\n';
            }
        }
    }
    return Function(['y'],
            'var x = this;\n'+
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
            setup+'\n'+
            'if(x.y) {'+
            '  if(y.y) {'+
            '    return new numeric.T('+cc+');\n'+
            '  }\n'+
            '  return new numeric.T('+cr+');\n'+
            '}\n'+
            'if(y.y) {\n'+
            '  return new numeric.T('+rc+');\n'+
            '}\n'+
            'return new numeric.T('+rr+');\n'
    );
}

numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

numeric.T.prototype.reciprocal = function reciprocal() {
    var mul = numeric.mul, div = numeric.div;
    if(this.y) {
        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
    }
    return new T(div(1,this.x));
}
numeric.T.prototype.div = function div(y) {
    if(!(y instanceof numeric.T)) y = new numeric.T(y);
    if(y.y) { return this.mul(y.reciprocal()); }
    var div = numeric.div;
    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
    return new numeric.T(div(this.x,y.x));
}
numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
numeric.T.prototype.transpose = function transpose() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),t(y)); }
    return new numeric.T(t(x));
}
numeric.T.prototype.transjugate = function transjugate() {
    var t = numeric.transpose, x = this.x, y = this.y;
    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
    return new numeric.T(t(x));
}
numeric.Tunop = function Tunop(r,c,s) {
    if(typeof s !== "string") { s = ''; }
    return Function(
            'var x = this;\n'+
            s+'\n'+
            'if(x.y) {'+
            '  '+c+';\n'+
            '}\n'+
            r+';\n'
    );
}

numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
        'return new numeric.T(numeric.log(r.x),theta.x);');
numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n'+
        'return Math.sqrt(f(x.x)+f(x.y));');
numeric.T.prototype.inv = function inv() {
    var A = this;
    if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
    var n = A.x.length, i, j, k;
    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
    var i,j,k,d,d1,ax,ay,bx,by,temp;
    for(i=0;i<n;i++) {
        ax = Ax[i][i]; ay = Ay[i][i];
        d = ax*ax+ay*ay;
        k = i;
        for(j=i+1;j<n;j++) {
            ax = Ax[j][i]; ay = Ay[j][i];
            d1 = ax*ax+ay*ay;
            if(d1 > d) { k=j; d = d1; }
        }
        if(k!==i) {
            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
        }
        Aix = Ax[i]; Aiy = Ay[i];
        Rix = Rx[i]; Riy = Ry[i];
        ax = Aix[i]; ay = Aiy[i];
        for(j=i+1;j<n;j++) {
            bx = Aix[j]; by = Aiy[j];
            Aix[j] = (bx*ax+by*ay)/d;
            Aiy[j] = (by*ax-bx*ay)/d;
        }
        for(j=0;j<n;j++) {
            bx = Rix[j]; by = Riy[j];
            Rix[j] = (bx*ax+by*ay)/d;
            Riy[j] = (by*ax-bx*ay)/d;
        }
        for(j=i+1;j<n;j++) {
            Ajx = Ax[j]; Ajy = Ay[j];
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ajx[i]; ay = Ajy[i];
            for(k=i+1;k<n;k++) {
                bx = Aix[k]; by = Aiy[k];
                Ajx[k] -= bx*ax-by*ay;
                Ajy[k] -= by*ax+bx*ay;
            }
            for(k=0;k<n;k++) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= bx*ax-by*ay;
                Rjy[k] -= by*ax+bx*ay;
            }
        }
    }
    for(i=n-1;i>0;i--) {
        Rix = Rx[i]; Riy = Ry[i];
        for(j=i-1;j>=0;j--) {
            Rjx = Rx[j]; Rjy = Ry[j];
            ax = Ax[j][i]; ay = Ay[j][i];
            for(k=n-1;k>=0;k--) {
                bx = Rix[k]; by = Riy[k];
                Rjx[k] -= ax*bx - ay*by;
                Rjy[k] -= ax*by + ay*bx;
            }
        }
    }
    return new numeric.T(Rx,Ry);
}
numeric.T.prototype.get = function get(i) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length;
    if(y) {
        while(k<n) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        return new numeric.T(x,y);
    }
    while(k<n) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    return new numeric.T(x);
}
numeric.T.prototype.set = function set(i,v) {
    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
    if(n===0) {
        if(vy) { this.y = vy; }
        else if(y) { this.y = undefined; }
        this.x = x;
        return this;
    }
    if(vy) {
        if(y) { /* ok */ }
        else {
            y = numeric.rep(numeric.dim(x),0);
            this.y = y;
        }
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        y[ik] = vy;
        return this;
    }
    if(y) {
        while(k<n-1) {
            ik = i[k];
            x = x[ik];
            y = y[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
        else y[ik] = 0;
        return this;
    }
    while(k<n-1) {
        ik = i[k];
        x = x[ik];
        k++;
    }
    ik = i[k];
    x[ik] = vx;
    return this;
}
numeric.T.prototype.getRows = function getRows(i0,i1) {
    var n = i1-i0+1, j;
    var rx = Array(n), ry, x = this.x, y = this.y;
    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
    if(y) {
        ry = Array(n);
        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
        return new numeric.T(rx,ry);
    }
    return new numeric.T(rx);
}
numeric.T.prototype.setRows = function setRows(i0,i1,A) {
    var j;
    var rx = this.x, ry = this.y, x = A.x, y = A.y;
    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
    } else if(ry) {
        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
    }
    return this;
}
numeric.T.prototype.getRow = function getRow(k) {
    var x = this.x, y = this.y;
    if(y) { return new numeric.T(x[k],y[k]); }
    return new numeric.T(x[k]);
}
numeric.T.prototype.setRow = function setRow(i,v) {
    var rx = this.x, ry = this.y, x = v.x, y = v.y;
    rx[i] = x;
    if(y) {
        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
        ry[i] = y;
    } else if(ry) {
        ry = numeric.rep([x.length],0);
    }
    return this;
}

numeric.T.prototype.getBlock = function getBlock(from,to) {
    var x = this.x, y = this.y, b = numeric.getBlock;
    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
    return new numeric.T(b(x,from,to));
}
numeric.T.prototype.setBlock = function setBlock(from,to,A) {
    if(!(A instanceof numeric.T)) A = new numeric.T(A);
    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
    if(Ay) {
        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
        b(x,from,to,Ax);
        b(y,from,to,Ay);
        return this;
    }
    b(x,from,to,Ax);
    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
}
numeric.T.rep = function rep(s,v) {
    var T = numeric.T;
    if(!(v instanceof T)) v = new T(v);
    var x = v.x, y = v.y, r = numeric.rep;
    if(y) return new T(r(s,x),r(s,y));
    return new T(r(s,x));
}
numeric.T.diag = function diag(d) {
    if(!(d instanceof numeric.T)) d = new numeric.T(d);
    var x = d.x, y = d.y, diag = numeric.diag;
    if(y) return new numeric.T(diag(x),diag(y));
    return new numeric.T(diag(x));
}
numeric.T.eig = function eig() {
    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
    return numeric.eig(this.x);
}
numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
numeric.T.prototype.getDiag = function getDiag() {
    var n = numeric;
    var x = this.x, y = this.y;
    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
    return new n.T(n.getDiag(x));
}

// 4. Eigenvalues of real matrices

numeric.house = function house(x) {
    var v = numeric.clone(x);
    var s = x[0] >= 0 ? 1 : -1;
    var alpha = s*numeric.norm2(x);
    v[0] += alpha;
    var foo = numeric.norm2(v);
    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
    return numeric.div(v,foo);
}

numeric.toUpperHessenberg = function toUpperHessenberg(me) {
    var s = numeric.dim(me);
    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
    for(j=0;j<m-2;j++) {
        x = Array(m-j-1);
        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
        if(numeric.norm2(x)>0) {
            v = numeric.house(x);
            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
            B = Array(m-j-1);
            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    return {H:A, Q:Q};
}

numeric.epsilon = 2.220446049250313e-16;

numeric.QRFrancis = function(H,maxiter) {
    if(typeof maxiter === "undefined") { maxiter = 10000; }
    H = numeric.clone(H);
    var H0 = numeric.clone(H);
    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
    var epsilon = numeric.epsilon;
    for(iter=0;iter<maxiter;iter++) {
        for(j=0;j<m-1;j++) {
            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                B = Array(j+1);
                for(i=0;i<=j;i++) { B[i] = Q[i]; }
                C = numeric.dot(QH1.Q,B);
                for(i=0;i<=j;i++) { Q[i] = C[i]; }
                B = Array(m-j-1);
                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                C = numeric.dot(QH2.Q,B);
                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
            }
        }
        a = H[m-2][m-2]; b = H[m-2][m-1];
        c = H[m-1][m-2]; d = H[m-1][m-1];
        tr = a+d;
        det = (a*d-b*c);
        Hloc = numeric.getBlock(H, [0,0], [2,2]);
        if(tr*tr>=4*det) {
            var s1,s2;
            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,s1+s2)),
                               numeric.diag(numeric.rep([3],s1*s2)));
        } else {
            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                                           numeric.mul(Hloc,tr)),
                               numeric.diag(numeric.rep([3],det)));
        }
        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
        v = numeric.house(x);
        B = [H[0],H[1],H[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
        B = numeric.getBlock(H, [0,0],[m-1,2]);
        C = numeric.tensor(numeric.dot(B,v),v);
        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
        B = [Q[0],Q[1],Q[2]];
        C = numeric.tensor(v,numeric.dot(v,B));
        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        var J;
        for(j=0;j<m-2;j++) {
            for(k=j;k<=j+1;k++) {
                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                    B = Array(k+1);
                    for(i=0;i<=k;i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q,B);
                    for(i=0;i<=k;i++) { Q[i] = C[i]; }
                    B = Array(m-k-1);
                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                    C = numeric.dot(QH2.Q,B);
                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                }
            }
            J = Math.min(m-1,j+3);
            x = Array(J-j);
            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
            v = numeric.house(x);
            B = numeric.getBlock(H, [j+1,j],[J,m-1]);
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
            B = numeric.getBlock(H, [0,j+1],[m-1,J]);
            C = numeric.tensor(numeric.dot(B,v),v);
            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
            B = Array(J-j);
            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
            C = numeric.tensor(v,numeric.dot(v,B));
            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
        }
    }
    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
}

numeric.eig = function eig(A,maxiter) {
    var QH = numeric.toUpperHessenberg(A);
    var QB = numeric.QRFrancis(QH.H,maxiter);
    var T = numeric.T;
    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
    var m = B.length,j;
    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
    var sqrt = Math.sqrt;
    for(k=0;k<m;k++) {
        i = B[k][0];
        if(i === B[k][1]) {
            // nothing
        } else {
            j = i+1;
            a = H[i][i];
            b = H[i][j];
            c = H[j][i];
            d = H[j][j];
            if(b === 0 && c === 0) continue;
            p1 = -a-d;
            p2 = a*d-b*c;
            disc = p1*p1-4*p2;
            if(disc>=0) {
                if(p1<0) x = -0.5*(p1-sqrt(disc));
                else     x = -0.5*(p1+sqrt(disc));
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1);
                    p = (a-x)/n1;
                    q = b/n1;
                } else {
                    n2 = sqrt(n2);
                    p = c/n2;
                    q = (d-x)/n2;
                }
                Q0 = new T([[q,-p],[p,q]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            } else {
                x = -0.5*p1;
                y = 0.5*sqrt(-disc);
                n1 = (a-x)*(a-x)+b*b;
                n2 = c*c+(d-x)*(d-x);
                if(n1>n2) {
                    n1 = sqrt(n1+y*y);
                    p = (a-x)/n1;
                    q = b/n1;
                    x = 0;
                    y /= n1;
                } else {
                    n2 = sqrt(n2+y*y);
                    p = c/n2;
                    q = (d-x)/n2;
                    x = y/n2;
                    y = 0;
                }
                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
            }
        }
    }
    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
    for(j=0;j<n;j++) {
        if(j>0) {
            for(k=j-1;k>=0;k--) {
                var Rk = R.get([k,k]), Rj = R.get([j,j]);
                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                    x = R.getRow(k).getBlock([k],[j-1]);
                    y = E.getRow(j).getBlock([k],[j-1]);
                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                } else {
                    E.setRow(j,E.getRow(k));
                    continue;
                }
            }
        }
    }
    for(j=0;j<n;j++) {
        x = E.getRow(j);
        E.setRow(j,x.div(x.norm2()));
    }
    E = E.transpose();
    E = Q.transjugate().dot(E);
    return { lambda:R.getDiag(), E:E };
};

// 5. Compressed Column Storage matrices
numeric.ccsSparse = function ccsSparse(A) {
    var m = A.length,n,foo, i,j, counts = [];
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            j = parseInt(j);
            while(j>=counts.length) counts[counts.length] = 0;
            if(foo[j]!==0) counts[j]++;
        }
    }
    var n = counts.length;
    var Ai = Array(n+1);
    Ai[0] = 0;
    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
    var Aj = Array(Ai[n]), Av = Array(Ai[n]);
    for(i=m-1;i!==-1;--i) {
        foo = A[i];
        for(j in foo) {
            if(foo[j]!==0) {
                counts[j]--;
                Aj[Ai[j]+counts[j]] = i;
                Av[Ai[j]+counts[j]] = foo[j];
            }
        }
    }
    return [Ai,Aj,Av];
}
numeric.ccsFull = function ccsFull(A) {
    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
    var B = numeric.rep([m,n],0);
    for(i=0;i<n;i++) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
    }
    return B;
}
numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
    if(typeof bj === "undefined") x = numeric.rep([m],0);
    if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
    if(typeof xj === "undefined") xj = [];
    function dfs(j) {
        var k;
        if(x[j] !== 0) return;
        x[j] = 1;
        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
        xj[n] = j;
        ++n;
    }
    var i,j,j0,j1,k,l,l0,l1,a;
    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
    xj.length = n;
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = max(Ai[j+1],j0);
        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k!==j1;++k) {
            l = Aj[k];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsDFS = function ccsDFS(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[J];
    k1[0] = k11 = Ai[J+1];
    while(1) {
        if(km >= k11) {
            xj[n] = j[m];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Pinv[Aj[km]];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
        a = x[j];
        for(k=j0;k<j1;++k) {
            l = Pinv[Aj[k]];
            if(l !== j) x[l] -= a*Av[k];
        }
    }
    return x;
}
numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var x = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,x,xj,i,Pinv,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(x[k]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(x[i])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
            a = x[i]; x[i] = x[e]; x[e] = a;
        }
        a = Li[i];
        e = Ui[i];
        d = x[i];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = x[k];
            xj[j] = 0;
            x[k] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsDFS0 = function ccsDFS0(n) {
    this.k = Array(n);
    this.k1 = Array(n);
    this.j = Array(n);
}
numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
    var m = 0,foo,n=xj.length;
    var k = this.k, k1 = this.k1, j = this.j,km,k11;
    if(x[J]!==0) return;
    x[J] = 1;
    j[0] = J;
    k[0] = km = Ai[Pinv[J]];
    k1[0] = k11 = Ai[Pinv[J]+1];
    while(1) {
        if(isNaN(km)) throw new Error("Ow!");
        if(km >= k11) {
            xj[n] = Pinv[j[m]];
            if(m===0) return;
            ++n;
            --m;
            km = k[m];
            k11 = k1[m];
        } else {
            foo = Aj[km];
            if(x[foo] === 0) {
                x[foo] = 1;
                k[m] = km;
                ++m;
                j[m] = foo;
                foo = Pinv[foo];
                km = Ai[foo];
                k1[m] = k11 = Ai[foo+1];
            } else ++km;
        }
    }
}
numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
    var Bi = B[0], Bj = B[1], Bv = B[2];
    
    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
    i0 = Bi[I];
    i1 = Bi[I+1];
    xj.length = 0;
    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
    for(i=xj.length-1;i!==-1;--i) {
        j = xj[i];
        l = P[j];
        j0 = Ai[j];
        j1 = Ai[j+1];
        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
        a = y[l];
        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
        y[l] = a;
    }
}
numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
    var m = A[0].length-1;
    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
    var y = numeric.rep([m],0), xj = numeric.rep([m],0);
    var i,j,k,j0,j1,a,e,c,d,K;
    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
    var dfs = new numeric.ccsDFS0(m);
    if(typeof threshold === "undefined") { threshold = 1; }
    for(i=0;i<m;++i) {
        sol(L,A,y,xj,i,Pinv,P,dfs);
        a = -1;
        e = -1;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            if(k <= i) continue;
            c = abs(y[P[k]]);
            if(c > a) { e = k; a = c; }
        }
        if(abs(y[P[i]])<threshold*a) {
            j = P[i];
            a = P[e];
            P[i] = a; Pinv[a] = i;
            P[e] = j; Pinv[j] = e;
        }
        a = Li[i];
        e = Ui[i];
        d = y[P[i]];
        Lj[a] = P[i];
        Lv[a] = 1;
        ++a;
        for(j=xj.length-1;j!==-1;--j) {
            k = xj[j];
            c = y[P[k]];
            xj[j] = 0;
            y[P[k]] = 0;
            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
        }
        Li[i+1] = a;
        Ui[i+1] = e;
    }
    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
    return {L:L, U:U, P:P, Pinv:Pinv};
}
numeric.ccsLUP = numeric.ccsLUP0;

numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
    var s = numeric.ccsDim(A),m=s[0],n=s[1];
    if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
    else if(typeof i === "number") { i = [i]; }
    if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
    else if(typeof j === "number") { j = [j]; }
    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
    var Ai = A[0], Aj = A[1], Av = A[2];
    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
    for(q=0;q<Q;++q) {
        jq = j[q];
        var q0 = Ai[jq];
        var q1 = Ai[jq+1];
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 1;
            x[r] = Av[p];
        }
        for(p=0;p<P;++p) {
            ip = i[p];
            if(flags[ip]) {
                Bj[count] = p;
                Bv[count] = x[i[p]];
                ++count;
            }
        }
        for(p=q0;p<q1;++p) {
            r = Aj[p];
            flags[r] = 0;
        }
        Bi[q+1] = count;
    }
    return B;
}

numeric.ccsDot = function ccsDot(A,B) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var Bi = B[0], Bj = B[1], Bv = B[2];
    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
    var m = sA[0], n = sA[1], o = sB[1];
    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
    var i,j,k,j0,j1,i0,i1,l,p,a,b;
    for(k=0;k!==o;++k) {
        j0 = Bi[k];
        j1 = Bi[k+1];
        p = 0;
        for(j=j0;j<j1;++j) {
            a = Bj[j];
            b = Bv[j];
            i0 = Ai[a];
            i1 = Ai[a+1];
            for(i=i0;i<i1;++i) {
                l = Aj[i];
                if(flags[l]===0) {
                    xj[p] = l;
                    flags[l] = 1;
                    p = p+1;
                }
                x[l] = x[l] + Av[i]*b;
            }
        }
        j0 = Ci[k];
        j1 = j0+p;
        Ci[k+1] = j1;
        for(j=p-1;j!==-1;--j) {
            b = j0+j;
            i = xj[j];
            Cj[b] = i;
            Cv[b] = x[i];
            flags[i] = 0;
            x[i] = 0;
        }
        Ci[k+1] = Ci[k]+p;
    }
    return C;
}

numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
    var L = LUP.L, U = LUP.U, P = LUP.P;
    var Bi = B[0];
    var flag = false;
    if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
    var Bj = B[1], Bv = B[2];
    var n = L[0].length-1, m = Bi.length-1;
    var x = numeric.rep([n],0), xj = Array(n);
    var b = numeric.rep([n],0), bj = Array(n);
    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
    var sol = numeric.ccsTSolve;
    var i,j,j0,j1,k,J,N=0;
    for(i=0;i<m;++i) {
        k = 0;
        j0 = Bi[i];
        j1 = Bi[i+1];
        for(j=j0;j<j1;++j) { 
            J = LUP.Pinv[Bj[j]];
            bj[k] = J;
            b[J] = Bv[j];
            ++k;
        }
        bj.length = k;
        sol(L,b,x,bj,xj);
        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
        sol(U,x,b,xj,bj);
        if(flag) return b;
        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
        for(j=bj.length-1;j!==-1;--j) {
            J = bj[j];
            Xj[N] = J;
            Xv[N] = b[J];
            b[J] = 0;
            ++N;
        }
        Xi[i+1] = N;
    }
    return [Xi,Xj,Xv];
}

numeric.ccsbinop = function ccsbinop(body,setup) {
    if(typeof setup === "undefined") setup='';
    return Function('X','Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
            'var xk,yk,zk;\n'+
            'var i,j,j0,j1,k,p=0;\n'+
            setup+
            'for(i=0;i<n;++i) {\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Xj[j];\n'+
            '    x[k] = 1;\n'+
            '    Zj[p] = k;\n'+
            '    ++p;\n'+
            '  }\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Yj[j];\n'+
            '    y[k] = Yv[j];\n'+
            '    if(x[k] === 0) {\n'+
            '      Zj[p] = k;\n'+
            '      ++p;\n'+
            '    }\n'+
            '  }\n'+
            '  Zi[i+1] = p;\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
            '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) {\n'+
            '    k = Zj[j];\n'+
            '    xk = x[k];\n'+
            '    yk = y[k];\n'+
            body+'\n'+
            '    Zv[j] = zk;\n'+
            '  }\n'+
            '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
            '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
            '}\n'+
            'return [Zi,Zj,Zv];'
            );
};

(function() {
    var k,A,B,C;
    for(k in numeric.ops2) {
        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
        else A = 'NaN';
        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
        else B = 'NaN';
        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
        else C = 'NaN';
        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
        numeric['ccs'+k] = Function('X','Y',
                'if(typeof X === "number") return '+A+';\n'+
                'if(typeof Y === "number") return '+B+';\n'+
                'return '+C+';\n'
                );
    }
}());

numeric.ccsScatter = function ccsScatter(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = numeric.sup(Aj)+1,m=Ai.length;
    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
    var counts = numeric.rep([n],0),i;
    for(i=0;i<m;++i) counts[Aj[i]]++;
    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
    var ptr = Ri.slice(0),k,Aii;
    for(i=0;i<m;++i) {
        Aii = Aj[i];
        k = ptr[Aii];
        Rj[k] = Ai[i];
        Rv[k] = Av[i];
        ptr[Aii]=ptr[Aii]+1;
    }
    return [Ri,Rj,Rv];
}

numeric.ccsGather = function ccsGather(A) {
    var Ai = A[0], Aj = A[1], Av = A[2];
    var n = Ai.length-1,m = Aj.length;
    var Ri = Array(m), Rj = Array(m), Rv = Array(m);
    var i,j,j0,j1,p;
    p=0;
    for(i=0;i<n;++i) {
        j0 = Ai[i];
        j1 = Ai[i+1];
        for(j=j0;j!==j1;++j) {
            Rj[p] = i;
            Ri[p] = Aj[j];
            Rv[p] = Av[j];
            ++p;
        }
    }
    return [Ri,Rj,Rv];
}

// The following sparse linear algebra routines are deprecated.

numeric.sdim = function dim(A,ret,k) {
    if(typeof ret === "undefined") { ret = []; }
    if(typeof A !== "object") return ret;
    if(typeof k === "undefined") { k=0; }
    if(!(k in ret)) { ret[k] = 0; }
    if(A.length > ret[k]) ret[k] = A.length;
    var i;
    for(i in A) {
        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
    }
    return ret;
};

numeric.sclone = function clone(A,k,n) {
    if(typeof k === "undefined") { k=0; }
    if(typeof n === "undefined") { n = numeric.sdim(A).length; }
    var i,ret = Array(A.length);
    if(k === n-1) {
        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
        return ret;
    }
    for(i in A) {
        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
    }
    return ret;
}

numeric.sdiag = function diag(d) {
    var n = d.length,i,ret = Array(n),i1,i2,i3;
    for(i=n-1;i>=1;i-=2) {
        i1 = i-1;
        ret[i] = []; ret[i][i] = d[i];
        ret[i1] = []; ret[i1][i1] = d[i1];
    }
    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
    return ret;
}

numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

numeric.stranspose = function transpose(A) {
    var ret = [], n = A.length, i,j,Ai;
    for(i in A) {
        if(!(A.hasOwnProperty(i))) continue;
        Ai = A[i];
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(typeof ret[j] !== "object") { ret[j] = []; }
            ret[j][i] = Ai[j];
        }
    }
    return ret;
}

numeric.sLUP = function LUP(A,tol) {
    throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};

numeric.sdotMM = function dotMM(A,B) {
    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
    var i,j,k,accum;
    var ret = Array(p),reti;
    for(i=p-1;i>=0;i--) {
        reti = [];
        Ai = A[i];
        for(k=r-1;k>=0;k--) {
            accum = 0;
            BTk = BT[k];
            for(j in Ai) {
                if(!(Ai.hasOwnProperty(j))) continue;
                if(j in BTk) { accum += Ai[j]*BTk[j]; }
            }
            if(accum) reti[k] = accum;
        }
        ret[i] = reti;
    }
    return ret;
}

numeric.sdotMV = function dotMV(A,x) {
    var p = A.length, Ai, i,j;
    var ret = Array(p), accum;
    for(i=p-1;i>=0;i--) {
        Ai = A[i];
        accum = 0;
        for(j in Ai) {
            if(!(Ai.hasOwnProperty(j))) continue;
            if(x[j]) accum += Ai[j]*x[j];
        }
        if(accum) ret[i] = accum;
    }
    return ret;
}

numeric.sdotVM = function dotMV(x,A) {
    var i,j,Ai,alpha;
    var ret = [], accum;
    for(i in x) {
        if(!x.hasOwnProperty(i)) continue;
        Ai = A[i];
        alpha = x[i];
        for(j in Ai) {
            if(!Ai.hasOwnProperty(j)) continue;
            if(!ret[j]) { ret[j] = 0; }
            ret[j] += alpha*Ai[j];
        }
    }
    return ret;
}

numeric.sdotVV = function dotVV(x,y) {
    var i,ret=0;
    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
    return ret;
}

numeric.sdot = function dot(A,B) {
    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
    var k = m*1000+n;
    switch(k) {
    case 0: return A*B;
    case 1001: return numeric.sdotVV(A,B);
    case 2001: return numeric.sdotMV(A,B);
    case 1002: return numeric.sdotVM(A,B);
    case 2002: return numeric.sdotMM(A,B);
    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
    }
}

numeric.sscatter = function scatter(V) {
    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
    for(i=n-1;i>=0;--i) {
        if(!V[m-1][i]) continue;
        Aj = A;
        for(j=0;j<m-2;j++) {
            Vij = V[j][i];
            if(!Aj[Vij]) Aj[Vij] = [];
            Aj = Aj[Vij];
        }
        Aj[V[j][i]] = V[j+1][i];
    }
    return A;
}

numeric.sgather = function gather(A,ret,k) {
    if(typeof ret === "undefined") ret = [];
    if(typeof k === "undefined") k = [];
    var n,i,Ai;
    n = k.length;
    for(i in A) {
        if(A.hasOwnProperty(i)) {
            k[n] = parseInt(i);
            Ai = A[i];
            if(typeof Ai === "number") {
                if(Ai) {
                    if(ret.length === 0) {
                        for(i=n+1;i>=0;--i) ret[i] = [];
                    }
                    for(i=n;i>=0;--i) ret[i].push(k[i]);
                    ret[n+1].push(Ai);
                }
            } else gather(Ai,ret,k);
        }
    }
    if(k.length>n) k.pop();
    return ret;
}

// 6. Coordinate matrices
numeric.cLU = function LU(A) {
    var I = A[0], J = A[1], V = A[2];
    var p = I.length, m=0, i,j,k,a,b,c;
    for(i=0;i<p;i++) if(I[i]>m) m=I[i];
    m++;
    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
    var Ui, Uj,alpha;
    for(k=0;k<p;k++) {
        i = I[k];
        j = J[k];
        if(j<left[i]) left[i] = j;
        if(j>right[i]) right[i] = j;
    }
    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
    var countL = 0, countU = 0;
    for(i=0;i<m;i++) {
        U[i] = numeric.rep([right[i]-left[i]+1],0);
        L[i] = numeric.rep([i-left[i]],0);
        countL += i-left[i]+1;
        countU += right[i]-i+1;
    }
    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
    for(i=0;i<m-1;i++) {
        a = i-left[i];
        Ui = U[i];
        for(j=i+1;left[j]<=i && j<m;j++) {
            b = i-left[j];
            c = right[i]-i;
            Uj = U[j];
            alpha = Uj[b]/Ui[a];
            if(alpha) {
                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                L[j][i-left[j]] = alpha;
            }
        }
    }
    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
    var p,q,foo;
    p=0; q=0;
    for(i=0;i<m;i++) {
        a = left[i];
        b = right[i];
        foo = U[i];
        for(j=i;j<=b;j++) {
            if(foo[j-a]) {
                Ui[p] = i;
                Uj[p] = j;
                Uv[p] = foo[j-a];
                p++;
            }
        }
        foo = L[i];
        for(j=a;j<i;j++) {
            if(foo[j-a]) {
                Li[q] = i;
                Lj[q] = j;
                Lv[q] = foo[j-a];
                q++;
            }
        }
        Li[q] = i;
        Lj[q] = i;
        Lv[q] = 1;
        q++;
    }
    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
};

numeric.cLUsolve = function LUsolve(lu,b) {
    var L = lu.L, U = lu.U, ret = numeric.clone(b);
    var Li = L[0], Lj = L[1], Lv = L[2];
    var Ui = U[0], Uj = U[1], Uv = U[2];
    var p = Ui.length, q = Li.length;
    var m = ret.length,i,j,k;
    k = 0;
    for(i=0;i<m;i++) {
        while(Lj[k] < i) {
            ret[i] -= Lv[k]*ret[Lj[k]];
            k++;
        }
        k++;
    }
    k = p-1;
    for(i=m-1;i>=0;i--) {
        while(Uj[k] > i) {
            ret[i] -= Uv[k]*ret[Uj[k]];
            k--;
        }
        ret[i] /= Uv[k];
        k--;
    }
    return ret;
};

numeric.cgrid = function grid(n,shape) {
    if(typeof n === "number") n = [n,n];
    var ret = numeric.rep(n,-1);
    var i,j,count;
    if(typeof shape !== "function") {
        switch(shape) {
        case 'L':
            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
            break;
        default:
            shape = function(i,j) { return true; };
            break;
        }
    }
    count=0;
    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) 
        if(shape(i,j)) {
            ret[i][j] = count;
            count++;
        }
    return ret;
}

numeric.cdelsq = function delsq(g) {
    var dir = [[-1,0],[0,-1],[0,1],[1,0]];
    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
    var Li = [], Lj = [], Lv = [];
    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
        if(g[i][j]<0) continue;
        for(k=0;k<4;k++) {
            p = i+dir[k][0];
            q = j+dir[k][1];
            if(g[p][q]<0) continue;
            Li.push(g[i][j]);
            Lj.push(g[p][q]);
            Lv.push(-1);
        }
        Li.push(g[i][j]);
        Lj.push(g[i][j]);
        Lv.push(4);
    }
    return [Li,Lj,Lv];
}

numeric.cdotMV = function dotMV(A,x) {
    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
    N=0;
    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
    N++;
    ret = numeric.rep([N],0);
    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
    return ret;
}

// 7. Splines

numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
numeric.Spline.prototype._at = function _at(x1,p) {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var x1,a,b,t;
    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
    t = (x1-x[p])/(x[p+1]-x[p]);
    var s = t*(1-t);
    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
}
numeric.Spline.prototype.at = function at(x0) {
    if(typeof x0 === "number") {
        var x = this.x;
        var n = x.length;
        var p,q,mid,floor = Math.floor,a,b,t;
        p = 0;
        q = n-1;
        while(q-p>1) {
            mid = floor((p+q)/2);
            if(x[mid] <= x0) p = mid;
            else q = mid;
        }
        return this._at(x0,p);
    }
    var n = x0.length, i, ret = Array(n);
    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
    return ret;
}
numeric.Spline.prototype.diff = function diff() {
    var x = this.x;
    var yl = this.yl;
    var yr = this.yr;
    var kl = this.kl;
    var kr = this.kr;
    var n = yl.length;
    var i,dx,dy;
    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
    for(i=n-1;i!==-1;--i) {
        dx = x[i+1]-x[i];
        dy = sub(yr[i+1],yl[i]);
        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
    }
    return new numeric.Spline(x,zl,zr,pl,pr);
}
numeric.Spline.prototype.roots = function roots() {
    function sqr(x) { return x*x; }
    function heval(y0,y1,k0,k1,x) {
        var A = k0*2-(y1-y0);
        var B = -k1*2+(y1-y0);
        var t = (x+1)*0.5;
        var s = t*(1-t);
        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
    }
    var ret = [];
    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
    if(typeof yl[0] === "number") {
        yl = [yl];
        yr = [yr];
        kl = [kl];
        kr = [kr];
    }
    var m = yl.length,n=x.length-1,i,j,k,y,s,t;
    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
    var sqrt = Math.sqrt;
    for(i=0;i!==m;++i) {
        ai = yl[i];
        bi = yr[i];
        ci = kl[i];
        di = kr[i];
        ri = [];
        for(j=0;j!==n;j++) {
            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
            dx = (x[j+1]-x[j]);
            cx = x[j];
            y0 = ai[j];
            y1 = bi[j+1];
            k0 = ci[j]/dx;
            k1 = di[j+1]/dx;
            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
            A = k1+3*y0+2*k0-3*y1;
            B = 3*(k1+k0+2*(y0-y1));
            if(D<=0) {
                z0 = A/B;
                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                else stops = [x[j],x[j+1]];
            } else {
                z0 = (A-sqrt(D))/B;
                z1 = (A+sqrt(D))/B;
                stops = [x[j]];
                if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                stops.push(x[j+1]);
            }
            t0 = stops[0];
            z0 = this._at(t0,j);
            for(k=0;k<stops.length-1;k++) {
                t1 = stops[k+1];
                z1 = this._at(t1,j);
                if(z0 === 0) {
                    ri.push(t0); 
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                if(z1 === 0 || z0*z1>0) {
                    t0 = t1;
                    z0 = z1;
                    continue;
                }
                var side = 0;
                while(1) {
                    tm = (z0*t1-z1*t0)/(z0-z1);
                    if(tm <= t0 || tm >= t1) { break; }
                    zm = this._at(tm,j);
                    if(zm*z1>0) {
                        t1 = tm;
                        z1 = zm;
                        if(side === -1) z0*=0.5;
                        side = -1;
                    } else if(zm*z0>0) {
                        t0 = tm;
                        z0 = zm;
                        if(side === 1) z1*=0.5;
                        side = 1;
                    } else break;
                }
                ri.push(tm);
                t0 = stops[k+1];
                z0 = this._at(t0, j);
            }
            if(z1 === 0) ri.push(t1);
        }
        ret[i] = ri;
    }
    if(typeof this.yl[0] === "number") return ret[0];
    return ret;
}
numeric.spline = function spline(x,y,k1,kn) {
    var n = x.length, b = [], dx = [], dy = [];
    var i;
    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
    if(typeof k1 === "string" || typeof kn === "string") { 
        k1 = kn = "periodic";
    }
    // Build sparse tridiagonal system
    var T = [[],[],[]];
    switch(typeof k1) {
    case "undefined":
        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
        T[0].push(0,0);
        T[1].push(0,1);
        T[2].push(2/dx[0],1/dx[0]);
        break;
    case "string":
        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
        T[0].push(0,0,0);
        T[1].push(n-2,0,1);
        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
        break;
    default:
        b[0] = k1;
        T[0].push(0);
        T[1].push(0);
        T[2].push(1);
        break;
    }
    for(i=1;i<n-1;i++) {
        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
        T[0].push(i,i,i);
        T[1].push(i-1,i,i+1);
        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
    }
    switch(typeof kn) {
    case "undefined":
        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
        T[0].push(n-1,n-1);
        T[1].push(n-2,n-1);
        T[2].push(1/dx[n-2],2/dx[n-2]);
        break;
    case "string":
        T[1][T[1].length-1] = 0;
        break;
    default:
        b[n-1] = kn;
        T[0].push(n-1);
        T[1].push(n-1);
        T[2].push(1);
        break;
    }
    if(typeof b[0] !== "number") b = numeric.transpose(b);
    else b = [b];
    var k = Array(b.length);
    if(typeof k1 === "string") {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
            k[i][n-1] = k[i][0];
        }
    } else {
        for(i=k.length-1;i!==-1;--i) {
            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
        }
    }
    if(typeof y[0] === "number") k = k[0];
    else k = numeric.transpose(k);
    return new numeric.Spline(x,y,y,k,k);
}

// 8. FFT
numeric.fftpow2 = function fftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    fftpow2(xe,ye);
    fftpow2(xo,yo);
    j = n/2;
    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric._ifftpow2 = function _ifftpow2(x,y) {
    var n = x.length;
    if(n === 1) return;
    var cos = Math.cos, sin = Math.sin, i,j;
    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
    j = n/2;
    for(i=n-1;i!==-1;--i) {
        --j;
        xo[j] = x[i];
        yo[j] = y[i];
        --i;
        xe[j] = x[i];
        ye[j] = y[i];
    }
    _ifftpow2(xe,ye);
    _ifftpow2(xo,yo);
    j = n/2;
    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
    for(i=n-1;i!==-1;--i) {
        --j;
        if(j === -1) j = n/2-1;
        t = k*i;
        ci = cos(t);
        si = sin(t);
        x[i] = xe[j] + ci*xo[j] - si*yo[j];
        y[i] = ye[j] + ci*yo[j] + si*xo[j];
    }
}
numeric.ifftpow2 = function ifftpow2(x,y) {
    numeric._ifftpow2(x,y);
    numeric.diveq(x,x.length);
    numeric.diveq(y,y.length);
}
numeric.convpow2 = function convpow2(ax,ay,bx,by) {
    numeric.fftpow2(ax,ay);
    numeric.fftpow2(bx,by);
    var i,n = ax.length,axi,bxi,ayi,byi;
    for(i=n-1;i!==-1;--i) {
        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
        ax[i] = axi*bxi-ayi*byi;
        ay[i] = axi*byi+ayi*bxi;
    }
    numeric.ifftpow2(ax,ay);
}
numeric.T.prototype.fft = function fft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X;
}
numeric.T.prototype.ifft = function ifft() {
    var x = this.x, y = this.y;
    var n = x.length, log = Math.log, log2 = log(2),
        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
    for(k=0;k<n;k++) a[k] = x[k];
    if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
    cx[0] = 1;
    for(k=1;k<=m/2;k++) {
        t = c*k*k;
        cx[k] = cos(t);
        cy[k] = sin(t);
        cx[m-k] = cos(t);
        cy[m-k] = sin(t)
    }
    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
    X = X.mul(Y);
    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
    X = X.mul(Y);
    X.x.length = n;
    X.y.length = n;
    return X.div(n);
}

//9. Unconstrained optimization
numeric.gradient = function gradient(f,x) {
    var n = x.length;
    var f0 = f(x);
    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
    var max = Math.max;
    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
    var t0,t1,t2,it=0,d1,d2,N;
    for(i=0;i<n;i++) {
        var h = max(1e-6*f0,1e-8);
        while(1) {
            ++it;
            if(it>20) { throw new Error("Numerical gradient fails"); }
            x0[i] = x[i]+h;
            f1 = f(x0);
            x0[i] = x[i]-h;
            f2 = f(x0);
            x0[i] = x[i];
            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
            J[i] = (f1-f2)/(2*h);
            t0 = x[i]-h;
            t1 = x[i];
            t2 = x[i]+h;
            d1 = (f1-f0)/h;
            d2 = (f0-f2)/h;
            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
            if(errest>eps) { h/=16; }
            else break;
            }
    }
    return J;
}

numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
    var grad = numeric.gradient;
    if(typeof options === "undefined") { options = {}; }
    if(typeof tol === "undefined") { tol = 1e-8; }
    if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
    if(typeof maxit === "undefined") maxit = 1000;
    x0 = numeric.clone(x0);
    var n = x0.length;
    var f0 = f(x0),f1,df0;
    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
    var max = Math.max, norm2 = numeric.norm2;
    tol = max(tol,numeric.epsilon);
    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
    var msg = "";
    g0 = gradient(x0);
    while(it<maxit) {
        if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
        if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
        step = neg(dot(H1,g0));
        if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
        nstep = norm2(step);
        if(nstep < tol) { msg="Newton step smaller than tol"; break; }
        t = 1;
        df0 = dot(g0,step);
        // line search
        x1 = x0;
        while(it < maxit) {
            if(t*nstep < tol) { break; }
            s = mul(step,t);
            x1 = add(x0,s);
            f1 = f(x1);
            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                t *= 0.5;
                ++it;
                continue;
            }
            break;
        }
        if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
        if(it === maxit) { msg = "maxit reached during line search"; break; }
        g1 = gradient(x1);
        y = sub(g1,g0);
        ys = dot(y,s);
        Hy = dot(H1,y);
        H1 = sub(add(H1,
                mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                div(add(ten(Hy,s),ten(s,Hy)),ys));
        x0 = x1;
        f0 = f1;
        g0 = g1;
        ++it;
    }
    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
}

// 10. Ode solver (Dormand-Prince)
numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
    this.x = x;
    this.y = y;
    this.f = f;
    this.ymid = ymid;
    this.iterations = iterations;
    this.events = events;
    this.message = msg;
}
numeric.Dopri.prototype._at = function _at(xi,j) {
    function sqr(x) { return x*x; }
    var sol = this;
    var xs = sol.x;
    var ys = sol.y;
    var k1 = sol.f;
    var ymid = sol.ymid;
    var n = xs.length;
    var x0,x1,xh,y0,y1,yh,xi;
    var floor = Math.floor,h;
    var c = 0.5;
    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
    x0 = xs[j];
    x1 = xs[j+1];
    y0 = ys[j];
    y1 = ys[j+1];
    h  = x1-x0;
    xh = x0+c*h;
    yh = ymid[j];
    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
    return add(add(add(add(mul(y0,w[0]),
                           mul(yh,w[1])),
                           mul(y1,w[2])),
                           mul( p,w[3])),
                           mul( q,w[4]));
}
numeric.Dopri.prototype.at = function at(x) {
    var i,j,k,floor = Math.floor;
    if(typeof x !== "number") {
        var n = x.length, ret = Array(n);
        for(i=n-1;i!==-1;--i) {
            ret[i] = this.at(x[i]);
        }
        return ret;
    }
    var x0 = this.x;
    i = 0; j = x0.length-1;
    while(j-i>1) {
        k = floor(0.5*(i+j));
        if(x0[k] <= x) i = k;
        else j = k;
    }
    return this._at(x,i);
}

numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
    if(typeof tol === "undefined") { tol = 1e-6; }
    if(typeof maxit === "undefined") { maxit = 1000; }
    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
    var A2 = 1/5;
    var A3 = [3/40,9/40];
    var A4 = [44/45,-56/15,32/9];
    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
    var bm = [0.5*6025192743/30085553152,
              0,
              0.5*51252292925/65400821598,
              0.5*-2691868925/45128329728,
              0.5*187940372067/1594534317056,
              0.5*-1776094331/19743644256,
              0.5*11237099/235043384];
    var c = [1/5,3/10,4/5,8/9,1,1];
    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
    var i = 0,er,j;
    var h = (x1-x0)/10;
    var it = 0;
    var add = numeric.add, mul = numeric.mul, y1,erinf;
    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
    var e0, e1, ev;
    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
    if(typeof event === "function") e0 = event(x0,y0);
    while(x0<x1 && it<maxit) {
        ++it;
        if(x0+h>x1) h = x1-x0;
        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
        k7 = f(x0+h,y1);
        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
        if(typeof er === "number") erinf = abs(er);
        else erinf = norminf(er);
        if(erinf > tol) { // reject
            h = 0.2*h*pow(tol/erinf,0.25);
            if(x0+h === x0) {
                ret.msg = "Step size became too small";
                break;
            }
            continue;
        }
        ymid[i] = add(add(add(add(add(add(y0,
                mul(k1[i],h*bm[0])),
                mul(k3   ,h*bm[2])),
                mul(k4   ,h*bm[3])),
                mul(k5   ,h*bm[4])),
                mul(k6   ,h*bm[5])),
                mul(k7   ,h*bm[6]));
        ++i;
        xs[i] = x0+h;
        ys[i] = y1;
        k1[i] = k7;
        if(typeof event === "function") {
            var yi,xl = x0,xr = x0+0.5*h,xi;
            e1 = event(xr,ymid[i-1]);
            ev = and(lt(e0,0),lt(0,e1));
            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
            if(any(ev)) {
                var xc, yc, en,ei;
                var side=0, sl = 1.0, sr = 1.0;
                while(1) {
                    if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                    else {
                        xi = xr;
                        for(j=e0.length-1;j!==-1;--j) {
                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                        }
                    }
                    if(xi <= xl || xi >= xr) break;
                    yi = ret._at(xi, i-1);
                    ei = event(xi,yi);
                    en = and(lt(e0,0),lt(0,ei));
                    if(any(en)) {
                        xr = xi;
                        e1 = ei;
                        ev = en;
                        sr = 1.0;
                        if(side === -1) sl *= 0.5;
                        else sl = 1.0;
                        side = -1;
                    } else {
                        xl = xi;
                        e0 = ei;
                        sl = 1.0;
                        if(side === 1) sr *= 0.5;
                        else sr = 1.0;
                        side = 1;
                    }
                }
                y1 = ret._at(0.5*(x0+xi),i-1);
                ret.f[i] = f(xi,yi);
                ret.x[i] = xi;
                ret.y[i] = yi;
                ret.ymid[i-1] = y1;
                ret.events = ev;
                ret.iterations = it;
                return ret;
            }
        }
        x0 += h;
        y0 = y1;
        e0 = e1;
        h = min(0.8*h*pow(tol/erinf,0.25),4*h);
    }
    ret.iterations = it;
    return ret;
}

// 11. Ax = b
numeric.LU = function(A, fast) {
  fast = fast || false;

  var abs = Math.abs;
  var i, j, k, absAjk, Akk, Ak, Pk, Ai;
  var max;
  var n = A.length, n1 = n-1;
  var P = new Array(n);
  if(!fast) A = numeric.clone(A);

  for (k = 0; k < n; ++k) {
    Pk = k;
    Ak = A[k];
    max = abs(Ak[k]);
    for (j = k + 1; j < n; ++j) {
      absAjk = abs(A[j][k]);
      if (max < absAjk) {
        max = absAjk;
        Pk = j;
      }
    }
    P[k] = Pk;

    if (Pk != k) {
      A[k] = A[Pk];
      A[Pk] = Ak;
      Ak = A[k];
    }

    Akk = Ak[k];

    for (i = k + 1; i < n; ++i) {
      A[i][k] /= Akk;
    }

    for (i = k + 1; i < n; ++i) {
      Ai = A[i];
      for (j = k + 1; j < n1; ++j) {
        Ai[j] -= Ai[k] * Ak[j];
        ++j;
        Ai[j] -= Ai[k] * Ak[j];
      }
      if(j===n1) Ai[j] -= Ai[k] * Ak[j];
    }
  }

  return {
    LU: A,
    P:  P
  };
}

numeric.LUsolve = function LUsolve(LUP, b) {
  var i, j;
  var LU = LUP.LU;
  var n   = LU.length;
  var x = numeric.clone(b);
  var P   = LUP.P;
  var Pi, LUi, LUii, tmp;

  for (i=n-1;i!==-1;--i) x[i] = b[i];
  for (i = 0; i < n; ++i) {
    Pi = P[i];
    if (P[i] !== i) {
      tmp = x[i];
      x[i] = x[Pi];
      x[Pi] = tmp;
    }

    LUi = LU[i];
    for (j = 0; j < i; ++j) {
      x[i] -= x[j] * LUi[j];
    }
  }

  for (i = n - 1; i >= 0; --i) {
    LUi = LU[i];
    for (j = i + 1; j < n; ++j) {
      x[i] -= x[j] * LUi[j];
    }

    x[i] /= LUi[i];
  }

  return x;
}

numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
numeric.echelonize = function echelonize(A) {
    var s = numeric.dim(A), m = s[0], n = s[1];
    var I = numeric.identity(m);
    var P = Array(m);
    var i,j,k,l,Ai,Ii,Z,a;
    var abs = Math.abs;
    var diveq = numeric.diveq;
    A = numeric.clone(A);
    for(i=0;i<m;++i) {
        k = 0;
        Ai = A[i];
        Ii = I[i];
        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
        P[i] = k;
        diveq(Ii,Ai[k]);
        diveq(Ai,Ai[k]);
        for(j=0;j<m;++j) if(j!==i) {
            Z = A[j]; a = Z[k];
            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
            Z = I[j];
            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
        }
    }
    return {I:I, A:A, P:P};
}

numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var m = c.length, n = b.length,y;
    var unbounded = false, cb,i0=0;
    var alpha = 1.0;
    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
    var muleq = numeric.muleq;
    var norm = numeric.norminf, any = numeric.any,min = Math.min;
    var all = numeric.all, gt = numeric.gt;
    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
    var solve = numeric.solve, z = sub(b,dot(A,x)),count;
    var dotcc = dot(c,c);
    var g;
    for(count=i0;count<maxit;++count) {
        var i,j,d;
        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
        var A1 = transpose(A0);
        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
        alpha = 0.25*abs(dotcc/dot(c,p));
        var a1 = 100*sqrt(dotcc/dot(p,p));
        if(!isFinite(alpha) || alpha>a1) alpha = a1;
        g = add(c,mul(alpha,p));
        H = dot(A1,A0);
        for(i=m-1;i!==-1;--i) H[i][i] += 1;
        d = solve(H,div(g,alpha),true);
        var t0 = div(z,dot(A,d));
        var t = 1.0;
        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
        y = sub(x,mul(d,t));
        z = sub(b,dot(A,y));
        if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
        x = y;
        if(alpha<tol) return { solution: y, message: "", iterations: count };
        if(flag) {
            var s = dot(c,g), Ag = dot(A,g);
            unbounded = true;
            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
        } else {
            if(x[m-1]>=0) unbounded = false;
            else unbounded = true;
        }
        if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
    }
    return { solution: x, message: "maximum iteration count exceeded", iterations:count };
}

numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
    var m = c.length, n = b.length,y;
    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
    var c0 = numeric.rep([m],0).concat([1]);
    var J = numeric.rep([n,1],-1);
    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
    var b0 = b;
    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
    var x = numeric.clone(x0.solution);
    x.length = m;
    var foo = numeric.inf(sub(b,dot(A,x)));
    if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
    ret.iterations += x0.iterations;
    return ret;
};

numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
    if(typeof maxit === "undefined") maxit = 1000;
    if(typeof tol === "undefined") tol = numeric.epsilon;
    if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
    var m = Aeq.length, n = Aeq[0].length, o = A.length;
    var B = numeric.echelonize(Aeq);
    var flags = numeric.rep([n],0);
    var P = B.P;
    var Q = [];
    var i;
    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
    var g = numeric.getRange;
    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
    var A3 = dot(A1,B.I);
    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
    var c1 = Array(P.length), c2 = Array(Q.length);
    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
    var S = numeric._solveLP(c4,A4,b4,tol,maxit);
    var x2 = S.solution;
    if(x2!==x2) return S;
    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
    var x = Array(c.length);
    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
    return { solution: x, message:S.message, iterations: S.iterations };
}

numeric.MPStoLP = function MPStoLP(MPS) {
    if(MPS instanceof String) { MPS.split('\n'); }
    var state = 0;
    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
    var n = MPS.length;
    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
    var name;
    var c = [], A = [], b = [];
    function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
    for(i=0;i<n;++i) {
        z = MPS[i];
        var w0 = z.match(/\S*/g);
        var w = [];
        for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
        if(w.length === 0) continue;
        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
        if(j<states.length) {
            state = j;
            if(j===1) { name = w[1]; }
            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
            continue;
        }
        switch(state) {
        case 0: case 1: err('Unexpected line');
        case 2: 
            switch(w[0]) {
            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
            default: err('Parse error '+numeric.prettyPrint(w));
            }
            break;
        case 3:
            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
            var p = vars[w[0]];
            for(j=1;j<w.length;j+=2) {
                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                var q = rows[w[j]];
                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
            }
            break;
        case 4:
            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
            break;
        case 5: /*FIXME*/ break;
        case 6: err('Internal error');
        }
    }
    err('Reached end of file without ENDATA');
}
// seedrandom.js version 2.0.
// Author: David Bau 4/2/2011
//
// Defines a method Math.seedrandom() that, when called, substitutes
// an explicitly seeded RC4-based algorithm for Math.random().  Also
// supports automatic seeding from local or network sources of entropy.
//
// Usage:
//
//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
//
//   Math.seedrandom('yipee'); Sets Math.random to a function that is
//                             initialized using the given explicit seed.
//
//   Math.seedrandom();        Sets Math.random to a function that is
//                             seeded using the current time, dom state,
//                             and other accumulated local entropy.
//                             The generated seed string is returned.
//
//   Math.seedrandom('yowza', true);
//                             Seeds using the given explicit seed mixed
//                             together with accumulated entropy.
//
//   <script src="http://bit.ly/srandom-512"></script>
//                             Seeds using physical random bits downloaded
//                             from random.org.
//
//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
//   </script>                 Seeds using urandom bits from call.jsonlib.com,
//                             which is faster than random.org.
//
// Examples:
//
//   Math.seedrandom("hello");            // Use "hello" as the seed.
//   document.write(Math.random());       // Always 0.5463663768140734
//   document.write(Math.random());       // Always 0.43973793770592234
//   var rng1 = Math.random;              // Remember the current prng.
//
//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
//   document.write(Math.random());       // Pretty much unpredictable.
//
//   Math.random = rng1;                  // Continue "hello" prng sequence.
//   document.write(Math.random());       // Always 0.554769432473455
//
//   Math.seedrandom(autoseed);           // Restart at the previous seed.
//   document.write(Math.random());       // Repeat the 'unpredictable' value.
//
// Notes:
//
// Each time seedrandom('arg') is called, entropy from the passed seed
// is accumulated in a pool to help generate future seeds for the
// zero-argument form of Math.seedrandom, so entropy can be injected over
// time by calling seedrandom with explicit data repeatedly.
//
// On speed - This javascript implementation of Math.random() is about
// 3-10x slower than the built-in Math.random() because it is not native
// code, but this is typically fast enough anyway.  Seeding is more expensive,
// especially if you use auto-seeding.  Some details (timings on Chrome 4):
//
// Our Math.random()            - avg less than 0.002 milliseconds per call
// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
// seedrandom('explicit', true) - avg less than 2 milliseconds per call
// seedrandom()                 - avg about 38 milliseconds per call
//
// LICENSE (BSD):
//
// Copyright 2010 David Bau, all rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
// 
//   3. Neither the name of this module nor the names of its contributors may
//      be used to endorse or promote products derived from this software
//      without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
/**
 * All code is in an anonymous closure to keep the global namespace clean.
 *
 * @param {number=} overflow 
 * @param {number=} startdenom
 */

// Patched by Seb so that seedrandom.js does not pollute the Math object.
// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%
// slower.
numeric.seedrandom = { pow:Math.pow, random:Math.random };

(function (pool, math, width, chunks, significance, overflow, startdenom) {


//
// seedrandom()
// This is the seedrandom function described above.
//
math['seedrandom'] = function seedrandom(seed, use_entropy) {
  var key = [];
  var arc4;

  // Flatten the seed string or build one from local entropy if needed.
  seed = mixkey(flatten(
    use_entropy ? [seed, pool] :
    arguments.length ? seed :
    [new Date().getTime(), pool, window], 3), key);

  // Use the seed to initialize an ARC4 generator.
  arc4 = new ARC4(key);

  // Mix the randomness into accumulated entropy.
  mixkey(arc4.S, pool);

  // Override Math.random

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.

  math['random'] = function random() {  // Closure to return a random double:
    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
    var d = startdenom;                 //   and denominator d = 2 ^ 48.
    var x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  // Return the seed that was used
  return seed;
};

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
/** @constructor */
function ARC4(key) {
  var t, u, me = this, keylen = key.length;
  var i = 0, j = me.i = me.j = me.m = 0;
  me.S = [];
  me.c = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) { me.S[i] = i++; }
  for (i = 0; i < width; i++) {
    t = me.S[i];
    j = lowbits(j + t + key[i % keylen]);
    u = me.S[j];
    me.S[i] = u;
    me.S[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  me.g = function getnext(count) {
    var s = me.S;
    var i = lowbits(me.i + 1); var t = s[i];
    var j = lowbits(me.j + t); var u = s[j];
    s[i] = u;
    s[j] = t;
    var r = s[lowbits(t + u)];
    while (--count) {
      i = lowbits(i + 1); t = s[i];
      j = lowbits(j + t); u = s[j];
      s[i] = u;
      s[j] = t;
      r = r * width + s[lowbits(t + u)];
    }
    me.i = i;
    me.j = j;
    return r;
  };
  // For robust unpredictability discard an initial batch of values.
  // See http://www.rsa.com/rsalabs/node.asp?id=2009
  me.g(width);
}

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
/** @param {Object=} result 
  * @param {string=} prop
  * @param {string=} typ */
function flatten(obj, depth, result, prop, typ) {
  result = [];
  typ = typeof(obj);
  if (depth && typ == 'object') {
    for (prop in obj) {
      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
      }
    }
  }
  return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
/** @param {number=} smear 
  * @param {number=} j */
function mixkey(seed, key, smear, j) {
  seed += '';                         // Ensure the seed is a string
  smear = 0;
  for (j = 0; j < seed.length; j++) {
    key[lowbits(j)] =
      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
  }
  seed = '';
  for (j in key) { seed += String.fromCharCode(key[j]); }
  return seed;
}

//
// lowbits()
// A quick "n mod width" for width a power of 2.
//
function lowbits(n) { return n & (width - 1); }

//
// The following constants are related to IEEE 754 limits.
//
startdenom = math.pow(width, chunks);
significance = math.pow(2, significance);
overflow = significance * 2;

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

// End anonymous scope, and pass initial values.
}(
  [],   // pool: entropy pool starts empty
  numeric.seedrandom, // math: package containing random, pow, and seedrandom
  256,  // width: each RC4 output is 0 <= x < 256
  6,    // chunks: at least six RC4 outputs for each double
  52    // significance: there are 52 significant digits in a double
  ));
/* This file is a slightly modified version of quadprog.js from Alberto Santini.
 * It has been slightly modified by Sébastien Loisel to make sure that it handles
 * 0-based Arrays instead of 1-based Arrays.
 * License is in resources/LICENSE.quadprog */
(function(exports) {

function base0to1(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=0;i<n;i++) ret[i+1] = base0to1(A[i]);
    return ret;
}
function base1to0(A) {
    if(typeof A !== "object") { return A; }
    var ret = [], i,n=A.length;
    for(i=1;i<n;i++) ret[i-1] = base1to0(A[i]);
    return ret;
}

function dpori(a, lda, n) {
    var i, j, k, kp1, t;

    for (k = 1; k <= n; k = k + 1) {
        a[k][k] = 1 / a[k][k];
        t = -a[k][k];
        //~ dscal(k - 1, t, a[1][k], 1);
        for (i = 1; i < k; i = i + 1) {
            a[i][k] = t * a[i][k];
        }

        kp1 = k + 1;
        if (n < kp1) {
            break;
        }
        for (j = kp1; j <= n; j = j + 1) {
            t = a[k][j];
            a[k][j] = 0;
            //~ daxpy(k, t, a[1][k], 1, a[1][j], 1);
            for (i = 1; i <= k; i = i + 1) {
                a[i][j] = a[i][j] + (t * a[i][k]);
            }
        }
    }

}

function dposl(a, lda, n, b) {
    var i, k, kb, t;

    for (k = 1; k <= n; k = k + 1) {
        //~ t = ddot(k - 1, a[1][k], 1, b[1], 1);
        t = 0;
        for (i = 1; i < k; i = i + 1) {
            t = t + (a[i][k] * b[i]);
        }

        b[k] = (b[k] - t) / a[k][k];
    }

    for (kb = 1; kb <= n; kb = kb + 1) {
        k = n + 1 - kb;
        b[k] = b[k] / a[k][k];
        t = -b[k];
        //~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);
        for (i = 1; i < k; i = i + 1) {
            b[i] = b[i] + (t * a[i][k]);
        }
    }
}

function dpofa(a, lda, n, info) {
    var i, j, jm1, k, t, s;

    for (j = 1; j <= n; j = j + 1) {
        info[1] = j;
        s = 0;
        jm1 = j - 1;
        if (jm1 < 1) {
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        } else {
            for (k = 1; k <= jm1; k = k + 1) {
                //~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);
                t = a[k][j];
                for (i = 1; i < k; i = i + 1) {
                    t = t - (a[i][j] * a[i][k]);
                }
                t = t / a[k][k];
                a[k][j] = t;
                s = s + t * t;
            }
            s = a[j][j] - s;
            if (s <= 0) {
                break;
            }
            a[j][j] = Math.sqrt(s);
        }
        info[1] = 0;
    }
}

function qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,
    bvec, fdamat, q, meq, iact, nact, iter, work, ierr) {

    var i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,
        temp, sum, t1, tt, gc, gs, nu,
        t1inf, t2min,
        vsmall, tmpa, tmpb,
        go;

    r = Math.min(n, q);
    l = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;

    vsmall = 1.0e-60;
    do {
        vsmall = vsmall + vsmall;
        tmpa = 1 + 0.1 * vsmall;
        tmpb = 1 + 0.2 * vsmall;
    } while (tmpa <= 1 || tmpb <= 1);

    for (i = 1; i <= n; i = i + 1) {
        work[i] = dvec[i];
    }
    for (i = n + 1; i <= l; i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }

    info = [];

    if (ierr[1] === 0) {
        dpofa(dmat, fddmat, n, info);
        if (info[1] !== 0) {
            ierr[1] = 2;
            return;
        }
        dposl(dmat, fddmat, n, dvec);
        dpori(dmat, fddmat, n);
    } else {
        for (j = 1; j <= n; j = j + 1) {
            sol[j] = 0;
            for (i = 1; i <= j; i = i + 1) {
                sol[j] = sol[j] + dmat[i][j] * dvec[i];
            }
        }
        for (j = 1; j <= n; j = j + 1) {
            dvec[j] = 0;
            for (i = j; i <= n; i = i + 1) {
                dvec[j] = dvec[j] + dmat[j][i] * sol[i];
            }
        }
    }

    crval[1] = 0;
    for (j = 1; j <= n; j = j + 1) {
        sol[j] = dvec[j];
        crval[1] = crval[1] + work[j] * sol[j];
        work[j] = 0;
        for (i = j + 1; i <= n; i = i + 1) {
            dmat[i][j] = 0;
        }
    }
    crval[1] = -crval[1] / 2;
    ierr[1] = 0;

    iwzv = n;
    iwrv = iwzv + n;
    iwuv = iwrv + r;
    iwrm = iwuv + r + 1;
    iwsv = iwrm + (r * (r + 1)) / 2;
    iwnbv = iwsv + q;

    for (i = 1; i <= q; i = i + 1) {
        sum = 0;
        for (j = 1; j <= n; j = j + 1) {
            sum = sum + amat[j][i] * amat[j][i];
        }
        work[iwnbv + i] = Math.sqrt(sum);
    }
    nact = 0;
    iter[1] = 0;
    iter[2] = 0;

    function fn_goto_50() {
        iter[1] = iter[1] + 1;

        l = iwsv;
        for (i = 1; i <= q; i = i + 1) {
            l = l + 1;
            sum = -bvec[i];
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + amat[j][i] * sol[j];
            }
            if (Math.abs(sum) < vsmall) {
                sum = 0;
            }
            if (i > meq) {
                work[l] = sum;
            } else {
                work[l] = -Math.abs(sum);
                if (sum > 0) {
                    for (j = 1; j <= n; j = j + 1) {
                        amat[j][i] = -amat[j][i];
                    }
                    bvec[i] = -bvec[i];
                }
            }
        }

        for (i = 1; i <= nact; i = i + 1) {
            work[iwsv + iact[i]] = 0;
        }

        nvl = 0;
        temp = 0;
        for (i = 1; i <= q; i = i + 1) {
            if (work[iwsv + i] < temp * work[iwnbv + i]) {
                nvl = i;
                temp = work[iwsv + i] / work[iwnbv + i];
            }
        }
        if (nvl === 0) {
            return 999;
        }

        return 0;
    }

    function fn_goto_55() {
        for (i = 1; i <= n; i = i + 1) {
            sum = 0;
            for (j = 1; j <= n; j = j + 1) {
                sum = sum + dmat[j][i] * amat[j][nvl];
            }
            work[i] = sum;
        }

        l1 = iwzv;
        for (i = 1; i <= n; i = i + 1) {
            work[l1 + i] = 0;
        }
        for (j = nact + 1; j <= n; j = j + 1) {
            for (i = 1; i <= n; i = i + 1) {
                work[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];
            }
        }

        t1inf = true;
        for (i = nact; i >= 1; i = i - 1) {
            sum = work[i];
            l = iwrm + (i * (i + 3)) / 2;
            l1 = l - i;
            for (j = i + 1; j <= nact; j = j + 1) {
                sum = sum - work[l] * work[iwrv + j];
                l = l + j;
            }
            sum = sum / work[l1];
            work[iwrv + i] = sum;
            if (iact[i] < meq) {
                // continue;
                break;
            }
            if (sum < 0) {
                // continue;
                break;
            }
            t1inf = false;
            it1 = i;
        }

        if (!t1inf) {
            t1 = work[iwuv + it1] / work[iwrv + it1];
            for (i = 1; i <= nact; i = i + 1) {
                if (iact[i] < meq) {
                    // continue;
                    break;
                }
                if (work[iwrv + i] < 0) {
                    // continue;
                    break;
                }
                temp = work[iwuv + i] / work[iwrv + i];
                if (temp < t1) {
                    t1 = temp;
                    it1 = i;
                }
            }
        }

        sum = 0;
        for (i = iwzv + 1; i <= iwzv + n; i = i + 1) {
            sum = sum + work[i] * work[i];
        }
        if (Math.abs(sum) <= vsmall) {
            if (t1inf) {
                ierr[1] = 1;
                // GOTO 999
                return 999;
            } else {
                for (i = 1; i <= nact; i = i + 1) {
                    work[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];
                }
                work[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;
                // GOTO 700
                return 700;
            }
        } else {
            sum = 0;
            for (i = 1; i <= n; i = i + 1) {
                sum = sum + work[iwzv + i] * amat[i][nvl];
            }
            tt = -work[iwsv + nvl] / sum;
            t2min = true;
            if (!t1inf) {
                if (t1 < tt) {
                    tt = t1;
                    t2min = false;
                }
            }

            for (i = 1; i <= n; i = i + 1) {
                sol[i] = sol[i] + tt * work[iwzv + i];
                if (Math.abs(sol[i]) < vsmall) {
                    sol[i] = 0;
                }
            }

            crval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);
            for (i = 1; i <= nact; i = i + 1) {
                work[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];
            }
            work[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;

            if (t2min) {
                nact = nact + 1;
                iact[nact] = nvl;

                l = iwrm + ((nact - 1) * nact) / 2 + 1;
                for (i = 1; i <= nact - 1; i = i + 1) {
                    work[l] = work[i];
                    l = l + 1;
                }

                if (nact === n) {
                    work[l] = work[n];
                } else {
                    for (i = n; i >= nact + 1; i = i - 1) {
                        if (work[i] === 0) {
                            // continue;
                            break;
                        }
                        gc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));
                        gs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));
                        if (work[i - 1] >= 0) {
                            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        } else {
                            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                        }
                        gc = work[i - 1] / temp;
                        gs = work[i] / temp;

                        if (gc === 1) {
                            // continue;
                            break;
                        }
                        if (gc === 0) {
                            work[i - 1] = gs * temp;
                            for (j = 1; j <= n; j = j + 1) {
                                temp = dmat[j][i - 1];
                                dmat[j][i - 1] = dmat[j][i];
                                dmat[j][i] = temp;
                            }
                        } else {
                            work[i - 1] = temp;
                            nu = gs / (1 + gc);
                            for (j = 1; j <= n; j = j + 1) {
                                temp = gc * dmat[j][i - 1] + gs * dmat[j][i];
                                dmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];
                                dmat[j][i - 1] = temp;

                            }
                        }
                    }
                    work[l] = work[nact];
                }
            } else {
                sum = -bvec[nvl];
                for (j = 1; j <= n; j = j + 1) {
                    sum = sum + sol[j] * amat[j][nvl];
                }
                if (nvl > meq) {
                    work[iwsv + nvl] = sum;
                } else {
                    work[iwsv + nvl] = -Math.abs(sum);
                    if (sum > 0) {
                        for (j = 1; j <= n; j = j + 1) {
                            amat[j][nvl] = -amat[j][nvl];
                        }
                        bvec[nvl] = -bvec[nvl];
                    }
                }
                // GOTO 700
                return 700;
            }
        }

        return 0;
    }

    function fn_goto_797() {
        l = iwrm + (it1 * (it1 + 1)) / 2 + 1;
        l1 = l + it1;
        if (work[l1] === 0) {
            // GOTO 798
            return 798;
        }
        gc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        gs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
        if (work[l1 - 1] >= 0) {
            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        } else {
            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
        }
        gc = work[l1 - 1] / temp;
        gs = work[l1] / temp;

        if (gc === 1) {
            // GOTO 798
            return 798;
        }
        if (gc === 0) {
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = work[l1 - 1];
                work[l1 - 1] = work[l1];
                work[l1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = dmat[i][it1];
                dmat[i][it1] = dmat[i][it1 + 1];
                dmat[i][it1 + 1] = temp;
            }
        } else {
            nu = gs / (1 + gc);
            for (i = it1 + 1; i <= nact; i = i + 1) {
                temp = gc * work[l1 - 1] + gs * work[l1];
                work[l1] = nu * (work[l1 - 1] + temp) - work[l1];
                work[l1 - 1] = temp;
                l1 = l1 + i;
            }
            for (i = 1; i <= n; i = i + 1) {
                temp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];
                dmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];
                dmat[i][it1] = temp;
            }
        }

        return 0;
    }

    function fn_goto_798() {
        l1 = l - it1;
        for (i = 1; i <= it1; i = i + 1) {
            work[l1] = work[l];
            l = l + 1;
            l1 = l1 + 1;
        }

        work[iwuv + it1] = work[iwuv + it1 + 1];
        iact[it1] = iact[it1 + 1];
        it1 = it1 + 1;
        if (it1 < nact) {
            // GOTO 797
            return 797;
        }

        return 0;
    }

    function fn_goto_799() {
        work[iwuv + nact] = work[iwuv + nact + 1];
        work[iwuv + nact + 1] = 0;
        iact[nact] = 0;
        nact = nact - 1;
        iter[2] = iter[2] + 1;

        return 0;
    }

    go = 0;
    while (true) {
        go = fn_goto_50();
        if (go === 999) {
            return;
        }
        while (true) {
            go = fn_goto_55();
            if (go === 0) {
                break;
            }
            if (go === 999) {
                return;
            }
            if (go === 700) {
                if (it1 === nact) {
                    fn_goto_799();
                } else {
                    while (true) {
                        fn_goto_797();
                        go = fn_goto_798();
                        if (go !== 797) {
                            break;
                        }
                    }
                    fn_goto_799();
                }
            }
        }
    }

}

function solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {
    Dmat = base0to1(Dmat);
    dvec = base0to1(dvec);
    Amat = base0to1(Amat);
    var i, n, q,
        nact, r,
        crval = [], iact = [], sol = [], work = [], iter = [],
        message;

    meq = meq || 0;
    factorized = factorized ? base0to1(factorized) : [undefined, 0];
    bvec = bvec ? base0to1(bvec) : [];

    // In Fortran the array index starts from 1
    n = Dmat.length - 1;
    q = Amat[1].length - 1;

    if (!bvec) {
        for (i = 1; i <= q; i = i + 1) {
            bvec[i] = 0;
        }
    }
    for (i = 1; i <= q; i = i + 1) {
        iact[i] = 0;
    }
    nact = 0;
    r = Math.min(n, q);
    for (i = 1; i <= n; i = i + 1) {
        sol[i] = 0;
    }
    crval[1] = 0;
    for (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {
        work[i] = 0;
    }
    for (i = 1; i <= 2; i = i + 1) {
        iter[i] = 0;
    }

    qpgen2(Dmat, dvec, n, n, sol, crval, Amat,
        bvec, n, q, meq, iact, nact, iter, work, factorized);

    message = "";
    if (factorized[1] === 1) {
        message = "constraints are inconsistent, no solution!";
    }
    if (factorized[1] === 2) {
        message = "matrix D in quadratic function is not positive definite!";
    }

    return {
        solution: base1to0(sol),
        value: base1to0(crval),
        unconstrained_solution: base1to0(dvec),
        iterations: base1to0(iter),
        iact: base1to0(iact),
        message: message
    };
}
exports.solveQP = solveQP;
}(numeric));
/*
Shanti Rao sent me this routine by private email. I had to modify it
slightly to work on Arrays instead of using a Matrix object.
It is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py
*/

numeric.svd= function svd(A) {
    var temp;
//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
	var prec= numeric.epsilon; //Math.pow(2,-52) // assumes double prec
	var tolerance= 1.e-64/prec;
	var itmax= 50;
	var c=0;
	var i=0;
	var j=0;
	var k=0;
	var l=0;
	
	var u= numeric.clone(A);
	var m= u.length;
	
	var n= u[0].length;
	
	if (m < n) throw "Need more rows than columns"
	
	var e = new Array(n);
	var q = new Array(n);
	for (i=0; i<n; i++) e[i] = q[i] = 0.0;
	var v = numeric.rep([n,n],0);
//	v.zero();
	
 	function pythag(a,b)
 	{
		a = Math.abs(a)
		b = Math.abs(b)
		if (a > b)
			return a*Math.sqrt(1.0+(b*b/a/a))
		else if (b == 0.0) 
			return a
		return b*Math.sqrt(1.0+(a*a/b/b))
	}

	//Householder's reduction to bidiagonal form

	var f= 0.0;
	var g= 0.0;
	var h= 0.0;
	var x= 0.0;
	var y= 0.0;
	var z= 0.0;
	var s= 0.0;
	
	for (i=0; i < n; i++)
	{	
		e[i]= g;
		s= 0.0;
		l= i+1;
		for (j=i; j < m; j++) 
			s += (u[j][i]*u[j][i]);
		if (s <= tolerance)
			g= 0.0;
		else
		{	
			f= u[i][i];
			g= Math.sqrt(s);
			if (f >= 0.0) g= -g;
			h= f*g-s
			u[i][i]=f-g;
			for (j=l; j < n; j++)
			{
				s= 0.0
				for (k=i; k < m; k++) 
					s += u[k][i]*u[k][j]
				f= s/h
				for (k=i; k < m; k++) 
					u[k][j]+=f*u[k][i]
			}
		}
		q[i]= g
		s= 0.0
		for (j=l; j < n; j++) 
			s= s + u[i][j]*u[i][j]
		if (s <= tolerance)
			g= 0.0
		else
		{	
			f= u[i][i+1]
			g= Math.sqrt(s)
			if (f >= 0.0) g= -g
			h= f*g - s
			u[i][i+1] = f-g;
			for (j=l; j < n; j++) e[j]= u[i][j]/h
			for (j=l; j < m; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += (u[j][k]*u[i][k])
				for (k=l; k < n; k++) 
					u[j][k]+=s*e[k]
			}	
		}
		y= Math.abs(q[i])+Math.abs(e[i])
		if (y>x) 
			x=y
	}
	
	// accumulation of right hand gtransformations
	for (i=n-1; i != -1; i+= -1)
	{	
		if (g != 0.0)
		{
		 	h= g*u[i][i+1]
			for (j=l; j < n; j++) 
				v[j][i]=u[i][j]/h
			for (j=l; j < n; j++)
			{	
				s=0.0
				for (k=l; k < n; k++) 
					s += u[i][k]*v[k][j]
				for (k=l; k < n; k++) 
					v[k][j]+=(s*v[k][i])
			}	
		}
		for (j=l; j < n; j++)
		{
			v[i][j] = 0;
			v[j][i] = 0;
		}
		v[i][i] = 1;
		g= e[i]
		l= i
	}
	
	// accumulation of left hand transformations
	for (i=n-1; i != -1; i+= -1)
	{	
		l= i+1
		g= q[i]
		for (j=l; j < n; j++) 
			u[i][j] = 0;
		if (g != 0.0)
		{
			h= u[i][i]*g
			for (j=l; j < n; j++)
			{
				s=0.0
				for (k=l; k < m; k++) s += u[k][i]*u[k][j];
				f= s/h
				for (k=i; k < m; k++) u[k][j]+=f*u[k][i];
			}
			for (j=i; j < m; j++) u[j][i] = u[j][i]/g;
		}
		else
			for (j=i; j < m; j++) u[j][i] = 0;
		u[i][i] += 1;
	}
	
	// diagonalization of the bidiagonal form
	prec= prec*x
	for (k=n-1; k != -1; k+= -1)
	{
		for (var iteration=0; iteration < itmax; iteration++)
		{	// test f splitting
			var test_convergence = false
			for (l=k; l != -1; l+= -1)
			{	
				if (Math.abs(e[l]) <= prec)
				{	test_convergence= true
					break 
				}
				if (Math.abs(q[l-1]) <= prec)
					break 
			}
			if (!test_convergence)
			{	// cancellation of e[l] if l>0
				c= 0.0
				s= 1.0
				var l1= l-1
				for (i =l; i<k+1; i++)
				{	
					f= s*e[i]
					e[i]= c*e[i]
					if (Math.abs(f) <= prec)
						break
					g= q[i]
					h= pythag(f,g)
					q[i]= h
					c= g/h
					s= -f/h
					for (j=0; j < m; j++)
					{	
						y= u[j][l1]
						z= u[j][i]
						u[j][l1] =  y*c+(z*s)
						u[j][i] = -y*s+(z*c)
					} 
				}	
			}
			// test f convergence
			z= q[k]
			if (l== k)
			{	//convergence
				if (z<0.0)
				{	//q[k] is made non-negative
					q[k]= -z
					for (j=0; j < n; j++)
						v[j][k] = -v[j][k]
				}
				break  //break out of iteration loop and move on to next k value
			}
			if (iteration >= itmax-1)
				throw 'Error: no convergence.'
			// shift from bottom 2x2 minor
			x= q[l]
			y= q[k-1]
			g= e[k-1]
			h= e[k]
			f= ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)
			g= pythag(f,1.0)
			if (f < 0.0)
				f= ((x-z)*(x+z)+h*(y/(f-g)-h))/x
			else
				f= ((x-z)*(x+z)+h*(y/(f+g)-h))/x
			// next QR transformation
			c= 1.0
			s= 1.0
			for (i=l+1; i< k+1; i++)
			{	
				g= e[i]
				y= q[i]
				h= s*g
				g= c*g
				z= pythag(f,h)
				e[i-1]= z
				c= f/z
				s= h/z
				f= x*c+g*s
				g= -x*s+g*c
				h= y*s
				y= y*c
				for (j=0; j < n; j++)
				{	
					x= v[j][i-1]
					z= v[j][i]
					v[j][i-1] = x*c+z*s
					v[j][i] = -x*s+z*c
				}
				z= pythag(f,h)
				q[i-1]= z
				c= f/z
				s= h/z
				f= c*g+s*y
				x= -s*g+c*y
				for (j=0; j < m; j++)
				{
					y= u[j][i-1]
					z= u[j][i]
					u[j][i-1] = y*c+z*s
					u[j][i] = -y*s+z*c
				}
			}
			e[l]= 0.0
			e[k]= f
			q[k]= x
		} 
	}
		
	//vt= transpose(v)
	//return (u,q,vt)
	for (i=0;i<q.length; i++) 
	  if (q[i] < prec) q[i] = 0
	  
	//sort eigenvalues	
	for (i=0; i< n; i++)
	{	 
	//writeln(q)
	 for (j=i-1; j >= 0; j--)
	 {
	  if (q[j] < q[i])
	  {
	//  writeln(i,'-',j)
	   c = q[j]
	   q[j] = q[i]
	   q[i] = c
	   for(k=0;k<u.length;k++) { temp = u[k][i]; u[k][i] = u[k][j]; u[k][j] = temp; }
	   for(k=0;k<v.length;k++) { temp = v[k][i]; v[k][i] = v[k][j]; v[k][j] = temp; }
//	   u.swapCols(i,j)
//	   v.swapCols(i,j)
	   i = j	   
	  }
	 }	
	}
	
	return {U:u,S:q,V:v}
};


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/style-loader/addStyles.js":
/*!************************************************!*\
  !*** ./node_modules/style-loader/addStyles.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
	}),
	getHeadElement = memoize(function () {
		return document.head || document.getElementsByTagName("head")[0];
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [];

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the bottom of <head>.
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
}

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var head = getHeadElement();
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			head.insertBefore(styleElement, head.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			head.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		head.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	styleElement.type = "text/css";
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	linkElement.rel = "stylesheet";
	insertStyleElement(options, linkElement);
	return linkElement;
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./web/app/brep/geom/curves/nurbsCurve.js":
/*!************************************************!*\
  !*** ./web/app/brep/geom/curves/nurbsCurve.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NurbsCurve; });
/* harmony import */ var _impl_nurbs_ext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../impl/nurbs-ext */ "./web/app/brep/geom/impl/nurbs-ext.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var NurbsCurve =
/*#__PURE__*/
function () {
  _createClass(NurbsCurve, null, [{
    key: "create",
    value: function create(degree, knots, cp, weights) {
      return new NurbsCurve(verb.geom.NurbsCurve.byKnotsControlPointsWeights(degree, knots, cp, weights));
    }
  }, {
    key: "deserialize",
    value: function deserialize(_ref) {
      var degree = _ref.degree,
          knots = _ref.knots,
          cp = _ref.cp,
          weights = _ref.weights;
      return NurbsCurve.create(degree, knots, cp, weights);
    }
  }]);

  function NurbsCurve(verbCurve) {
    _classCallCheck(this, NurbsCurve);

    this.verb = verbCurve;
    this.data = verbCurve.asNurbs();
  }

  _createClass(NurbsCurve, [{
    key: "domain",
    value: function domain() {
      return _impl_nurbs_ext__WEBPACK_IMPORTED_MODULE_0__["curveDomain"](this.data);
    }
  }, {
    key: "degree",
    value: function degree() {
      return this.data.degree;
    }
  }, {
    key: "transform",
    value: function transform(tr) {
      return new NurbsCurve(this.verb.transform(tr));
    }
  }, {
    key: "point",
    value: function point(u) {
      return this.verb.point(u);
    }
  }, {
    key: "param",
    value: function param(point) {
      return this.verb.closestParam(point);
    }
  }, {
    key: "eval",
    value: function _eval(u, num) {
      return verb.eval.Eval.rationalCurveDerivatives(this.data, u, num);
    }
  }, {
    key: "knots",
    value: function knots() {
      return Object(_impl_nurbs_ext__WEBPACK_IMPORTED_MODULE_0__["distinctKnots"])(this.data.knots);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = _impl_nurbs_ext__WEBPACK_IMPORTED_MODULE_0__["curveInvert"](this.data);
      _impl_nurbs_ext__WEBPACK_IMPORTED_MODULE_0__["normalizeCurveParametrizationIfNeeded"](inverted); // let [min, max] = curveDomain(curve);
      // for (let i = 0; i < reversed.knots.length; i++) {
      //   if (eqEps(reversed.knots[i], max)) {
      //     reversed.knots[i] = max;
      //   } else {
      //     break;
      //   }
      // }
      // for (let i = reversed.knots.length - 1; i >= 0 ; i--) {
      //   if (eqEps(reversed.knots[i], min)) {
      //     reversed.knots[i] = min;
      //   } else {
      //     break;
      //   }
      // }

      return new NurbsCurve(new verb.geom.NurbsCurve(inverted));
    }
  }, {
    key: "split",
    value: function split(u) {
      var split = verb.eval.Divide.curveSplit(this.data, u);
      split.forEach(function (n) {
        return _impl_nurbs_ext__WEBPACK_IMPORTED_MODULE_0__["normalizeCurveParametrization"](n);
      });
      return split.map(function (c) {
        return new NurbsCurve(new verb.geom.NurbsCurve(c));
      });
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return {
        degree: this.verb.degree(),
        knots: this.verb.knots(),
        cp: this.verb.controlPoints(),
        weights: this.verb.weights()
      };
    }
  }]);

  return NurbsCurve;
}();



/***/ }),

/***/ "./web/app/brep/geom/impl/nurbs-ext.js":
/*!*********************************************!*\
  !*** ./web/app/brep/geom/impl/nurbs-ext.js ***!
  \*********************************************/
/*! exports provided: curveStep, curveDomain, distinctKnots, curveTessellate, curveRefineTessellation, curvePoint, curveClosestParam, surfaceClosestParam, surfaceIntersect, meshesIntersect, surfaceMaxDegree, curveIntersect, normalizeCurveEnds, normalizeCurveParametrization, normalizeCurveParametrizationIfNeeded, curveInvert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curveStep", function() { return curveStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curveDomain", function() { return curveDomain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distinctKnots", function() { return distinctKnots; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curveTessellate", function() { return curveTessellate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curveRefineTessellation", function() { return curveRefineTessellation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curvePoint", function() { return curvePoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curveClosestParam", function() { return curveClosestParam; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "surfaceClosestParam", function() { return surfaceClosestParam; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "surfaceIntersect", function() { return surfaceIntersect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "meshesIntersect", function() { return meshesIntersect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "surfaceMaxDegree", function() { return surfaceMaxDegree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curveIntersect", function() { return curveIntersect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeCurveEnds", function() { return normalizeCurveEnds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeCurveParametrization", function() { return normalizeCurveParametrization; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeCurveParametrizationIfNeeded", function() { return normalizeCurveParametrizationIfNeeded; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curveInvert", function() { return curveInvert; });
/* harmony import */ var _math_vec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../math/vec */ "./web/app/math/vec.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../math/math */ "./web/app/math/math.js");
/* harmony import */ var _tolerance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tolerance */ "./web/app/brep/geom/tolerance.js");
/* harmony import */ var _math_optim__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../math/optim */ "./web/app/math/optim.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }





function curveStep(curve, u, tessTol, scale) {
  tessTol = tessTol || 1;
  scale = scale || 1;
  var ders = verb.eval.Eval.rationalCurveDerivatives(curve, u, 2);
  var r1 = ders[1];
  var r2 = ders[2];
  var r1lsq = _math_vec__WEBPACK_IMPORTED_MODULE_0__["lengthSq"](r1);
  var r1l = Math.sqrt(r1lsq);
  var r = r1lsq * r1l / _math_vec__WEBPACK_IMPORTED_MODULE_0__["length"](_math_vec__WEBPACK_IMPORTED_MODULE_0__["cross"](r1, r2));
  var tol = tessTol / scale;
  var step = 2 * Math.sqrt(tol * (2 * r - tol)) / r1l;
  return step;
}
function curveDomain(curve) {
  return [curve.knots[0], curve.knots[curve.knots.length - 1]];
}
function distinctKnots(knots) {
  var out = [knots[0]];

  for (var i = 1; i < knots.length; ++i) {
    if (out[out.length - 1] !== knots[i]) {
      out.push(knots[i]);
    }
  }

  return out;
}
function curveTessellate(curve, min, max, tessTol, scale) {
  if (curve.degree === 1) {
    return distinctKnots(curve.knots);
  }

  var domain = curveDomain(curve);

  var _domain = _slicedToArray(domain, 2),
      dmin = _domain[0],
      dmax = _domain[1];

  var nSplits = curve.knots.length - 1;
  var splitStep = (dmax - dmin) / nSplits;
  nSplits = Math.round((max - min) / splitStep);
  splitStep = (max - min) / nSplits;
  var splits = [min];

  for (var i = 1; i < nSplits; ++i) {
    splits.push(min + i * splitStep);
  }

  splits.push(max);
  return curveRefineTessellation(curve, splits, tessTol, scale);
}
function curveRefineTessellation(curve, tess, tessTol, scale) {
  var out = [];

  function refine(u1, u2, step) {
    if (step < u2 - u1) {
      var mid = u1 + (u2 - u1) * 0.5;
      refine(u1, mid, step);
      out.push(mid);
      refine(mid, u2, curveStep(curve, mid, tessTol, scale));
    }
  }

  for (var i = 1; i < tess.length; ++i) {
    var u1 = tess[i - 1];
    out.push(u1);
    refine(u1, tess[i], curveStep(curve, u1, tessTol, scale));
  }

  out.push(tess[tess.length - 1]);
  return out;
}
function curvePoint(curve, u) {
  return verb.eval.Eval.rationalCurvePoint(curve, u);
}
function curveClosestParam(curve, point) {
  return verb.eval.Analyze.rationalCurveClosestParam(curve, point);
}
var surfaceClosestParam = verb.eval.Analyze.rationalSurfaceClosestParam;
function surfaceIntersect(surface0, surface1) {
  var tess0 = verb.eval.Tess.rationalSurfaceAdaptive(surface0);
  var tess1 = verb.eval.Tess.rationalSurfaceAdaptive(surface1);

  function fixTessNaNPoitns(s, tess) {
    for (var i = 0; i < tess.points.length; i++) {
      var pt = tess.points[i];

      if (Number.isNaN(pt[0]) || Number.isNaN(pt[1]) || Number.isNaN(pt[2])) {
        var _tess$uvs$i = _slicedToArray(tess.uvs[i], 2),
            u = _tess$uvs$i[0],
            v = _tess$uvs$i[1];

        tess.points[i] = verb.eval.Eval.rationalSurfacePoint(s, u, v);
      }
    }
  }

  fixTessNaNPoitns(surface0, tess0);
  fixTessNaNPoitns(surface1, tess1);
  var resApprox = meshesIntersect(tess0, tess1, _tolerance__WEBPACK_IMPORTED_MODULE_2__["TOLERANCE"], _tolerance__WEBPACK_IMPORTED_MODULE_2__["TOLERANCE_SQ"], _tolerance__WEBPACK_IMPORTED_MODULE_2__["TOLERANCE_01"]);
  var exactPls = resApprox.map(function (pl) {
    return pl.map(function (inter) {
      return verb.eval.Intersect.surfacesAtPointWithEstimate(surface0, surface1, inter.uv0, inter.uv1, _tolerance__WEBPACK_IMPORTED_MODULE_2__["TOLERANCE"]);
    });
  });
  var degree = Math.max(surfaceMaxDegree(surface0) === 1 && surfaceMaxDegree(surface1));
  var inserts = degree - 1;
  var nurbses = []; //TODO: temporary workaround. evenly distribute points accordingly to degree. 
  //TODO: it won't work for ellipses.
  //TODO: it also creates unnecessary degree if a cylinder is cut by a plane along it's Y axis(heightwise) 

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = exactPls[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var pl = _step.value;
      var points = pl.map(function (ip) {
        return ip.point;
      });
      var polyline = verb.eval.Make.polyline(points);

      var _curveDomain = curveDomain(polyline),
          _curveDomain2 = _slicedToArray(_curveDomain, 2),
          uMin = _curveDomain2[0],
          uMax = _curveDomain2[1];

      var insertStep = (uMax - uMin) / (inserts + 1);
      var normalizedPoints = [points[0]];

      for (var i = 0; i < inserts; i++) {
        var roughPt = curvePoint(polyline, i + insertStep);
        var uv0 = verb.eval.Analyze.rationalSurfaceClosestParam(surface0, roughPt);
        var uv1 = verb.eval.Analyze.rationalSurfaceClosestParam(surface1, roughPt);
        var pt = verb.eval.Intersect.surfacesAtPointWithEstimate(surface0, surface1, uv0, uv1, _tolerance__WEBPACK_IMPORTED_MODULE_2__["TOLERANCE"]);
        normalizedPoints.push(pt);
      }

      normalizedPoints.push(points[points.length - 1]);
      var nurbs = verb.eval.Make.rationalInterpCurve(normalizedPoints, degree);
      nurbses.push(nurbs);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return nurbses;
}
function meshesIntersect(mesh0, mesh1, TOLERANCE, TOLERANCE_SQ, TOLERANCE_01) {
  var bbtree0 = new verb.core.LazyMeshBoundingBoxTree(mesh0);
  var bbtree1 = new verb.core.LazyMeshBoundingBoxTree(mesh1);
  var bbints = verb.eval.Intersect.boundingBoxTrees(bbtree0, bbtree1, TOLERANCE);
  var segments = verb.core.ArrayExtensions.unique(bbints.map(function (ids) {
    return verb.eval.Intersect.triangles(mesh0, ids.item0, mesh1, ids.item1);
  }).filter(function (x) {
    return x != null;
  }).filter(function (x1) {
    return verb.core.Vec.distSquared(x1.min.point, x1.max.point) > TOLERANCE_SQ;
  }), function (a, b) {
    var s1 = verb.core.Vec.sub(a.min.uv0, b.min.uv0);
    var d1 = verb.core.Vec.dot(s1, s1);
    var s2 = verb.core.Vec.sub(a.max.uv0, b.max.uv0);
    var d2 = verb.core.Vec.dot(s2, s2);
    var s3 = verb.core.Vec.sub(a.min.uv0, b.max.uv0);
    var d3 = verb.core.Vec.dot(s3, s3);
    var s4 = verb.core.Vec.sub(a.max.uv0, b.min.uv0);
    var d4 = verb.core.Vec.dot(s4, s4);
    return d1 < TOLERANCE_01 && d2 < TOLERANCE_01 || d3 < TOLERANCE_01 && d4 < TOLERANCE_01;
  });
  return verb.eval.Intersect.makeMeshIntersectionPolylines(segments);
}
function surfaceMaxDegree(surface) {
  return Math.max(surface.degreeU, surface.degreeV);
}
function curveIntersect(curve1, curve2) {
  var result = [];
  var segs1 = curveTessellate(curve1);
  var segs2 = curveTessellate(curve2);

  for (var i = 0; i < segs1.length - 1; i++) {
    var a1 = segs1[i];
    var b1 = segs1[i + 1];

    for (var j = 0; j < segs2.length - 1; j++) {
      var a2 = segs2[j];
      var b2 = segs2[j + 1]; //TODO: minimize

      var isec = intersectSegs(a1, b1, a2, b2, _tolerance__WEBPACK_IMPORTED_MODULE_2__["TOLERANCE"]);

      if (isec !== null) {
        var point1 = isec.point1,
            point2 = isec.point2,
            l1 = isec.l1,
            l2 = isec.l2;
        var u1 = curveClosestParam(curve1, point1);
        var u2 = curveClosestParam(curve2, point2);

        var _curveExactIntersecti = curveExactIntersection(curve1, curve2, u1, u2);

        var _curveExactIntersecti2 = _slicedToArray(_curveExactIntersecti, 2);

        u1 = _curveExactIntersecti2[0];
        u2 = _curveExactIntersecti2[1];
        result.push({
          u0: u1,
          u1: u2,
          p0: point1,
          p1: point2
        });

        if (_math_math__WEBPACK_IMPORTED_MODULE_1__["areEqual"](u1, l1, _tolerance__WEBPACK_IMPORTED_MODULE_2__["TOLERANCE"])) {
          i++;
        }

        if (_math_math__WEBPACK_IMPORTED_MODULE_1__["areEqual"](u2, l2, _tolerance__WEBPACK_IMPORTED_MODULE_2__["TOLERANCE"])) {
          j++;
        }
      }
    }
  }

  return result;
}

function curveExactIntersection(curve1, curve2, u1, u2) {
  function f(_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        u1 = _ref2[0],
        u2 = _ref2[1];

    return _math_vec__WEBPACK_IMPORTED_MODULE_0__["lengthSq"](_math_vec__WEBPACK_IMPORTED_MODULE_0__["sub"](curvePoint(curve1, u1), curvePoint(curve2, u2)));
  }

  function grad(_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        u1 = _ref4[0],
        u2 = _ref4[1];

    var d1 = verb.eval.Eval.rationalCurveDerivatives(curve1, u1, 1);
    var d2 = verb.eval.Eval.rationalCurveDerivatives(curve2, u2, 1);
    var r = _math_vec__WEBPACK_IMPORTED_MODULE_0__["sub"](d1[0], d2[0]);
    var drdu = d1[1];
    var drdt = _math_vec__WEBPACK_IMPORTED_MODULE_0__["mul"](-1, d2[1]);
    return [2 * _math_vec__WEBPACK_IMPORTED_MODULE_0__["dot"](drdu, r), 2 * _math_vec__WEBPACK_IMPORTED_MODULE_0__["dot"](drdt, r)];
  }

  var params = [u1, u2];
  return Object(_math_optim__WEBPACK_IMPORTED_MODULE_3__["fmin_bfgs"])(f, params, _tolerance__WEBPACK_IMPORTED_MODULE_2__["TOLERANCE_SQ"], grad).solution;
}

function lineLineIntersection(p1, p2, v1, v2) {
  var zAx = _math_vec__WEBPACK_IMPORTED_MODULE_0__["cross"](v1, v2);

  var n1 = _math_vec__WEBPACK_IMPORTED_MODULE_0__["_normalize"](_math_vec__WEBPACK_IMPORTED_MODULE_0__["cross"](zAx, v1));

  var n2 = _math_vec__WEBPACK_IMPORTED_MODULE_0__["_normalize"](_math_vec__WEBPACK_IMPORTED_MODULE_0__["cross"](zAx, v2));

  return {
    u1: _math_vec__WEBPACK_IMPORTED_MODULE_0__["dot"](n2, _math_vec__WEBPACK_IMPORTED_MODULE_0__["sub"](p2, p1)) / _math_vec__WEBPACK_IMPORTED_MODULE_0__["dot"](n2, v1),
    u2: _math_vec__WEBPACK_IMPORTED_MODULE_0__["dot"](n1, _math_vec__WEBPACK_IMPORTED_MODULE_0__["sub"](p1, p2)) / _math_vec__WEBPACK_IMPORTED_MODULE_0__["dot"](n1, v2)
  };
}

function intersectSegs(a1, b1, a2, b2) {
  var v1 = _math_vec__WEBPACK_IMPORTED_MODULE_0__["sub"](b1, a1);
  var v2 = _math_vec__WEBPACK_IMPORTED_MODULE_0__["sub"](b2, a2);
  var l1 = _math_vec__WEBPACK_IMPORTED_MODULE_0__["length"](v1);
  var l2 = _math_vec__WEBPACK_IMPORTED_MODULE_0__["length"](v2);

  _math_vec__WEBPACK_IMPORTED_MODULE_0__["_div"](v1, l1);

  _math_vec__WEBPACK_IMPORTED_MODULE_0__["_div"](v2, l2);

  var _lineLineIntersection = lineLineIntersection(a1, a2, v1, v2),
      u1 = _lineLineIntersection.u1,
      u2 = _lineLineIntersection.u2;

  var point1 = _math_vec__WEBPACK_IMPORTED_MODULE_0__["add"](a1, _math_vec__WEBPACK_IMPORTED_MODULE_0__["mul"](v1, u1));
  var point2 = _math_vec__WEBPACK_IMPORTED_MODULE_0__["add"](a2, _math_vec__WEBPACK_IMPORTED_MODULE_0__["mul"](v2, u2));
  var p2p = _math_vec__WEBPACK_IMPORTED_MODULE_0__["lengthSq"](_math_vec__WEBPACK_IMPORTED_MODULE_0__["sub"](point1, point2));

  var eq = function eq(a, b) {
    return _math_math__WEBPACK_IMPORTED_MODULE_1__["areEqual"](a, b, _tolerance__WEBPACK_IMPORTED_MODULE_2__["TOLERANCE"]);
  };

  if (u1 !== Infinity && u2 !== Infinity && _math_math__WEBPACK_IMPORTED_MODULE_1__["areEqual"](p2p, 0, _tolerance__WEBPACK_IMPORTED_MODULE_2__["TOLERANCE_SQ"]) && (u1 > 0 && u1 < l1 || eq(u1, 0) || eq(u1, l1)) && (u2 > 0 && u2 < l2 || eq(u2, 0) || eq(u2, l2))) {
    return {
      point1: point1,
      point2: point2,
      u1: u1,
      u2: u2,
      l1: l1,
      l2: l2
    };
  }

  return null;
}

function normalizeCurveEnds(curve) {
  for (var i = 0; i < curve.knots.length; i++) {
    var val = curve.knots[i];

    if (Object(_tolerance__WEBPACK_IMPORTED_MODULE_2__["eqEps"])(val, 0)) {
      curve.knots[i] = 0;
    } else if (Object(_tolerance__WEBPACK_IMPORTED_MODULE_2__["eqEps"])(val, 1)) {
      curve.knots[i] = 1;
    }
  }
}
function normalizeCurveParametrization(curve) {
  var _curveDomain3 = curveDomain(curve),
      _curveDomain4 = _slicedToArray(_curveDomain3, 2),
      min = _curveDomain4[0],
      max = _curveDomain4[1];

  var d = max - min;

  for (var i = 0; i < curve.knots.length; i++) {
    var val = curve.knots[i];

    if (Object(_tolerance__WEBPACK_IMPORTED_MODULE_2__["eqEps"])(val, min)) {
      curve.knots[i] = 0;
    } else if (Object(_tolerance__WEBPACK_IMPORTED_MODULE_2__["eqEps"])(val, max)) {
      curve.knots[i] = 1;
    } else {
      curve.knots[i] = (val - min) / d;
    }
  }

  return curve;
}
function normalizeCurveParametrizationIfNeeded(curve) {
  var _curveDomain5 = curveDomain(curve),
      _curveDomain6 = _slicedToArray(_curveDomain5, 2),
      min = _curveDomain6[0],
      max = _curveDomain6[1];

  if (min !== 0 || max !== 1) {
    normalizeCurveParametrization(curve);
  }
}
function curveInvert(curve) {
  var reversed = verb.eval.Modify.curveReverse(curve);
  return reversed;
}

/***/ }),

/***/ "./web/app/brep/geom/tolerance.js":
/*!****************************************!*\
  !*** ./web/app/brep/geom/tolerance.js ***!
  \****************************************/
/*! exports provided: TOLERANCE, TOLERANCE_SQ, EPSILON, EPSILON_SQ, TOLERANCE_01, TOLERANCE_01_SQ, NUMERICAL_SOLVE_TOL, eqTol, eqSqTol, eqEps, veq, veqNeg, veq3, veqXYZ, ueq */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOLERANCE", function() { return TOLERANCE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOLERANCE_SQ", function() { return TOLERANCE_SQ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON", function() { return EPSILON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON_SQ", function() { return EPSILON_SQ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOLERANCE_01", function() { return TOLERANCE_01; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOLERANCE_01_SQ", function() { return TOLERANCE_01_SQ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NUMERICAL_SOLVE_TOL", function() { return NUMERICAL_SOLVE_TOL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eqTol", function() { return eqTol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eqSqTol", function() { return eqSqTol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eqEps", function() { return eqEps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "veq", function() { return veq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "veqNeg", function() { return veqNeg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "veq3", function() { return veq3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "veqXYZ", function() { return veqXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ueq", function() { return ueq; });
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");

var TOLERANCE = 1e-3;
var TOLERANCE_SQ = TOLERANCE * TOLERANCE;
var EPSILON = 1e-12;
var EPSILON_SQ = EPSILON * EPSILON; //tolerance used for parametric domain which is between 0..1

var TOLERANCE_01 = TOLERANCE * 1e-2;
var TOLERANCE_01_SQ = TOLERANCE * TOLERANCE;
var NUMERICAL_SOLVE_TOL = 1e-8;
function eqTol(a, b) {
  return Object(_math_math__WEBPACK_IMPORTED_MODULE_0__["areEqual"])(a, b, TOLERANCE);
}
function eqSqTol(a, b) {
  return Object(_math_math__WEBPACK_IMPORTED_MODULE_0__["areEqual"])(a, b, TOLERANCE_SQ);
}
function eqEps(a, b) {
  return Object(_math_math__WEBPACK_IMPORTED_MODULE_0__["areEqual"])(a, b, EPSILON);
}
function veq(a, b) {
  return Object(_math_math__WEBPACK_IMPORTED_MODULE_0__["areVectorsEqual"])(a, b, TOLERANCE_SQ);
}
function veqNeg(a, b) {
  return Object(_math_math__WEBPACK_IMPORTED_MODULE_0__["areNegVectorsEqual"])(a, b, TOLERANCE_SQ);
}
function veq3(a, b) {
  return Object(_math_math__WEBPACK_IMPORTED_MODULE_0__["areVectorsEqual3"])(a, b, TOLERANCE_SQ);
}
function veqXYZ(x1, y1, z1, x2, y2, z2) {
  return Object(_math_math__WEBPACK_IMPORTED_MODULE_0__["distanceSquared3"])(x1, y1, z1, x2, y2, z2) < TOLERANCE_SQ;
}
function ueq(a, b) {
  return Object(_math_math__WEBPACK_IMPORTED_MODULE_0__["areEqual"])(a, b, TOLERANCE_01);
}

/***/ }),

/***/ "./web/app/math/bbox.js":
/*!******************************!*\
  !*** ./web/app/math/bbox.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BBox; });
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var BBox =
/*#__PURE__*/
function () {
  function BBox() {
    _classCallCheck(this, BBox);

    this.minX = Number.MAX_VALUE;
    this.minY = Number.MAX_VALUE;
    this.minZ = Number.MAX_VALUE;
    this.maxX = -Number.MAX_VALUE;
    this.maxY = -Number.MAX_VALUE;
    this.maxZ = -Number.MAX_VALUE;
  }

  _createClass(BBox, [{
    key: "checkBounds",
    value: function checkBounds(x, y, z) {
      z = z || 0;
      this.minX = Math.min(this.minX, x);
      this.minY = Math.min(this.minY, y);
      this.minZ = Math.min(this.minZ, z);
      this.maxX = Math.max(this.maxX, x);
      this.maxY = Math.max(this.maxY, y);
      this.maxZ = Math.max(this.maxZ, z);
    }
  }, {
    key: "checkPoint",
    value: function checkPoint(p) {
      this.checkBounds(p.x, p.y, p.z);
    }
  }, {
    key: "checkData",
    value: function checkData(_ref) {
      var _ref2 = _slicedToArray(_ref, 3),
          x = _ref2[0],
          y = _ref2[1],
          z = _ref2[2];

      this.checkBounds(x, y, z);
    }
  }, {
    key: "center",
    value: function center() {
      return new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](this.minX + (this.maxX - this.minX) / 2, this.minY + (this.maxY - this.minY) / 2, this.minZ + (this.maxZ - this.minZ) / 2);
    }
  }, {
    key: "min",
    value: function min() {
      return new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](this.minX, this.minY, this.minZ);
    }
  }, {
    key: "max",
    value: function max() {
      return new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](this.maxX, this.maxY, this.maxZ);
    }
  }, {
    key: "width",
    value: function width() {
      return this.maxX - this.minX;
    }
  }, {
    key: "height",
    value: function height() {
      return this.maxY - this.minY;
    }
  }, {
    key: "depth",
    value: function depth() {
      return this.maxZ - this.minZ;
    }
  }, {
    key: "expand",
    value: function expand(delta) {
      this.minX -= delta;
      this.minY -= delta;
      this.minZ -= delta;
      this.maxX += delta;
      this.maxY += delta;
      this.maxZ += delta;
    }
  }, {
    key: "toPolygon",
    value: function toPolygon() {
      return [new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](this.minX, this.minY, 0), new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](this.maxX, this.minY, 0), new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](this.maxX, this.maxY, 0), new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](this.minX, this.maxY, 0)];
    }
  }]);

  return BBox;
}();



/***/ }),

/***/ "./web/app/math/bezier-cubic.js":
/*!**************************************!*\
  !*** ./web/app/math/bezier-cubic.js ***!
  \**************************************/
/*! exports provided: LUT, compute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LUT", function() { return LUT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compute", function() { return compute; });
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./web/app/math/math.js");


function LUT(a, b, cp1, cp2, scale) {
  scale = 1 / scale;
  var lut = [];

  for (var t = 0; t < 1; t += 0.1 * scale) {
    var p = compute(t, a, b, cp1, cp2);
    lut.push(p);
  }

  lut[0] = a;
  lut[lut.length - 1] = b;
  return lut;
}
function compute(t, from, to, controlPoint1, controlPoint2) {
  var mt = 1 - t;
  var mt2 = mt * mt;
  var t2 = t * t;
  var a = mt2 * mt;
  var b = mt2 * t * 3;
  var c = mt * t2 * 3;
  var d = t * t2;
  var p0 = from;
  var p3 = to;
  var p1 = controlPoint1;
  var p2 = controlPoint2;
  return new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](a * p0.x + b * p1.x + c * p2.x + d * p3.x, a * p0.y + b * p1.y + c * p2.y + d * p3.y, a * p0.z + b * p1.z + c * p2.z + d * p3.z);
}

/***/ }),

/***/ "./web/app/math/convex-hull.js":
/*!*************************************!*\
  !*** ./web/app/math/convex-hull.js ***!
  \*************************************/
/*! exports provided: ConvexHull2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConvexHull2D", function() { return ConvexHull2D; });
function ConvexHull2D(points) {
  points.sort(function (a, b) {
    return a.x != b.x ? a.x - b.x : a.y - b.y;
  });
  var n = points.length;
  var hull = [];

  for (var i = 0; i < 2 * n; i++) {
    var j = i < n ? i : 2 * n - 1 - i;

    while (hull.length >= 2 && removeMiddle(hull[hull.length - 2], hull[hull.length - 1], points[j])) {
      hull.pop();
    }

    hull.push(points[j]);
  }

  hull.pop();
  return hull;
}

function removeMiddle(a, b, c) {
  var cross = (a.x - b.x) * (c.y - b.y) - (a.y - b.y) * (c.x - b.x);
  var dot = (a.x - b.x) * (c.x - b.x) + (a.y - b.y) * (c.y - b.y);
  return cross < 0 || cross == 0 && dot <= 0;
}

/***/ }),

/***/ "./web/app/math/graph.js":
/*!*******************************!*\
  !*** ./web/app/math/graph.js ***!
  \*******************************/
/*! exports provided: Graph */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Graph", function() { return Graph; });
/* harmony import */ var _utils_hashmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/hashmap */ "./web/app/utils/hashmap.js");

/** @constructor */

function Graph(data) {
  this.connections = function (e) {
    return data[e];
  };

  this.at = function (index) {
    return index;
  };

  this.size = function () {
    return data.length;
  };
}

Graph.findAllLoops = function (graph, hashCode, equals) {
  var loops = [];
  var visited = new _utils_hashmap__WEBPACK_IMPORTED_MODULE_0__["HashTable"](hashCode, equals);

  function step(vertex, comesFrom, path) {
    var i;
    visited.put(vertex, true);

    for (i = path.length - 1; i >= 0; --i) {
      if (equals(vertex, path[i])) {
        loops.push(path.slice(i));
        return;
      }
    }

    var next = graph.connections(vertex);
    path.push(vertex);
    var needClone = false;

    for (i = 0; i < next.length; i++) {
      var v = next[i];

      if (equals(v, comesFrom)) {
        continue;
      }

      var p = needClone ? path.slice(0) : path;
      needClone = true;
      step(v, vertex, p);
    }

    path.pop();
  }

  for (i = 0; i < graph.size(); i++) {
    var vertex = graph.at(i);

    if (visited.get(vertex) !== true) {
      step(vertex, -1, []);
    }
  } //filter duplicates


  function sameLoop(a, b) {
    var first = a[0];

    for (var bShift = 0; bShift < a.length; bShift++) {
      if (equals(b[bShift], first)) {
        break;
      }
    }

    if (bShift == a.length) {
      return false;
    }

    for (var i = 0; i < a.length; i++) {
      var bUp = (bShift + i) % a.length;
      var bDown = bShift - i;

      if (bDown < 0) {
        bDown = a.length + bDown;
      } //      console.log("up: " + bUp + "; down: " + bDown);


      var curr = a[i];

      if (!equals(curr, b[bUp]) && !equals(curr, b[bDown])) {
        return false;
      }
    }

    return true;
  }

  var i,
      duplicates = 0;

  for (i = 0; i < loops.length; i++) {
    var a = loops[i];
    if (a == null) continue;

    for (var j = i + 1; j < loops.length; j++) {
      var b = loops[j];

      if (b == null || a.length !== b.length) {
        continue;
      }

      if (sameLoop(a, b)) {
        loops[j] = null;
        ++duplicates;
      }
    }
  }

  if (duplicates != 0) {
    var filtered = [];

    for (i = 0; i < loops.length; i++) {
      if (loops[i] != null) filtered.push(loops[i]);
    }

    loops = filtered;
  }

  return loops;
};

var test = function test() {
  var data = [[], [2], [1, 3, 9], [2, 4], [3, 9, 5, 8], [4, 6], [5, 8, 7], [6], [4, 6], [2, 4]];
  var graph = new Graph(data);
  console.log(Graph.findAllLoops(graph));
};

var test0 = function test0() {
  var data = [[3, 1], [0, 2, 8], [1, 3, 7, 5], [0, 2, 4], [3, 5], [4, 2, 6], [5, 7], [2, 6, 8], [1, 7]];
  var graph = new Graph(data);
  console.log(Graph.findAllLoops(graph));
};



/***/ }),

/***/ "./web/app/math/l3space.js":
/*!*********************************!*\
  !*** ./web/app/math/l3space.js ***!
  \*********************************/
/*! exports provided: STANDARD_BASES, Matrix3, ORIGIN, IDENTITY_BASIS, AXIS, BasisForPlane */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STANDARD_BASES", function() { return STANDARD_BASES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return Matrix3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORIGIN", function() { return ORIGIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IDENTITY_BASIS", function() { return IDENTITY_BASIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AXIS", function() { return AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasisForPlane", function() { return BasisForPlane; });
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var freeze = Object.freeze;
var ORIGIN = freeze(new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](0, 0, 0));
var AXIS = freeze({
  X: freeze(new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](1, 0, 0)),
  Y: freeze(new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](0, 1, 0)),
  Z: freeze(new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](0, 0, 1))
});
var IDENTITY_BASIS = Object.freeze([AXIS.X, AXIS.Y, AXIS.Z]);
var STANDARD_BASES = freeze({
  'XY': IDENTITY_BASIS,
  'XZ': [AXIS.X, AXIS.Z, AXIS.Y],
  'ZY': [AXIS.Z, AXIS.Y, AXIS.X]
});

var Matrix3 = function Matrix3() {
  var _this = this;

  _classCallCheck(this, Matrix3);

  _defineProperty(this, "apply", function (vector) {
    return _this.__apply(vector, new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"]());
  });

  this.reset();
};

Matrix3.prototype.reset = function () {
  this.mxx = 1;
  this.mxy = 0;
  this.mxz = 0;
  this.tx = 0;
  this.myx = 0;
  this.myy = 1;
  this.myz = 0;
  this.ty = 0;
  this.mzx = 0;
  this.mzy = 0;
  this.mzz = 1;
  this.tz = 0;
  return this;
};

Matrix3.prototype.setBasis = function (basis) {
  var b = basis;
  this.mxx = b[0].x;
  this.mxy = b[1].x;
  this.mxz = b[2].x;
  this.tx = 0;
  this.myx = b[0].y;
  this.myy = b[1].y;
  this.myz = b[2].y;
  this.ty = 0;
  this.mzx = b[0].z;
  this.mzy = b[1].z;
  this.mzz = b[2].z;
  this.tz = 0;
  return this;
};

Matrix3.prototype.setBasisAxises = function (x, y, z) {
  this.mxx = x.x;
  this.mxy = y.x;
  this.mxz = z.x;
  this.tx = 0;
  this.myx = x.y;
  this.myy = y.y;
  this.myz = z.y;
  this.ty = 0;
  this.mzx = x.z;
  this.mzy = y.z;
  this.mzz = z.z;
  this.tz = 0;
  return this;
};

Matrix3.prototype.scale = function (dx, dy, dz) {
  this.mxx *= dx;
  this.myy *= dy;
  this.mzz *= dz;
  return this;
};

Matrix3.prototype.translate = function (dx, dy, dz) {
  this.tx += dx;
  this.ty += dy;
  this.tz += dz;
  return this;
};

Matrix3.prototype.set3 = function (mxx, mxy, mxz, myx, myy, myz, mzx, mzy, mzz) {
  this.mxx = mxx;
  this.mxy = mxy;
  this.mxz = mxz;
  this.myx = myx;
  this.myy = myy;
  this.myz = myz;
  this.mzx = mzx;
  this.mzy = mzy;
  this.mzz = mzz;
  return this;
};

Matrix3.prototype.set34 = function (mxx, mxy, mxz, tx, myx, myy, myz, ty, mzx, mzy, mzz, tz) {
  this.mxx = mxx;
  this.mxy = mxy;
  this.mxz = mxz;
  this.tx = tx;
  this.myx = myx;
  this.myy = myy;
  this.myz = myz;
  this.ty = ty;
  this.mzx = mzx;
  this.mzy = mzy;
  this.mzz = mzz;
  this.tz = tz;
  return this;
};

Matrix3.prototype.setMatrix = function (m) {
  this.mxx = m.mxx;
  this.mxy = m.mxy;
  this.mxz = m.mxz;
  this.tx = m.tx;
  this.myx = m.myx;
  this.myy = m.myy;
  this.myz = m.myz;
  this.ty = m.ty;
  this.mzx = m.mzx;
  this.mzy = m.mzy;
  this.mzz = m.mzz;
  this.tz = m.tz;
  return this;
};

Matrix3.prototype.toArray = function () {
  return [[this.mxx, this.mxy, this.mxz, this.tx], [this.myx, this.myy, this.myz, this.ty], [this.mzx, this.mzy, this.mzz, this.tz]];
};

Matrix3.prototype.invert = function () {
  return this.__invert(new Matrix3());
};

Matrix3.prototype._invert = function () {
  return this.__invert(this);
};

Matrix3.prototype.__invert = function (out) {
  var det = this.mxx * (this.myy * this.mzz - this.mzy * this.myz) + this.mxy * (this.myz * this.mzx - this.mzz * this.myx) + this.mxz * (this.myx * this.mzy - this.mzx * this.myy);

  if (det == 0.0) {
    return null;
  }

  var cxx = this.myy * this.mzz - this.myz * this.mzy;
  var cyx = -this.myx * this.mzz + this.myz * this.mzx;
  var czx = this.myx * this.mzy - this.myy * this.mzx;
  var cxt = -this.mxy * (this.myz * this.tz - this.mzz * this.ty) - this.mxz * (this.ty * this.mzy - this.tz * this.myy) - this.tx * (this.myy * this.mzz - this.mzy * this.myz);
  var cxy = -this.mxy * this.mzz + this.mxz * this.mzy;
  var cyy = this.mxx * this.mzz - this.mxz * this.mzx;
  var czy = -this.mxx * this.mzy + this.mxy * this.mzx;
  var cyt = this.mxx * (this.myz * this.tz - this.mzz * this.ty) + this.mxz * (this.ty * this.mzx - this.tz * this.myx) + this.tx * (this.myx * this.mzz - this.mzx * this.myz);
  var cxz = this.mxy * this.myz - this.mxz * this.myy;
  var cyz = -this.mxx * this.myz + this.mxz * this.myx;
  var czz = this.mxx * this.myy - this.mxy * this.myx;
  var czt = -this.mxx * (this.myy * this.tz - this.mzy * this.ty) - this.mxy * (this.ty * this.mzx - this.tz * this.myx) - this.tx * (this.myx * this.mzy - this.mzx * this.myy);
  out.mxx = cxx / det;
  out.mxy = cxy / det;
  out.mxz = cxz / det;
  out.tx = cxt / det;
  out.myx = cyx / det;
  out.myy = cyy / det;
  out.myz = cyz / det;
  out.ty = cyt / det;
  out.mzx = czx / det;
  out.mzy = czy / det;
  out.mzz = czz / det;
  out.tz = czt / det;
  return out;
};

Matrix3.prototype.combine = function (transform, out) {
  var txx = transform.mxx;
  var txy = transform.mxy;
  var txz = transform.mxz;
  var ttx = transform.tx;
  var tyx = transform.myx;
  var tyy = transform.myy;
  var tyz = transform.myz;
  var tty = transform.ty;
  var tzx = transform.mzx;
  var tzy = transform.mzy;
  var tzz = transform.mzz;
  var ttz = transform.tz;
  var m = out || new Matrix3();
  m.mxx = this.mxx * txx + this.mxy * tyx + this.mxz * tzx;
  m.mxy = this.mxx * txy + this.mxy * tyy + this.mxz * tzy;
  m.mxz = this.mxx * txz + this.mxy * tyz + this.mxz * tzz;
  m.tx = this.mxx * ttx + this.mxy * tty + this.mxz * ttz + this.tx;
  m.myx = this.myx * txx + this.myy * tyx + this.myz * tzx;
  m.myy = this.myx * txy + this.myy * tyy + this.myz * tzy;
  m.myz = this.myx * txz + this.myy * tyz + this.myz * tzz;
  m.ty = this.myx * ttx + this.myy * tty + this.myz * ttz + this.ty;
  m.mzx = this.mzx * txx + this.mzy * tyx + this.mzz * tzx;
  m.mzy = this.mzx * txy + this.mzy * tyy + this.mzz * tzy;
  m.mzz = this.mzx * txz + this.mzy * tyz + this.mzz * tzz;
  m.tz = this.mzx * ttx + this.mzy * tty + this.mzz * ttz + this.tz;
  return m;
};

Matrix3.prototype._apply = function (vector) {
  return this.__apply(vector, vector);
};

Matrix3.prototype.__apply = function (vector, out) {
  var x = vector.x;
  var y = vector.y;
  var z = vector.z;
  out.x = this.mxx * x + this.mxy * y + this.mxz * z + this.tx;
  out.y = this.myx * x + this.myy * y + this.myz * z + this.ty;
  out.z = this.mzx * x + this.mzy * y + this.mzz * z + this.tz;
  return out;
};

Matrix3.prototype.apply3 = function (data) {
  return this.__apply3(data, []);
};

Matrix3.prototype._apply3 = function (data) {
  return this.__apply3(data, data);
};

Matrix3.prototype.__apply3 = function (_ref, out) {
  var _ref2 = _slicedToArray(_ref, 3),
      x = _ref2[0],
      y = _ref2[1],
      z = _ref2[2];

  out[0] = this.mxx * x + this.mxy * y + this.mxz * z + this.tx;
  out[1] = this.myx * x + this.myy * y + this.myz * z + this.ty;
  out[2] = this.mzx * x + this.mzy * y + this.mzz * z + this.tz;
  return out;
};

Matrix3.prototype.rotate = function (angle, axis, pivot) {
  return Matrix3.rotateMatrix(angle, axis, pivot, this);
};

Matrix3.rotateMatrix = function (angle, axis, pivot, matrix) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  var axisX, axisY, axisZ;
  var m = matrix || new Matrix3();

  if (axis === AXIS.X || axis === AXIS.Y || axis === AXIS.Z) {
    axisX = axis.x;
    axisY = axis.y;
    axisZ = axis.z;
  } else {
    // normalize
    var mag = axis.length();

    if (mag == 0.0) {
      return m;
    } else {
      axisX = axis.x / mag;
      axisY = axis.y / mag;
      axisZ = axis.z / mag;
    }
  }

  var px = pivot.x;
  var py = pivot.y;
  var pz = pivot.z;
  m.mxx = cos + axisX * axisX * (1 - cos);
  m.mxy = axisX * axisY * (1 - cos) - axisZ * sin;
  m.mxz = axisX * axisZ * (1 - cos) + axisY * sin;
  m.tx = px * (1 - m.mxx) - py * m.mxy - pz * m.mxz;
  m.myx = axisY * axisX * (1 - cos) + axisZ * sin;
  m.myy = cos + axisY * axisY * (1 - cos);
  m.myz = axisY * axisZ * (1 - cos) - axisX * sin;
  m.ty = py * (1 - m.myy) - px * m.myx - pz * m.myz;
  m.mzx = axisZ * axisX * (1 - cos) - axisY * sin;
  m.mzy = axisZ * axisY * (1 - cos) + axisX * sin;
  m.mzz = cos + axisZ * axisZ * (1 - cos);
  m.tz = pz * (1 - m.mzz) - px * m.mzx - py * m.mzy;
  return m;
};

function BasisForPlane(normal) {
  var alignY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AXIS.Y;
  var alignZ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AXIS.Z;
  var alignPlane, x, y;

  if (Math.abs(normal.dot(alignY)) < 0.5) {
    alignPlane = normal.cross(alignY);
  } else {
    alignPlane = normal.cross(alignZ);
  }

  y = alignPlane.cross(normal);
  x = y.cross(normal);
  return [x, y, normal];
}



/***/ }),

/***/ "./web/app/math/lm.js":
/*!****************************!*\
  !*** ./web/app/math/lm.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LMOptimizer; });
/**
 * This class solves a least-squares problem using the Levenberg-Marquardt algorithm.
 *
 * <p>This implementation <em>should</em> work even for over-determined systems
 * (i.e. systems having more point than equations). Over-determined systems
 * are solved by ignoring the point which have the smallest impact according
 * to their jacobian column norm. Only the rank of the matrix and some loop bounds
 * are changed to implement this.</p>
 *
 * <p>The resolution engine is a simple translation of the MINPACK <a
 * href="http://www.netlib.org/minpack/lmder.f">lmder</a> routine with minor
 * changes. The changes include the over-determined resolution, the use of
 * inherited convergence checker and the Q.R. decomposition which has been
 * rewritten following the algorithm described in the
 * P. Lascaux and R. Theodor book <i>Analyse num&eacute;rique matricielle
 * appliqu&eacute;e &agrave; l'art de l'ing&eacute;nieur</i>, Masson 1986.</p>
 * <p>The authors of the original fortran version are:
 * <ul>
 * <li>Argonne National Laboratory. MINPACK project. March 1980</li>
 * <li>Burton S. Garbow</li>
 * <li>Kenneth E. Hillstrom</li>
 * <li>Jorge J. More</li>
 * </ul>
 * The redistribution policy for MINPACK is available <a
 * href="http://www.netlib.org/minpack/disclaimer">here</a>, for convenience, it
 * is reproduced below.</p>
 *
 * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0">
 * <tr><td>
 *    Minpack Copyright Notice (1999) University of Chicago.
 *    All rights reserved
 * </td></tr>
 * <tr><td>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * <ol>
 *  <li>Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.</li>
 * <li>The end-user documentation included with the redistribution, if any,
 *     must include the following acknowledgment:
 *     <code>This product includes software developed by the University of
 *           Chicago, as Operator of Argonne National Laboratory.</code>
 *     Alternately, this acknowledgment may appear in the software itself,
 *     if and wherever such third-party acknowledgments normally appear.</li>
 * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS"
 *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE
 *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND
 *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR
 *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE
 *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY
 *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR
 *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF
 *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)
 *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION
 *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL
 *     BE CORRECTED.</strong></li>
 * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT
 *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF
 *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,
 *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF
 *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF
 *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER
 *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT
 *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,
 *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE
 *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>
 * <ol></td></tr>
 * </table>
 *
 * @version $Id: LevenbergMarquardtOptimizer.java 1416643 2012-12-03 19:37:14Z tn $
 * @constructor
 */
function LMOptimizer(startPoint, target, model, jacobian) {
  this.startPoint = startPoint;
  this.target = target;
  this.evalCount = 0;
  this.evalMaximalCount = 100000;
  this.model = model;
  this.jacobian = jacobian;

  this.identity = function (size) {
    var out = [];

    for (var row = 0; row < size; ++row) {
      out.push([]);

      for (var col = 0; col < size; ++col) {
        out[row].push(row === col ? 1 : 0);
      }
    }

    return out;
  };
  /** Square-root of the weight matrix. */


  this.weightMatrixSqrt = this.identity(target.length); //TMath.identity(new TMath.Matrix(target.length, target.length)); //TODO:

  this.weightMatrix = this.identity(target.length);
  /** Cost value (square root of the sum of the residuals). */

  this.cost = null;
  /** Number of solved point. */

  this.solvedCols = null;
  /** Diagonal elements of the R matrix in the Q.R. decomposition. */

  this.diagR = null;
  /** Norms of the columns of the jacobian matrix. */

  this.jacNorm = null;
  /** Coefficients of the Householder transforms vectors. */

  this.beta = null;
  /** Columns permutation array. */

  this.permutation = null;
  /** Rank of the jacobian matrix. */

  this.rank = null;
  /** Levenberg-Marquardt parameter. */

  this.lmPar = null;
  /** Parameters evolution direction associated with lmPar. */

  this.lmDir = null;
  /** Positive input variable used in determining the initial step bound. */

  this.initialStepBoundFactor = null;
  /** Desired relative error in the sum of squares. */

  this.costRelativeTolerance = null;
  /**  Desired relative error in the approximate solution parameters. */

  this.parRelativeTolerance = null;
  /** Desired max cosine on the orthogonality between the function vector
   * and the columns of the jacobian. */

  this.orthoTolerance = null;
  /** Threshold for QR ranking. */

  this.qrRankingThreshold = null;
  /** Weighted residuals. */

  this.weightedResidual = null;
  /** Weighted Jacobian. */

  this.weightedJacobian = null;
  this.checker = null;

  function arr(size) {
    var out = [];
    out.length = size;

    for (var i = 0; i < size; ++i) {
      out[i] = 0;
    }

    return out;
  }

  function Arrays_fill(a, fromIndex, toIndex, val) {
    for (var i = fromIndex; i < toIndex; i++) {
      a[i] = val;
    }
  } //    var SAFE_MIN = Number.MIN_VALUE; //FIXME!!!!


  var SAFE_MIN = 1e-30; //FIXME!!!!

  /**
   * Build an optimizer for least squares problems with default values
   * for all the tuning parameters (see the {@link
   * #LevenbergMarquardtOptimizer(double,double,double,double,double)
   * other contructor}.
   * The default values for the algorithm settings are:
   * <ul>
   *  <li>Initial step bound factor: 100</li>
   *  <li>Cost relative tolerance: 1e-10</li>
   *  <li>Parameters relative tolerance: 1e-10</li>
   *  <li>Orthogonality tolerance: 1e-10</li>
   *  <li>QR ranking threshold: {@link Precision#SAFE_MIN}</li>
   * </ul>
   */

  this.init = function () {
    this.init1(100, 1e-10, 1e-10, 1e-10, SAFE_MIN);
  };
  /**
   * Build an optimizer for least squares problems with default values
   * for some of the tuning parameters (see the {@link
   * #LevenbergMarquardtOptimizer(double,double,double,double,double)
   * other contructor}.
   * The default values for the algorithm settings are:
   * <ul>
   *  <li>Initial step bound factor}: 100</li>
   *  <li>QR ranking threshold}: {@link Precision#SAFE_MIN}</li>
   * </ul>
   *
   * @param costRelativeTolerance Desired relative error in the sum of
   * squares.
   * @param parRelativeTolerance Desired relative error in the approximate
   * solution parameters.
   * @param orthoTolerance Desired max cosine on the orthogonality between
   * the function vector and the columns of the Jacobian.
   */


  this.init0 = function (costRelativeTolerance, parRelativeTolerance, orthoTolerance) {
    this.init1(100, costRelativeTolerance, parRelativeTolerance, orthoTolerance, SAFE_MIN);
  };
  /**
   * The arguments control the behaviour of the default convergence checking
   * procedure.
   * Additional criteria can defined through the setting of a {@link
   * ConvergenceChecker}.
   *
   * @param initialStepBoundFactor Positive input variable used in
   * determining the initial step bound. This bound is set to the
   * product of initialStepBoundFactor and the euclidean norm of
   * {@code diag * x} if non-zero, or else to {@code initialStepBoundFactor}
   * itself. In most cases factor should lie in the interval
   * {@code (0.1, 100.0)}. {@code 100} is a generally recommended value.
   * @param costRelativeTolerance Desired relative error in the sum of
   * squares.
   * @param parRelativeTolerance Desired relative error in the approximate
   * solution parameters.
   * @param orthoTolerance Desired max cosine on the orthogonality between
   * the function vector and the columns of the Jacobian.
   * @param threshold Desired threshold for QR ranking. If the squared norm
   * of a column vector is smaller or equal to this threshold during QR
   * decomposition, it is considered to be a zero vector and hence the rank
   * of the matrix is reduced.
   */


  this.init1 = function (initialStepBoundFactor, costRelativeTolerance, parRelativeTolerance, orthoTolerance, threshold) {
    this.initialStepBoundFactor = initialStepBoundFactor;
    this.costRelativeTolerance = costRelativeTolerance;
    this.parRelativeTolerance = parRelativeTolerance;
    this.orthoTolerance = orthoTolerance;
    this.qrRankingThreshold = threshold;
  };
  /** {@inheritDoc} */


  this.doOptimize = function () {
    var nR = this.target.length; // Number of observed data.

    var currentPoint = this.startPoint;
    var nC = currentPoint.length; // Number of parameters.
    // arrays shared with the other private methods

    this.solvedCols = Math.min(nR, nC);
    this.diagR = arr(nC);
    this.jacNorm = arr(nC);
    this.beta = arr(nC);
    this.permutation = arr(nC);
    this.lmDir = arr(nC); // local point

    var delta = 0;
    var xNorm = 0;
    var diag = arr(nC);
    var oldX = arr(nC);
    var oldRes = arr(nR);
    var oldObj = arr(nR);
    var qtf = arr(nR);
    var work1 = arr(nC);
    var work2 = arr(nC);
    var work3 = arr(nC);
    var weightMatrixSqrt = this.getWeightSquareRoot(); // Evaluate the function at the starting point and calculate its norm.

    var currentObjective = this.computeObjectiveValue(currentPoint);
    var currentResiduals = this.computeResiduals(currentObjective);
    var current = [currentPoint, currentObjective];
    var currentCost = this.computeCost(currentResiduals); // Outer loop.

    this.lmPar = 0;
    var firstIteration = true;
    var iter = 0;

    while (true) {
      ++iter;
      var previous = current; // QR decomposition of the jacobian matrix

      this.qrDecomposition(this.computeWeightedJacobian(currentPoint));
      this.weightedResidual = this.operate(weightMatrixSqrt, currentResiduals);

      for (var i = 0; i < nR; i++) {
        qtf[i] = this.weightedResidual[i];
      } // compute Qt.res


      this.qTy(qtf); // now we don't need Q anymore,
      // so let jacobian contain the R matrix with its diagonal elements

      for (var k = 0; k < this.solvedCols; ++k) {
        var pk = this.permutation[k];
        this.weightedJacobian[k][pk] = this.diagR[pk];
      }

      if (firstIteration) {
        // scale the point according to the norms of the columns
        // of the initial jacobian
        xNorm = 0;

        for (var k = 0; k < nC; ++k) {
          var dk = this.jacNorm[k];

          if (dk == 0) {
            dk = 1.0;
          }

          var xk = dk * currentPoint[k];
          xNorm += xk * xk;
          diag[k] = dk;
        }

        xNorm = Math.sqrt(xNorm); // initialize the step bound delta

        delta = xNorm == 0 ? this.initialStepBoundFactor : this.initialStepBoundFactor * xNorm;
      } // check orthogonality between function vector and jacobian columns


      var maxCosine = 0;

      if (currentCost != 0) {
        for (var j = 0; j < this.solvedCols; ++j) {
          var pj = this.permutation[j];
          var s = this.jacNorm[pj];

          if (s != 0) {
            var sum = 0;

            for (var i = 0; i <= j; ++i) {
              sum += this.weightedJacobian[i][pj] * qtf[i];
            }

            maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * currentCost));
          }
        }
      }

      if (maxCosine <= this.orthoTolerance) {
        // Convergence has been reached.
        this.setCost(currentCost);
        return current;
      } // rescale if necessary


      for (var j = 0; j < nC; ++j) {
        diag[j] = Math.max(diag[j], this.jacNorm[j]);
      } // Inner loop.


      for (var ratio = 0; ratio < 1.0e-4;) {
        // save the state
        for (var j = 0; j < this.solvedCols; ++j) {
          var pj = this.permutation[j];
          oldX[pj] = currentPoint[pj];
        }

        var previousCost = currentCost;
        var tmpVec = this.weightedResidual;
        this.weightedResidual = oldRes;
        oldRes = tmpVec;
        tmpVec = currentObjective;
        currentObjective = oldObj;
        oldObj = tmpVec; // determine the Levenberg-Marquardt parameter

        this.determineLMParameter(qtf, delta, diag, work1, work2, work3); // compute the new point and the norm of the evolution direction

        var lmNorm = 0;

        for (var j = 0; j < this.solvedCols; ++j) {
          var pj = this.permutation[j];
          this.lmDir[pj] = -this.lmDir[pj];
          currentPoint[pj] = oldX[pj] + this.lmDir[pj];
          var s = diag[pj] * this.lmDir[pj];
          lmNorm += s * s;
        }

        lmNorm = Math.sqrt(lmNorm); // on the first iteration, adjust the initial step bound.

        if (firstIteration) {
          delta = Math.min(delta, lmNorm);
        } // Evaluate the function at x + p and calculate its norm.


        currentObjective = this.computeObjectiveValue(currentPoint);
        currentResiduals = this.computeResiduals(currentObjective);
        current = [currentPoint, currentObjective];
        currentCost = this.computeCost(currentResiduals); // compute the scaled actual reduction

        var actRed = -1.0;

        if (0.1 * currentCost < previousCost) {
          var r = currentCost / previousCost;
          actRed = 1.0 - r * r;
        } // compute the scaled predicted reduction
        // and the scaled directional derivative


        for (var j = 0; j < this.solvedCols; ++j) {
          var pj = this.permutation[j];
          var dirJ = this.lmDir[pj];
          work1[j] = 0;

          for (var i = 0; i <= j; ++i) {
            work1[i] += this.weightedJacobian[i][pj] * dirJ;
          }
        }

        var coeff1 = 0;

        for (var j = 0; j < this.solvedCols; ++j) {
          coeff1 += work1[j] * work1[j];
        }

        var pc2 = previousCost * previousCost;
        coeff1 = coeff1 / pc2;
        var coeff2 = this.lmPar * lmNorm * lmNorm / pc2;
        var preRed = coeff1 + 2 * coeff2;
        var dirDer = -(coeff1 + coeff2); // ratio of the actual to the predicted reduction

        ratio = preRed == 0 ? 0 : actRed / preRed; // update the step bound

        if (ratio <= 0.25) {
          var tmp = actRed < 0 ? 0.5 * dirDer / (dirDer + 0.5 * actRed) : 0.5;

          if (0.1 * currentCost >= previousCost || tmp < 0.1) {
            tmp = 0.1;
          }

          delta = tmp * Math.min(delta, 10.0 * lmNorm);
          this.lmPar /= tmp;
        } else if (this.lmPar == 0 || ratio >= 0.75) {
          delta = 2 * lmNorm;
          this.lmPar *= 0.5;
        } // test for successful iteration.


        if (ratio >= 1.0e-4) {
          // successful iteration, update the norm
          firstIteration = false;
          xNorm = 0;

          for (var k = 0; k < nC; ++k) {
            var xK = diag[k] * currentPoint[k];
            xNorm += xK * xK;
          }

          xNorm = Math.sqrt(xNorm); // tests for convergence.

          if (this.checker != null) {
            // we use the vectorial convergence checker
            if (this.checker.call(iter, previous, current)) {
              this.setCost(currentCost);
              return current;
            }
          }
        } else {
          // failed iteration, reset the previous values
          currentCost = previousCost;

          for (var j = 0; j < this.solvedCols; ++j) {
            var pj = this.permutation[j];
            currentPoint[pj] = oldX[pj];
          }

          tmpVec = this.weightedResidual;
          this.weightedResidual = oldRes;
          oldRes = tmpVec;
          tmpVec = currentObjective;
          currentObjective = oldObj;
          oldObj = tmpVec; // Reset "current" to previous values.

          current = [currentPoint, currentObjective];
        } // Default convergence criteria.


        if (Math.abs(actRed) <= this.costRelativeTolerance && preRed <= this.costRelativeTolerance && ratio <= 2.0 || delta <= this.parRelativeTolerance * xNorm) {
          this.setCost(currentCost);
          return current;
        } // tests for termination and stringent tolerances
        // (2.2204e-16 is the machine epsilon for IEEE754)


        if (Math.abs(actRed) <= 2.2204e-16 && preRed <= 2.2204e-16 && ratio <= 2.0) {
          throw "TOO_SMALL_COST_RELATIVE_TOLERANCE: " + this.costRelativeTolerance;
        } else if (delta <= 2.2204e-16 * xNorm) {
          throw "TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE: " + this.parRelativeTolerance;
        } else if (maxCosine <= 2.2204e-16) {
          throw "TOO_SMALL_ORTHOGONALITY_TOLERANCE: " + this.orthoTolerance;
        }
      }
    }
  };
  /**
   * Determine the Levenberg-Marquardt parameter.
   * <p>This implementation is a translation in Java of the MINPACK
   * <a href="http://www.netlib.org/minpack/lmpar.f">lmpar</a>
   * routine.</p>
   * <p>This method sets the lmPar and lmDir attributes.</p>
   * <p>The authors of the original fortran function are:</p>
   * <ul>
   *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>
   *   <li>Burton  S. Garbow</li>
   *   <li>Kenneth E. Hillstrom</li>
   *   <li>Jorge   J. More</li>
   * </ul>
   * <p>Luc Maisonobe did the Java translation.</p>
   *
   * @param qy array containing qTy
   * @param delta upper bound on the euclidean norm of diagR * lmDir
   * @param diag diagonal matrix
   * @param work1 work array
   * @param work2 work array
   * @param work3 work array
   */


  this.determineLMParameter = function (qy, delta, diag, work1, work2, work3) {
    var nC = this.weightedJacobian[0].length; // compute and store in x the gauss-newton direction, if the
    // jacobian is rank-deficient, obtain a least squares solution

    for (var j = 0; j < this.rank; ++j) {
      this.lmDir[this.permutation[j]] = qy[j];
    }

    for (var j = this.rank; j < nC; ++j) {
      this.lmDir[this.permutation[j]] = 0;
    }

    for (var k = this.rank - 1; k >= 0; --k) {
      var pk = this.permutation[k];
      var ypk = this.lmDir[pk] / this.diagR[pk];

      for (var i = 0; i < k; ++i) {
        this.lmDir[this.permutation[i]] -= ypk * this.weightedJacobian[i][pk];
      }

      this.lmDir[pk] = ypk;
    } // evaluate the function at the origin, and test
    // for acceptance of the Gauss-Newton direction


    var dxNorm = 0;

    for (var j = 0; j < this.solvedCols; ++j) {
      var pj = this.permutation[j];
      var s = diag[pj] * this.lmDir[pj];
      work1[pj] = s;
      dxNorm += s * s;
    }

    dxNorm = Math.sqrt(dxNorm);
    var fp = dxNorm - delta;

    if (fp <= 0.1 * delta) {
      this.lmPar = 0;
      return;
    } // if the jacobian is not rank deficient, the Newton step provides
    // a lower bound, parl, for the zero of the function,
    // otherwise set this bound to zero


    var sum2;
    var parl = 0;

    if (this.rank == this.solvedCols) {
      for (var j = 0; j < this.solvedCols; ++j) {
        var pj = this.permutation[j];
        work1[pj] *= diag[pj] / dxNorm;
      }

      sum2 = 0;

      for (var j = 0; j < this.solvedCols; ++j) {
        var pj = this.permutation[j];
        var sum = 0;

        for (var i = 0; i < j; ++i) {
          sum += this.weightedJacobian[i][pj] * work1[this.permutation[i]];
        }

        var s = (work1[pj] - sum) / this.diagR[pj];
        work1[pj] = s;
        sum2 += s * s;
      }

      parl = fp / (delta * sum2);
    } // calculate an upper bound, paru, for the zero of the function


    sum2 = 0;

    for (var j = 0; j < this.solvedCols; ++j) {
      var pj = this.permutation[j];
      var sum = 0;

      for (var i = 0; i <= j; ++i) {
        sum += this.weightedJacobian[i][pj] * qy[i];
      }

      sum /= diag[pj];
      sum2 += sum * sum;
    }

    var gNorm = Math.sqrt(sum2);
    var paru = gNorm / delta;

    if (paru == 0) {
      // 2.2251e-308 is the smallest positive real for IEE754
      paru = 2.2251e-308 / Math.min(delta, 0.1);
    } // if the input par lies outside of the interval (parl,paru),
    // set par to the closer endpoint


    this.lmPar = Math.min(paru, Math.max(this.lmPar, parl));

    if (this.lmPar == 0) {
      this.lmPar = gNorm / dxNorm;
    }

    for (var countdown = 10; countdown >= 0; --countdown) {
      // evaluate the function at the current value of lmPar
      if (this.lmPar == 0) {
        this.lmPar = Math.max(2.2251e-308, 0.001 * paru);
      }

      var sPar = Math.sqrt(this.lmPar);

      for (var j = 0; j < this.solvedCols; ++j) {
        var pj = this.permutation[j];
        work1[pj] = sPar * diag[pj];
      }

      this.determineLMDirection(qy, work1, work2, work3);
      dxNorm = 0;

      for (var j = 0; j < this.solvedCols; ++j) {
        var pj = this.permutation[j];
        var s = diag[pj] * this.lmDir[pj];
        work3[pj] = s;
        dxNorm += s * s;
      }

      dxNorm = Math.sqrt(dxNorm);
      var previousFP = fp;
      fp = dxNorm - delta; // if the function is small enough, accept the current value
      // of lmPar, also test for the exceptional cases where parl is zero

      if (Math.abs(fp) <= 0.1 * delta || parl == 0 && fp <= previousFP && previousFP < 0) {
        return;
      } // compute the Newton correction


      for (var j = 0; j < this.solvedCols; ++j) {
        var pj = this.permutation[j];
        work1[pj] = work3[pj] * diag[pj] / dxNorm;
      }

      for (var j = 0; j < this.solvedCols; ++j) {
        var pj = this.permutation[j];
        work1[pj] /= work2[j];
        var tmp = work1[pj];

        for (var i = j + 1; i < this.solvedCols; ++i) {
          work1[this.permutation[i]] -= this.weightedJacobian[i][pj] * tmp;
        }
      }

      sum2 = 0;

      for (var j = 0; j < this.solvedCols; ++j) {
        var s = work1[this.permutation[j]];
        sum2 += s * s;
      }

      var correction = fp / (delta * sum2); // depending on the sign of the function, update parl or paru.

      if (fp > 0) {
        parl = Math.max(parl, this.lmPar);
      } else if (fp < 0) {
        paru = Math.min(paru, this.lmPar);
      } // compute an improved estimate for lmPar


      this.lmPar = Math.max(parl, this.lmPar + correction);
    }
  };
  /**
   * Solve a*x = b and d*x = 0 in the least squares sense.
   * <p>This implementation is a translation in Java of the MINPACK
   * <a href="http://www.netlib.org/minpack/qrsolv.f">qrsolv</a>
   * routine.</p>
   * <p>This method sets the lmDir and lmDiag attributes.</p>
   * <p>The authors of the original fortran function are:</p>
   * <ul>
   *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>
   *   <li>Burton  S. Garbow</li>
   *   <li>Kenneth E. Hillstrom</li>
   *   <li>Jorge   J. More</li>
   * </ul>
   * <p>Luc Maisonobe did the Java translation.</p>
   *
   * @param qy array containing qTy
   * @param diag diagonal matrix
   * @param lmDiag diagonal elements associated with lmDir
   * @param work work array
   */


  this.determineLMDirection = function (qy, diag, lmDiag, work) {
    // copy R and Qty to preserve input and initialize s
    //  in particular, save the diagonal elements of R in lmDir
    for (var j = 0; j < this.solvedCols; ++j) {
      var pj = this.permutation[j];

      for (var i = j + 1; i < this.solvedCols; ++i) {
        this.weightedJacobian[i][pj] = this.weightedJacobian[j][this.permutation[i]];
      }

      this.lmDir[j] = this.diagR[pj];
      work[j] = qy[j];
    } // eliminate the diagonal matrix d using a Givens rotation


    for (var j = 0; j < this.solvedCols; ++j) {
      // prepare the row of d to be eliminated, locating the
      // diagonal element using p from the Q.R. factorization
      var pj = this.permutation[j];
      var dpj = diag[pj];

      if (dpj != 0) {
        Arrays_fill(lmDiag, j + 1, lmDiag.length, 0);
      }

      lmDiag[j] = dpj; //  the transformations to eliminate the row of d
      // modify only a single element of Qty
      // beyond the first n, which is initially zero.

      var qtbpj = 0;

      for (var k = j; k < this.solvedCols; ++k) {
        var pk = this.permutation[k]; // determine a Givens rotation which eliminates the
        // appropriate element in the current row of d

        if (lmDiag[k] != 0) {
          var sin;
          var cos;
          var rkk = this.weightedJacobian[k][pk];

          if (Math.abs(rkk) < Math.abs(lmDiag[k])) {
            var cotan = rkk / lmDiag[k];
            sin = 1.0 / Math.sqrt(1.0 + cotan * cotan);
            cos = sin * cotan;
          } else {
            var tan = lmDiag[k] / rkk;
            cos = 1.0 / Math.sqrt(1.0 + tan * tan);
            sin = cos * tan;
          } // compute the modified diagonal element of R and
          // the modified element of (Qty,0)


          this.weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];
          var temp = cos * work[k] + sin * qtbpj;
          qtbpj = -sin * work[k] + cos * qtbpj;
          work[k] = temp; // accumulate the tranformation in the row of s

          for (var i = k + 1; i < this.solvedCols; ++i) {
            var rik = this.weightedJacobian[i][pk];
            var temp2 = cos * rik + sin * lmDiag[i];
            lmDiag[i] = -sin * rik + cos * lmDiag[i];
            this.weightedJacobian[i][pk] = temp2;
          }
        }
      } // store the diagonal element of s and restore
      // the corresponding diagonal element of R


      lmDiag[j] = this.weightedJacobian[j][this.permutation[j]];
      this.weightedJacobian[j][this.permutation[j]] = this.lmDir[j];
    } // solve the triangular system for z, if the system is
    // singular, then obtain a least squares solution


    var nSing = this.solvedCols;

    for (var j = 0; j < this.solvedCols; ++j) {
      if (lmDiag[j] == 0 && nSing == this.solvedCols) {
        nSing = j;
      }

      if (nSing < this.solvedCols) {
        work[j] = 0;
      }
    }

    if (nSing > 0) {
      for (var j = nSing - 1; j >= 0; --j) {
        var pj = this.permutation[j];
        var sum = 0;

        for (var i = j + 1; i < nSing; ++i) {
          sum += this.weightedJacobian[i][pj] * work[i];
        }

        work[j] = (work[j] - sum) / lmDiag[j];
      }
    } // permute the components of z back to components of lmDir


    for (var j = 0; j < this.lmDir.length; ++j) {
      this.lmDir[this.permutation[j]] = work[j];
    }
  };
  /**
   * Decompose a matrix A as A.P = Q.R using Householder transforms.
   * <p>As suggested in the P. Lascaux and R. Theodor book
   * <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave;
   * l'art de l'ing&eacute;nieur</i> (Masson, 1986), instead of representing
   * the Householder transforms with u<sub>k</sub> unit vectors such that:
   * <pre>
   * H<sub>k</sub> = I - 2u<sub>k</sub>.u<sub>k</sub><sup>t</sup>
   * </pre>
   * we use <sub>k</sub> non-unit vectors such that:
   * <pre>
   * H<sub>k</sub> = I - beta<sub>k</sub>v<sub>k</sub>.v<sub>k</sub><sup>t</sup>
   * </pre>
   * where v<sub>k</sub> = a<sub>k</sub> - alpha<sub>k</sub> e<sub>k</sub>.
   * The beta<sub>k</sub> coefficients are provided upon exit as recomputing
   * them from the v<sub>k</sub> vectors would be costly.</p>
   * <p>This decomposition handles rank deficient cases since the tranformations
   * are performed in non-increasing columns norms order thanks to columns
   * pivoting. The diagonal elements of the R matrix are therefore also in
   * non-increasing absolute values order.</p>
   *
   * @param jacobian Weighted Jacobian matrix at the current point.
   * @exception ConvergenceException if the decomposition cannot be performed
   */


  this.qrDecomposition = function (jacobian) {
    // Code in this class assumes that the weighted Jacobian is -(W^(1/2) J),
    // hence the multiplication by -1.
    this.weightedJacobian = this.scalarMultiply(jacobian, -1);
    var nR = this.weightedJacobian.length;
    var nC = this.weightedJacobian[0].length; // initializations

    for (var k = 0; k < nC; ++k) {
      this.permutation[k] = k;
      var norm2 = 0;

      for (var i = 0; i < nR; ++i) {
        var akk = this.weightedJacobian[i][k];
        norm2 += akk * akk;
      }

      this.jacNorm[k] = Math.sqrt(norm2);
    } // transform the matrix column after column


    for (var k = 0; k < nC; ++k) {
      // select the column with the greatest norm on active components
      var nextColumn = -1;
      var ak2 = Number.NEGATIVE_INFINITY;

      for (var i = k; i < nC; ++i) {
        var norm2 = 0;

        for (var j = k; j < nR; ++j) {
          var aki = this.weightedJacobian[j][this.permutation[i]];
          norm2 += aki * aki;
        }

        if (!isFinite(norm2)) {
          throw "UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN";
        }

        if (norm2 > ak2) {
          nextColumn = i;
          ak2 = norm2;
        }
      }

      if (ak2 <= this.qrRankingThreshold) {
        this.rank = k;
        return;
      }

      var pk = this.permutation[nextColumn];
      this.permutation[nextColumn] = this.permutation[k];
      this.permutation[k] = pk; // choose alpha such that Hk.u = alpha ek

      var akk = this.weightedJacobian[k][pk];
      var alpha = akk > 0 ? -Math.sqrt(ak2) : Math.sqrt(ak2);
      var betak = 1.0 / (ak2 - akk * alpha);
      this.beta[pk] = betak; // transform the current column

      this.diagR[pk] = alpha;
      this.weightedJacobian[k][pk] -= alpha; // transform the remaining columns

      for (var dk = nC - 1 - k; dk > 0; --dk) {
        var gamma = 0;

        for (var j = k; j < nR; ++j) {
          gamma += this.weightedJacobian[j][pk] * this.weightedJacobian[j][this.permutation[k + dk]];
        }

        gamma *= betak;

        for (var j = k; j < nR; ++j) {
          this.weightedJacobian[j][this.permutation[k + dk]] -= gamma * this.weightedJacobian[j][pk];
        }
      }
    }

    this.rank = this.solvedCols;
  };
  /**
   * Compute the product Qt.y for some Q.R. decomposition.
   *
   * @param y vector to multiply (will be overwritten with the result)
   */


  this.qTy = function (y) {
    var nR = this.weightedJacobian.length;
    var nC = this.weightedJacobian[0].length;

    for (var k = 0; k < nC; ++k) {
      var pk = this.permutation[k];
      var gamma = 0;

      for (var i = k; i < nR; ++i) {
        gamma += this.weightedJacobian[i][pk] * y[i];
      }

      gamma *= this.beta[pk];

      for (var i = k; i < nR; ++i) {
        y[i] -= gamma * this.weightedJacobian[i][pk];
      }
    }
  };
  /**
   * Computes the weighted Jacobian matrix.
   *
   * @param params Model parameters at which to compute the Jacobian.
   * @return the weighted Jacobian: W<sup>1/2</sup> J.
   * @throws DimensionMismatchException if the Jacobian dimension does not
   * match problem dimension.
   */


  this.computeWeightedJacobian = function (params) {
    //        return this.weightMatrixSqrt.multiply(this.jacobian(params));
    //TODO: since weighted matrix is always identity return jacobian itself
    return this.jacobian(params);
  };

  this.scalarMultiply = function (m, s) {
    var rowCount = m.length;
    var columnCount = m[0].length;
    var out = [];

    for (var row = 0; row < rowCount; ++row) {
      out.push([]);

      for (var col = 0; col < columnCount; ++col) {
        out[row].push(m[row][col] * s);
      }
    }

    return out;
  };

  this.operate = function (m, v) {
    var nRows = m.length;
    var nCols = m[0].length;

    if (v.length != nCols) {
      throw "DimensionMismatchException: " + v.length + "!=" + nCols;
    }

    var out = [];

    for (var row = 0; row < nRows; row++) {
      var dataRow = m[row];
      var sum = 0;

      for (var i = 0; i < nCols; i++) {
        sum += dataRow[i] * v[i];
      }

      out[row] = sum;
    }

    return out;
  };
  /**
   * Computes the cost.
   *
   * @param residuals Residuals.
   * @return the cost.
   * @see #computeResiduals(double[])
   */


  this.computeCost = function (residuals) {
    return Math.sqrt(this.dotProduct(residuals, this.operate(this.getWeight(), residuals)));
  };

  this.dotProduct = function (v1, v2) {
    var dot = 0;

    for (var i = 0; i < v1.length; i++) {
      dot += v1[i] * v2[i];
    }

    return dot;
  };
  /**
   * Gets the root-mean-square (RMS) value.
   *
   * The RMS the root of the arithmetic mean of the square of all weighted
   * residuals.
   * This is related to the criterion that is minimized by the optimizer
   * as follows: If <em>c</em> if the criterion, and <em>n</em> is the
   * number of measurements, then the RMS is <em>sqrt (c/n)</em>.
   *
   * @return the RMS value.
   */


  this.getRMS = function () {
    return Math.sqrt(this.getChiSquare() / this.target.length);
  };
  /**
   * Get a Chi-Square-like value assuming the N residuals follow N
   * distinct normal distributions centered on 0 and whose variances are
   * the reciprocal of the weights.
   * @return chi-square value
   */


  this.getChiSquare = function () {
    return this.cost * this.cost;
  };
  /**
   * Gets the square-root of the weight matrix.
   *
   * @return the square-root of the weight matrix.
   */


  this.getWeightSquareRoot = function () {
    return this.weightMatrixSqrt; //.copy(); FIXME for now it's always identity
  };

  this.getWeight = function () {
    return this.weightMatrix; //.copy(); FIXME for now it's always identity
  };
  /**
   * Sets the cost.
   *
   * @param cost Cost value.
   */


  this.setCost = function (cost) {
    this.cost = cost;
  };
  /**
   * Computes the residuals.
   * The residual is the difference between the observed (target)
   * values and the model (objective function) value.
   * There is one residual for each element of the vector-valued
   * function.
   *
   * @param objectiveValue Value of the the objective function. This is
   * the value returned from a call to
   * {@link #computeObjectiveValue(double[]) computeObjectiveValue}
   * (whose array argument contains the model parameters).
   * @return the residuals.
   * @throws DimensionMismatchException if {@code params} has a wrong
   * length.
   */


  this.computeResiduals = function (objectiveValue) {
    var target = this.target;

    if (objectiveValue.length != target.length) {
      throw "DimensionMismatchException: " + target.length + " != " + objectiveValue.length;
    }

    var residuals = arr(target.length);

    for (var i = 0; i < target.length; i++) {
      residuals[i] = target[i] - objectiveValue[i];
    }

    return residuals;
  };

  this.computeObjectiveValue = function (params) {
    if (++this.evalCount > this.evalMaximalCount) {
      throw "TOO MANY FUNCTION EVALUATION";
    }

    return this.model(params);
  };
}

/***/ }),

/***/ "./web/app/math/math.js":
/*!******************************!*\
  !*** ./web/app/math/math.js ***!
  \******************************/
/*! exports provided: TOLERANCE, TOLERANCE_SQ, distanceAB, distance, distanceAB3, distance3, distanceSquaredAB3, distanceSquaredANegB3, distanceSquared3, circleFromPoints, norm2, areEqual, areVectorsEqual, areNegVectorsEqual, areVectorsEqual3, vectorsEqual, equal, strictEqual, strictEqual2D, _vec, _matrix, rotate, rotateInPlace, polygonOffsetXY, polygonOffset, polygonOffsetByDelta, isPointInsidePolygon, area, isCCW, findLowestLeftPoint, makeAngle0_360, perpendicularVector, radiusOfCurvature, DEG_RAD, sq */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOLERANCE", function() { return TOLERANCE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOLERANCE_SQ", function() { return TOLERANCE_SQ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceAB", function() { return distanceAB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceAB3", function() { return distanceAB3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance3", function() { return distance3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceSquaredAB3", function() { return distanceSquaredAB3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceSquaredANegB3", function() { return distanceSquaredANegB3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceSquared3", function() { return distanceSquared3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleFromPoints", function() { return circleFromPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "norm2", function() { return norm2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areEqual", function() { return areEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areVectorsEqual", function() { return areVectorsEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areNegVectorsEqual", function() { return areNegVectorsEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areVectorsEqual3", function() { return areVectorsEqual3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vectorsEqual", function() { return vectorsEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equal", function() { return equal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strictEqual", function() { return strictEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strictEqual2D", function() { return strictEqual2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_vec", function() { return _vec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_matrix", function() { return _matrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateInPlace", function() { return rotateInPlace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polygonOffsetXY", function() { return polygonOffsetXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polygonOffset", function() { return polygonOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polygonOffsetByDelta", function() { return polygonOffsetByDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPointInsidePolygon", function() { return isPointInsidePolygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "area", function() { return area; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCCW", function() { return isCCW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findLowestLeftPoint", function() { return findLowestLeftPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeAngle0_360", function() { return makeAngle0_360; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perpendicularVector", function() { return perpendicularVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radiusOfCurvature", function() { return radiusOfCurvature; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEG_RAD", function() { return DEG_RAD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sq", function() { return sq; });
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
/* harmony import */ var _bbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bbox */ "./web/app/math/bbox.js");
/* harmony import */ var _vec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec */ "./web/app/math/vec.js");



var TOLERANCE = 1E-6;
var TOLERANCE_SQ = TOLERANCE * TOLERANCE;
function distanceAB(a, b) {
  return distance(a.x, a.y, b.x, b.y);
}
function distance(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function distanceAB3(a, b) {
  return distance3(a.x, a.y, a.z, b.x, b.y, b.z);
}
function distance3(x1, y1, z1, x2, y2, z2) {
  return Math.sqrt(distanceSquared3(x1, y1, z1, x2, y2, z2));
}
function distanceSquaredAB3(a, b) {
  return distanceSquared3(a.x, a.y, a.z, b.x, b.y, b.z);
}
function distanceSquaredANegB3(a, b) {
  return distanceSquared3(a.x, a.y, a.z, -b.x, -b.y, -b.z);
}
function distanceSquared3(x1, y1, z1, x2, y2, z2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  var dz = z1 - z2;
  return dx * dx + dy * dy + dz * dz;
}
function circleFromPoints(p1, p2, p3) {
  var center = new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"]();
  var offset = p2.x * p2.x + p2.y * p2.y;
  var bc = (p1.x * p1.x + p1.y * p1.y - offset) / 2.0;
  var cd = (offset - p3.x * p3.x - p3.y * p3.y) / 2.0;
  var det = (p1.x - p2.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p2.y);

  if (Math.abs(det) < TOLERANCE) {
    return null;
  }

  var idet = 1 / det;
  center.x = (bc * (p2.y - p3.y) - cd * (p1.y - p2.y)) * idet;
  center.y = (cd * (p1.x - p2.x) - bc * (p2.x - p3.x)) * idet;
  return center;
}
function norm2(vec) {
  var sq = 0;

  for (var i = 0; i < vec.length; i++) {
    sq += vec[i] * vec[i];
  }

  return Math.sqrt(sq);
}
function areEqual(v1, v2, tolerance) {
  return Math.abs(v1 - v2) < tolerance;
}
function areVectorsEqual(v1, v2, toleranceSQ) {
  return areEqual(distanceSquaredAB3(v1, v2), 0, toleranceSQ);
}
function areNegVectorsEqual(v1, v2, toleranceSQ) {
  return areEqual(distanceSquaredANegB3(v1, v2), 0, toleranceSQ);
}
function areVectorsEqual3(v1, v2, toleranceSQ) {
  return areEqual(distanceSquared3(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2]), 0, toleranceSQ);
}
function vectorsEqual(v1, v2) {
  return areVectorsEqual(v1, v2, TOLERANCE_SQ);
}
function equal(v1, v2) {
  return areEqual(v1, v2, TOLERANCE);
}
function strictEqual(a, b) {
  return a.x == b.x && a.y == b.y && a.z == b.z;
}
function strictEqual2D(a, b) {
  return a.x == b.x && a.y == b.y;
}
function _vec(size) {
  var out = [];
  out.length = size;

  for (var i = 0; i < size; ++i) {
    out[i] = 0;
  }

  return out;
}
function _matrix(m, n) {
  var out = [];
  out.length = m;

  for (var i = 0; i < m; ++i) {
    out[i] = _vec(n);
  }

  return out;
}
function rotate(px, py, angle) {
  return rotateInPlace(px, py, angle, new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"]());
}
function rotateInPlace(px, py, angle, out) {
  out.x = px * Math.cos(angle) - py * Math.sin(angle);
  out.y = px * Math.sin(angle) + py * Math.cos(angle);
  return out;
}
function polygonOffsetXY(polygon, scaleX, scaleY) {
  var origBBox = new _bbox__WEBPACK_IMPORTED_MODULE_1__["default"]();
  var scaledBBox = new _bbox__WEBPACK_IMPORTED_MODULE_1__["default"]();
  var result = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = polygon[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var point = _step.value;
      var scaledPoint = new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](point.x * scaleX, point.y * scaleY);
      result.push(scaledPoint);
      origBBox.checkPoint(point);
      scaledBBox.checkPoint(scaledPoint);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var alignVector = scaledBBox.center()._minus(origBBox.center());

  for (var _i = 0, _result = result; _i < _result.length; _i++) {
    var _point = _result[_i];

    _point._minus(alignVector);
  }

  return result;
}
function polygonOffset(polygon, scale) {
  return polygonOffsetXY(polygon, scale, scale);
}
function polygonOffsetByDelta(polygon, delta) {
  var origBBox = new _bbox__WEBPACK_IMPORTED_MODULE_1__["default"]();
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = polygon[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var point = _step2.value;
      origBBox.checkPoint(point);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var width = origBBox.width();
  var height = origBBox.height();
  return polygonOffsetXY(polygon, (width + delta) / width, (height + delta) / height);
}
function isPointInsidePolygon(inPt, inPolygon) {
  var EPSILON = TOLERANCE;
  var polyLen = inPolygon.length; // inPt on polygon contour => immediate success    or
  // toggling of inside/outside at every single! intersection point of an edge
  //  with the horizontal line through inPt, left of inPt
  //  not counting lowerY endpoints of edges and whole edges on that line

  var inside = false;

  for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
    var edgeLowPt = inPolygon[p];
    var edgeHighPt = inPolygon[q];
    var edgeDx = edgeHighPt.x - edgeLowPt.x;
    var edgeDy = edgeHighPt.y - edgeLowPt.y;

    if (Math.abs(edgeDy) > EPSILON) {
      // not parallel
      if (edgeDy < 0) {
        edgeLowPt = inPolygon[q];
        edgeDx = -edgeDx;
        edgeHighPt = inPolygon[p];
        edgeDy = -edgeDy;
      }

      if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

      if (inPt.y == edgeLowPt.y) {
        if (inPt.x == edgeLowPt.x) return true; // inPt is on contour ?
        // continue;				// no intersection or edgeLowPt => doesn't count !!!
      } else {
        var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
        if (perpEdge == 0) return true; // inPt is on contour ?

        if (perpEdge < 0) continue;
        inside = !inside; // true intersection left of inPt
      }
    } else {
      // parallel or colinear
      if (inPt.y != edgeLowPt.y) continue; // parallel
      // egde lies on the same horizontal line as inPt

      if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
      // continue;
    }
  }

  return inside;
} // http://en.wikipedia.org/wiki/Shoelace_formula

function area(contour) {
  var n = contour.length;
  var a = 0.0;

  for (var p = n - 1, q = 0; q < n; p = q++) {
    a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
  }

  return a * 0.5;
}
function isCCW(path2D) {
  return area(path2D) >= 0;
}
function findLowestLeftPoint(poly) {
  var heroIdx = 0;

  for (var i = 1; i < poly.length; ++i) {
    var point = poly[i];
    var hero = poly[heroIdx];

    if (point.y < hero.y) {
      heroIdx = i;
    } else if (hero.y == point.y) {
      if (point.x < hero.x) {
        heroIdx = i;
      }
    }
  }

  return heroIdx;
}
function makeAngle0_360(angle) {
  angle %= 2 * Math.PI;

  if (angle < 0) {
    angle = 2 * Math.PI + angle;
  }

  return angle;
}
function perpendicularVector(v) {
  v = _vec__WEBPACK_IMPORTED_MODULE_2__["normalize"](v);
  return _vec__WEBPACK_IMPORTED_MODULE_2__["BASIS3"].map(function (axis) {
    return _vec__WEBPACK_IMPORTED_MODULE_2__["cross"](axis, v);
  }).sort(function (a, b) {
    return _vec__WEBPACK_IMPORTED_MODULE_2__["lengthSq"](b) - _vec__WEBPACK_IMPORTED_MODULE_2__["lengthSq"](a);
  })[0];
}
function radiusOfCurvature(d1, d2) {
  var r1lsq = _vec__WEBPACK_IMPORTED_MODULE_2__["lengthSq"](d1);
  var r1l = Math.sqrt(r1lsq);
  return r1lsq * r1l / _vec__WEBPACK_IMPORTED_MODULE_2__["length"](_vec__WEBPACK_IMPORTED_MODULE_2__["cross"](d1, d2));
}
var DEG_RAD = Math.PI / 180.0;
var sq = function sq(a) {
  return a * a;
};

/***/ }),

/***/ "./web/app/math/optim.js":
/*!*******************************!*\
  !*** ./web/app/math/optim.js ***!
  \*******************************/
/*! exports provided: fmin_bfgs, dog_leg, optim */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fmin_bfgs", function() { return fmin_bfgs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dog_leg", function() { return dog_leg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "optim", function() { return optim; });
/* harmony import */ var numeric__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! numeric */ "./node_modules/numeric/numeric-1.2.6.js");
/* harmony import */ var numeric__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(numeric__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./web/app/math/math.js");

 //Added strong wolfe condition to numeric's uncmin

function fmin_bfgs(f, x0, tol, gradient, maxit, callback, options) {
  var grad = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.gradient;

  if (typeof options === "undefined") {
    options = {};
  }

  if (typeof tol === "undefined") {
    tol = 1e-8;
  }

  if (typeof gradient === "undefined") {
    gradient = function gradient(x) {
      return grad(f, x);
    };
  }

  if (typeof maxit === "undefined") maxit = 1000;
  x0 = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.clone(x0);
  var n = x0.length;
  var f0 = f(x0),
      f1,
      df0;
  if (isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
  var max = Math.max,
      norm2 = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.norm2;
  tol = max(tol, numeric__WEBPACK_IMPORTED_MODULE_0___default.a.epsilon);
  var step,
      g0,
      g1,
      H1 = options.Hinv || numeric__WEBPACK_IMPORTED_MODULE_0___default.a.identity(n);
  var dot = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.dot,
      inv = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.inv,
      sub = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.sub,
      add = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.add,
      ten = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.tensor,
      div = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.div,
      mul = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.mul;
  var all = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.all,
      isfinite = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.isFinite,
      neg = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.neg;
  var it = 0,
      i,
      s,
      x1,
      y,
      Hy,
      Hs,
      ys,
      i0,
      t,
      nstep,
      t1,
      t2;
  var msg = "";
  g0 = gradient(x0);

  while (it < maxit) {
    if (typeof callback === "function") {
      if (callback(it, x0, f0, g0, H1)) {
        msg = "Callback returned true";
        break;
      }
    }

    if (!all(isfinite(g0))) {
      msg = "Gradient has Infinity or NaN";
      break;
    }

    step = neg(dot(H1, g0));

    if (!all(isfinite(step))) {
      msg = "Search direction has Infinity or NaN";
      break;
    }

    nstep = norm2(step);

    if (nstep < tol) {
      msg = "Newton step smaller than tol";
      break;
    }

    t = 1;
    df0 = dot(g0, step); // line search

    x1 = x0;
    var tL = 0;
    var tR = 100;

    while (it < maxit) {
      if (t * nstep < tol) {
        break;
      }

      s = mul(step, t);
      x1 = add(x0, s);
      f1 = f(x1); //Nocadel, 3.7(a,b)

      if (f1 - f0 >= 0.1 * t * df0 || isNaN(f1)) {
        tR = t;
        t = (tL + tR) * 0.5;
        ++it;
      } else {
        var slope = dot(gradient(x1), step);

        if (slope <= 0.9 * Math.abs(df0)) {
          break;
        } else if (slope >= 0.9 * df0) {
          tR = t;
          t = (tL + tR) * 0.5;
        } else {
          tL = t;
          t = (tL + tR) * 0.5;
        }
      }
    }

    if (t * nstep < tol) {
      msg = "Line search step size smaller than tol";
      break;
    }

    if (it === maxit) {
      msg = "maxit reached during line search";
      break;
    }

    g1 = gradient(x1);
    y = sub(g1, g0);
    ys = dot(y, s);
    Hy = dot(H1, y); // BFGS update on H1

    H1 = sub(add(H1, mul((ys + dot(y, Hy)) / (ys * ys), ten(s, s))), div(add(ten(Hy, s), ten(s, Hy)), ys));
    x0 = x1;
    f0 = f1;
    g0 = g1;
    ++it;
  }

  return {
    solution: x0,
    f: f0,
    gradient: g0,
    invHessian: H1,
    iterations: it,
    message: msg
  };
}
;

var bfgs = function bfgs(f, x0, tol, gradient, maxit, callback, options) {
  var grad = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.gradient;

  if (typeof options === "undefined") {
    options = {};
  }

  if (typeof tol === "undefined") {
    tol = 1e-8;
  }

  if (typeof gradient === "undefined") {
    gradient = function gradient(x) {
      return grad(f, x);
    };
  }

  if (typeof maxit === "undefined") maxit = 1000;
  x0 = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.clone(x0);
  var n = x0.length;
  var f0 = f(x0),
      f1,
      df0;
  if (isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
  var max = Math.max,
      norm2 = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.norm2;
  tol = max(tol, numeric__WEBPACK_IMPORTED_MODULE_0___default.a.epsilon);
  var step,
      g0,
      g1,
      H1 = options.Hinv || numeric__WEBPACK_IMPORTED_MODULE_0___default.a.identity(n);
  var dot = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.dot,
      inv = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.inv,
      sub = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.sub,
      add = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.add,
      ten = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.tensor,
      div = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.div,
      mul = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.mul;
  var all = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.all,
      isfinite = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.isFinite,
      neg = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.neg;
  var it = 0,
      i,
      s,
      x1,
      y,
      Hy,
      Hs,
      ys,
      i0,
      t,
      nstep,
      t1,
      t2;
  var msg = "";
  g0 = gradient(x0);

  while (it < maxit) {
    if (typeof callback === "function") {
      if (callback(it, x0, f0, g0, H1)) {
        msg = "Callback returned true";
        break;
      }
    }

    if (!all(isfinite(g0))) {
      msg = "Gradient has Infinity or NaN";
      break;
    }

    step = neg(dot(H1, g0));

    if (!all(isfinite(step))) {
      msg = "Search direction has Infinity or NaN";
      break;
    }

    nstep = norm2(step);

    if (nstep < tol) {
      msg = "Newton step smaller than tol";
      break;
    }

    df0 = dot(g0, step); // line search

    t1 = 0.0;
    f1 = f0;
    t2 = 1.0;
    s = mul(step, t2);
    x1 = add(x0, s);
    var f2 = f(x1);
    var t3 = 2.0;
    s = mul(step, t3);
    x1 = add(x0, s);
    var f3 = f(x1);
    var tMax = 1e23;

    while ((f2 > f1 || f2 > f3) && it < maxit) {
      if (t * nstep < tol) {
        break;
      }

      if (f2 > f1) {
        //If f2 is greater than f1 then we shorten alpha2 and alpha3 closer to f1
        //Effectively both are shortened by a factor of two.
        t3 = t2;
        f3 = f2;
        t2 = t2 / 2;
        s = mul(step, t2);
        x1 = add(x0, s);
        f2 = f(x1);
      } else if (f2 > f3) {
        if (t3 >= tMax) break; //If f2 is greater than f3 then we increase alpha2 and alpha3 away from f1
        //Effectively both are lengthened by a factor of two.

        t2 = t3;
        f2 = f3;
        t3 = t3 * 2;
        s = mul(step, t3);
        x1 = add(x0, s);
        f3 = f(x1);
      }

      it++;
    } //Get the alpha for the minimum f of the quadratic approximation


    var ts = t2 + (t2 - t1) * (f1 - f3) / (3 * (f1 - 2 * f2 + f3)); //Guarantee that the new alphaStar is within the bracket

    if (ts >= t3 || ts <= t1) ts = t2;
    if (ts > tMax) ts = tMax;
    if (ts != ts) ts = 0.; //Take a final step to alphaStar

    s = mul(step, ts);
    x1 = add(x0, s);
    f1 = f(x1);

    if (t * nstep < tol) {
      msg = "Line search step size smaller than tol";
      break;
    }

    if (it === maxit) {
      msg = "maxit reached during line search";
      break;
    }

    g1 = gradient(x1);
    y = sub(g1, g0);
    ys = dot(y, s);
    Hy = dot(H1, y); // BFGS update on H1

    H1 = sub(add(H1, mul((ys + dot(y, Hy)) / (ys * ys), ten(s, s))), div(add(ten(Hy, s), ten(s, Hy)), ys));
    x0 = x1;
    f0 = f1;
    g0 = g1;
    ++it;
  }

  return {
    solution: x0,
    f: f0,
    gradient: g0,
    invHessian: H1,
    iterations: it,
    message: msg
  };
};

var bfgs_updater = function bfgs_updater(gradient, x0) {
  var n = x0.length;
  var max = Math.max,
      norm2 = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.norm2;
  var g0,
      g1,
      H1 = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.identity(n);
  var dot = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.dot,
      inv = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.inv,
      sub = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.sub,
      add = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.add,
      ten = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.tensor,
      div = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.div,
      mul = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.mul;
  var all = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.all,
      isfinite = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.isFinite,
      neg = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.neg;
  var y, Hy, Hs, ys;
  var msg = "";
  g0 = gradient(x0);

  function step() {
    return neg(dot(H1, g0));
  }

  function update(x, real_step) {
    var s = real_step;
    g1 = gradient(x);
    y = sub(g1, g0);
    ys = dot(y, s);
    Hy = dot(H1, y); // BFGS update on H1

    H1 = sub(add(H1, mul((ys + dot(y, Hy)) / (ys * ys), ten(s, s))), div(add(ten(Hy, s), ten(s, Hy)), ys));
    g0 = g1;
  }

  return {
    step: step,
    update: update
  };
};

var inv = function inv(A) {
  A = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.clone(A);
  var s = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.dim(A),
      abs = Math.abs,
      m = s[0],
      n = s[1];
  var Ai, Aj;
  var I = numeric__WEBPACK_IMPORTED_MODULE_0___default.a.identity(m),
      Ii,
      Ij;
  var i, j, k, x;

  for (j = 0; j < n; ++j) {
    var i0 = -1;
    var v0 = -1;

    for (i = j; i !== m; ++i) {
      k = abs(A[i][j]);

      if (k > v0) {
        i0 = i;
        v0 = k;
      }
    }

    Aj = A[i0];
    A[i0] = A[j];
    A[j] = Aj;
    Ij = I[i0];
    I[i0] = I[j];
    I[j] = Ij;
    x = Aj[j];

    if (x === 0) {
      console.log("CAN' INVERSE MATRIX");
      x = 1e-32;
    }

    for (k = j; k !== n; ++k) {
      Aj[k] /= x;
    }

    for (k = n - 1; k !== -1; --k) {
      Ij[k] /= x;
    }

    for (i = m - 1; i !== -1; --i) {
      if (i !== j) {
        Ai = A[i];
        Ii = I[i];
        x = Ai[j];

        for (k = j + 1; k !== n; ++k) {
          Ai[k] -= Aj[k] * x;
        }

        for (k = n - 1; k > 0; --k) {
          Ii[k] -= Ij[k] * x;
          --k;
          Ii[k] -= Ij[k] * x;
        }

        if (k === 0) Ii[0] -= Ij[0] * x;
      }
    }
  }

  return I;
};

var _result = function _result(evalCount, error, returnCode) {
  this.evalCount = evalCount;
  this.error = error;
  this.returnCode = returnCode;
};

var dog_leg = function dog_leg(subsys, rough) {
  //rough = true
  //var tolg = rough ? 1e-3 : 1e-4;
  var tolg, tolf;

  if (rough) {
    tolg = 1e-3;
    tolf = 1e-3;
  } else {
    tolg = 1e-6;
    tolf = 1e-6;
  }

  var tolx = 1e-80;
  var xsize = subsys.params.length;
  var csize = subsys.constraints.length;

  if (xsize == 0) {
    return new _result(0, 0, 1);
  }

  var vec = _math__WEBPACK_IMPORTED_MODULE_1__["_vec"];
  var mx = _math__WEBPACK_IMPORTED_MODULE_1__["_matrix"];
  var n = numeric__WEBPACK_IMPORTED_MODULE_0___default.a;
  var x = vec(xsize);
  var x_new = vec(xsize);
  var fx = vec(csize);
  var fx_new = vec(csize);
  var J = mx(csize, xsize);
  var J_new = mx(csize, xsize);
  var gn_step = vec(xsize);
  var dl_step = vec(xsize);
  subsys.fillParams(x);
  var err = subsys.calcResidual(fx);
  subsys.fillJacobian(J);

  function lsolve_slow(A, b) {
    var At = n.transpose(A);
    var res = n.dot(n.dot(At, inv(n.dot(A, At))), b);
    return res;
  }

  function lsolve(A, b) {
    if (csize < xsize) {
      var At = n.transpose(A);
      var sol = n.solve(n.dot(A, At), b, true);
      return n.dot(At, sol);
    } else {
      return n.solve(A, b, false);
    }
  }

  var g = n.dot(n.transpose(J), fx);
  var g_inf = n.norminf(g);
  var fx_inf = n.norminf(fx);
  var iterLimit = 100;
  var divergenceLimit = 1e6 * (err + 1e6);
  var delta = 10;
  var alpha = 0.;
  var iter = 0,
      returnCode = 0; //var log = [];

  var SUCCESS = 1,
      ITER_LIMIT = 2,
      SMALL_DELTA = 3,
      SMALL_STEP = 4,
      DIVERGENCE = 5,
      INVALID_STATE = 6;

  while (returnCode === 0) {
    optim.DEBUG_HANDLER(iter, err);

    if (fx_inf <= tolf) {
      returnCode = SUCCESS;
    } else if (g_inf <= tolg) {
      returnCode = SUCCESS;
    } else if (iter >= iterLimit) {
      returnCode = ITER_LIMIT;
    } else if (delta <= tolx * (tolx + n.norm2(x))) {
      returnCode = SMALL_DELTA;
    } else if (err > divergenceLimit) {
      returnCode = DIVERGENCE;
    } else if (isNaN(err)) {
      returnCode = INVALID_STATE;
    }

    if (returnCode != 0) {
      break;
    } // get the gauss-newton step
    //gn_step = n.solve(J, n.mul(fx, -1));


    gn_step = lsolve(J, n.mul(fx, -1)); //LU-Decomposition
    //gn_step = lusolve(J, n.mul(fx, -1));
    //Conjugate gradient method
    //gn_step = cg(J, gn_step, n.mul(fx, -1), 1e-8, iterLimit);
    //solve linear problem using svd formula to get the gauss-newton step
    //gn_step = lls(J, n.mul(fx, -1));

    var hitBoundary = false;
    var gnorm = n.norm2(g);
    var gnNorm = n.norm2(gn_step);

    if (gnNorm < delta) {
      dl_step = gn_step;
    } else {
      var Jt = n.transpose(J);
      var B = n.dot(Jt, J);
      var gBg = n.dot(g, n.dot(B, g));
      alpha = n.norm2Squared(g) / gBg;

      if (alpha * gnorm >= delta) {
        dl_step = n.mul(g, -delta / gnorm);
        hitBoundary = true;
      } else {
        var sd_step = n.mul(g, -alpha);

        if (isNaN(gnNorm)) {
          dl_step = sd_step;
        } else {
          var d = n.sub(gn_step, sd_step);
          var a = n.dot(d, d);
          var b = 2 * n.dot(sd_step, d);
          var c = n.dot(sd_step, sd_step) - delta * delta;
          var sqrt_discriminant = Math.sqrt(b * b - 4 * a * c);
          var beta = (-b + sqrt_discriminant) / (2 * a);
          dl_step = n.add(sd_step, n.mul(beta, d));
          hitBoundary = true;
        }
      }
    }

    var dl_norm = n.norm2(dl_step); //    if (dl_norm <= tolx) {
    //      returnCode = SMALL_STEP;
    //      break;
    //    }

    x_new = n.add(x, dl_step);
    subsys.setParams(x_new);
    var err_new = subsys.calcResidual(fx_new);
    subsys.fillJacobian(J_new);
    var fxNormSq = n.norm2Squared(fx);
    var dF = fxNormSq - n.norm2Squared(fx_new);
    var dL = fxNormSq - n.norm2Squared(n.add(fx, n.dot(J, dl_step)));
    var acceptCandidate;

    if (dF == 0 || dL == 0) {
      acceptCandidate = true;
    } else {
      var rho = dF / dL;

      if (rho < 0.25) {
        // if the model is a poor predictor reduce the size of the trust region
        delta = 0.25 * dl_norm; //delta *= 0.5;
      } else {
        // only increase the size of the trust region if it is taking a step of maximum size
        // otherwise just assume it's doing good enough job
        if (rho > 0.75 && hitBoundary) {
          //delta = Math.max(delta,3*dl_norm);
          delta *= 2;
        }
      }

      acceptCandidate = rho > 0; // could be 0 .. 0.25
    } //log.push([stepKind,err,  delta,rho]);


    if (acceptCandidate) {
      x = n.clone(x_new);
      J = n.clone(J_new);
      fx = n.clone(fx_new);
      err = err_new;
      g = n.dot(n.transpose(J), fx); // get infinity norms

      g_inf = n.norminf(g);
      fx_inf = n.norminf(fx);
    }

    iter++;
  } //log.push(returnCode);
  //window.___log(log);


  return new _result(iter, err, returnCode);
};

var cg = function cg(A, x, b, tol, maxIt) {
  var _ = numeric__WEBPACK_IMPORTED_MODULE_0___default.a;
  var tr = _.transpose;
  var At = tr(A);

  if (A.length != A[0].length) {
    A = _.dot(At, A);
    b = _.dot(At, b);
  }

  var r = _.sub(_.dot(A, x), b);

  var p = _.mul(r, -1);

  var rr = _.dotVV(r, r);

  var a;

  var _rr;

  var beta;

  for (var i = 0; i < maxIt; ++i) {
    if (_.norm2(r) <= tol) break;

    var Axp = _.dot(A, p);

    a = rr / _.dotVV(Axp, p);
    x = _.add(x, _.mul(p, a));
    r = _.add(r, _.mul(Axp, a));
    _rr = rr;
    rr = _.dotVV(r, r);
    beta = rr / _rr;
    p = _.add(_.mul(r, -1), _.mul(p, beta));
  } //  console.log("liner problem solved in " + i);


  return x;
};

var optim = {
  DEBUG_HANDLER: function DEBUG_HANDLER() {}
}; //backward compatibility



/***/ }),

/***/ "./web/app/math/qr.js":
/*!****************************!*\
  !*** ./web/app/math/qr.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ "./web/app/utils/utils.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./web/app/math/math.js");


/** @constructor */

function QR(matrix) {
  var vec = _math__WEBPACK_IMPORTED_MODULE_1__["_vec"];
  this.matrix = matrix;
  var nR = this.matrix.length;
  var nC = nR == 0 ? 0 : this.matrix[0].length;
  this.qrRankingThreshold = 1e-30; //??

  this.solvedCols = Math.min(nR, nC);
  this.diagR = vec(nC);
  this.norm = vec(nC);
  this.beta = vec(nC);
  this.permutation = vec(nC);
  this.rank = null;
  var k;
  var norm2;
  var akk;
  var j;
  var i; // initializations

  for (k = 0; k < nC; ++k) {
    this.permutation[k] = k;
    norm2 = 0;

    for (i = 0; i < nR; ++i) {
      akk = matrix[i][k];
      norm2 += akk * akk;
    }

    this.norm[k] = Math.sqrt(norm2);
  } // transform the matrix column after column


  for (k = 0; k < nC; ++k) {
    // select the column with the greatest norm on active components
    var nextColumn = -1;
    var ak2 = Number.NEGATIVE_INFINITY;

    for (i = k; i < nC; ++i) {
      norm2 = 0;

      for (j = k; j < nR; ++j) {
        var aki = matrix[j][this.permutation[i]];
        norm2 += aki * aki;
      }

      if (!isFinite(norm2)) {
        throw "UNABLE_TO_PERFORM_QR_DECOMPOSITION";
      }

      if (norm2 > ak2) {
        nextColumn = i;
        ak2 = norm2;
      }
    }

    if (ak2 <= this.qrRankingThreshold) {
      this.rank = k;
      return;
    }

    var pk = this.permutation[nextColumn];
    this.permutation[nextColumn] = this.permutation[k];
    this.permutation[k] = pk; // choose alpha such that Hk.u = alpha ek

    akk = matrix[k][pk];
    var alpha = akk > 0 ? -Math.sqrt(ak2) : Math.sqrt(ak2);
    var betak = 1.0 / (ak2 - akk * alpha);
    this.beta[pk] = betak; // transform the current column

    this.diagR[pk] = alpha;
    matrix[k][pk] -= alpha; // transform the remaining columns

    for (var dk = nC - 1 - k; dk > 0; --dk) {
      var gamma = 0;

      for (j = k; j < nR; ++j) {
        gamma += matrix[j][pk] * matrix[j][this.permutation[k + dk]];
      }

      gamma *= betak;

      for (j = k; j < nR; ++j) {
        matrix[j][this.permutation[k + dk]] -= gamma * matrix[j][pk];
      }
    }
  }

  this.rank = this.solvedCols;
}

QR.prototype.qTy = function (y) {
  var nR = this.matrix.length;
  var nC = this.matrix[0].length;

  for (var k = 0; k < nC; ++k) {
    var pk = this.permutation[k];
    var gamma = 0;

    for (var i = k; i < nR; ++i) {
      gamma += this.matrix[i][pk] * y[i];
    }

    gamma *= this.beta[pk];

    for (var i = k; i < nR; ++i) {
      y[i] -= gamma * this.matrix[i][pk];
    }
  }
};

QR.prototype.solve = function (qy) {
  var nR = this.matrix.length;
  var nC = this.matrix[0].length;
  var vec = _math__WEBPACK_IMPORTED_MODULE_1__["_vec"];
  var diag = vec(nC);
  var lmDiag = vec(nC);
  var work = vec(nC);
  var out = vec(nC); // copy R and Qty to preserve input and initialize s
  //  in particular, save the diagonal elements of R in lmDir

  for (var j = 0; j < this.solvedCols; ++j) {
    var pj = this.permutation[j];

    for (var i = j + 1; i < this.solvedCols; ++i) {
      this.matrix[i][pj] = this.matrix[j][this.permutation[i]];
    }

    out[j] = this.diagR[pj];
    work[j] = qy[j];
  } // eliminate the diagonal matrix d using a Givens rotation


  for (var j = 0; j < this.solvedCols; ++j) {
    // prepare the row of d to be eliminated, locating the
    // diagonal element using p from the Q.R. factorization
    var pj = this.permutation[j];
    var dpj = diag[pj];

    if (dpj != 0) {
      Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__["fillArray"])(lmDiag, j + 1, lmDiag.length, 0);
    }

    lmDiag[j] = dpj; //  the transformations to eliminate the row of d
    // modify only a single element of Qty
    // beyond the first n, which is initially zero.

    var qtbpj = 0;

    for (var k = j; k < this.solvedCols; ++k) {
      var pk = this.permutation[k]; // determine a Givens rotation which eliminates the
      // appropriate element in the current row of d

      if (lmDiag[k] != 0) {
        var sin;
        var cos;
        var rkk = this.matrix[k][pk];

        if (Math.abs(rkk) < Math.abs(lmDiag[k])) {
          var cotan = rkk / lmDiag[k];
          sin = 1.0 / Math.sqrt(1.0 + cotan * cotan);
          cos = sin * cotan;
        } else {
          var tan = lmDiag[k] / rkk;
          cos = 1.0 / Math.sqrt(1.0 + tan * tan);
          sin = cos * tan;
        } // compute the modified diagonal element of R and
        // the modified element of (Qty,0)


        this.matrix[k][pk] = cos * rkk + sin * lmDiag[k];
        var temp = cos * work[k] + sin * qtbpj;
        qtbpj = -sin * work[k] + cos * qtbpj;
        work[k] = temp; // accumulate the tranformation in the row of s

        for (var i = k + 1; i < this.solvedCols; ++i) {
          var rik = this.matrix[i][pk];
          var temp2 = cos * rik + sin * lmDiag[i];
          lmDiag[i] = -sin * rik + cos * lmDiag[i];
          this.matrix[i][pk] = temp2;
        }
      }
    } // store the diagonal element of s and restore
    // the corresponding diagonal element of R


    lmDiag[j] = this.matrix[j][this.permutation[j]];
    this.matrix[j][this.permutation[j]] = out[j];
  } // solve the triangular system for z, if the system is
  // singular, then obtain a least squares solution


  var nSing = this.solvedCols;

  for (var j = 0; j < this.solvedCols; ++j) {
    if (lmDiag[j] == 0 && nSing == this.solvedCols) {
      nSing = j;
    }

    if (nSing < this.solvedCols) {
      work[j] = 0;
    }
  }

  if (nSing > 0) {
    for (var j = nSing - 1; j >= 0; --j) {
      var pj = this.permutation[j];
      var sum = 0;

      for (var i = j + 1; i < nSing; ++i) {
        sum += this.matrix[i][pj] * work[i];
      }

      work[j] = (work[j] - sum) / lmDiag[j];
    }
  } // permute the components of z back to components of lmDir


  for (var j = 0; j < out.length; ++j) {
    out[this.permutation[j]] = work[j];
  }

  return out;
};

/* harmony default export */ __webpack_exports__["default"] = (QR);

/***/ }),

/***/ "./web/app/math/vec.js":
/*!*****************************!*\
  !*** ./web/app/math/vec.js ***!
  \*****************************/
/*! exports provided: dotVM, __mul, _mul, mul, __div, _div, div, __add, _add, add, __sub, _sub, sub, __negate, _negate, negate, dot, __cross, cross, __normalize, _normalize, normalize, lengthSq, length, copy, clone, create, newVector, distanceSq, distance, normal3, polynomial, AXIS_X3, AXIS_Y3, AXIS_Z3, ORIGIN3, BASIS3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__mul", function() { return __mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_mul", function() { return _mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__div", function() { return __div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_div", function() { return _div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__add", function() { return __add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_add", function() { return _add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__sub", function() { return __sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_sub", function() { return _sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__negate", function() { return __negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_negate", function() { return _negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__cross", function() { return __cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__normalize", function() { return __normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_normalize", function() { return _normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lengthSq", function() { return lengthSq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newVector", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distanceSq", function() { return distanceSq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normal3", function() { return normal3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polynomial", function() { return polynomial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AXIS_X3", function() { return AXIS_X3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AXIS_Y3", function() { return AXIS_Y3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AXIS_Z3", function() { return AXIS_Z3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORIGIN3", function() { return ORIGIN3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASIS3", function() { return BASIS3; });
/* harmony import */ var numeric__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! numeric */ "./node_modules/numeric/numeric-1.2.6.js");
/* harmony import */ var numeric__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(numeric__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dotVM", function() { return numeric__WEBPACK_IMPORTED_MODULE_0__["dotVM"]; });



function scalarOperand(v, out, func) {
  for (var i = 0; i < v.length; i++) {
    out[i] = func(v[i]);
  }

  return out;
}

function vectorOperand(v1, v2, out, func) {
  for (var i = 0; i < v1.length; i++) {
    out[i] = func(v1[i], v2[i]);
  }

  return out;
}

function __mul(v, scalar, out) {
  return scalarOperand(v, out, function (x) {
    return x * scalar;
  });
}
function _mul(v, scalar) {
  return __mul(v, scalar, v);
}
function mul(v, scalar) {
  return __mul(v, scalar, []);
}
function __div(v, scalar, out) {
  return scalarOperand(v, out, function (x) {
    return x / scalar;
  });
}
function _div(v, scalar) {
  return __div(v, scalar, v);
}
function div(v, scalar) {
  return __div(v, scalar, []);
}
function __add(v1, v2, out) {
  return vectorOperand(v1, v2, out, function (x1, x2) {
    return x1 + x2;
  });
}
function _add(v1, v2) {
  return __add(v1, v2, v1);
}
function add(v1, v2) {
  return __add(v1, v2, []);
}
function __sub(v1, v2, out) {
  return vectorOperand(v1, v2, out, function (x1, x2) {
    return x1 - x2;
  });
}
function _sub(v1, v2) {
  return __sub(v1, v2, v1);
}
function sub(v1, v2) {
  return __sub(v1, v2, []);
}
function __negate(v, out) {
  return scalarOperand(v, out, function (x) {
    return -x;
  });
}
function _negate(v) {
  return __negate(v, v);
}
function negate(v) {
  return __negate(v, []);
}
function dot(v1, v2) {
  var sum = 0;

  for (var i = 0; i < v1.length; i++) {
    sum += v1[i] * v2[i];
  }

  return sum;
}
function __cross(v1, v2, out) {
  out[0] = v1[1] * v2[2] - v1[2] * v2[1];
  out[1] = v1[2] * v2[0] - v1[0] * v2[2];
  out[2] = v1[0] * v2[1] - v1[1] * v2[0];
  return out;
}
function cross(v1, v2) {
  return __cross(v1, v2, []);
}
function __normalize(v, out) {
  var mag = length(v);

  if (mag === 0.0) {
    out[0] = out[1] = out[2] = 0;
  }

  return __div(v, mag, out);
}
function _normalize(v) {
  return __normalize(v, v);
}
function normalize(v) {
  return __normalize(v, []);
}
function lengthSq(v) {
  return dot(v, v);
}
function length(v) {
  return Math.sqrt(lengthSq(v));
}
function copy(to, from) {
  for (var i = 0; i < v.length; i++) {
    to[i] = from(v[i]);
  }

  return to;
}
function clone(v) {
  return copy(create(v.length), v);
}
function create(dim) {
  var out = [];

  for (var i = 0; i < dim; i++) {
    out[i] = 0;
  }

  return out;
}


var sq = function sq(v) {
  return v * v;
};

function distanceSq(v1, v2) {
  var dSq = 0;

  for (var i = 0; i < v1.length; i++) {
    dSq += sq(v1[i] - v2[i]);
  }

  return dSq;
}
function distance(v1, v2) {
  return Math.sqrt(distanceSq(v1, v2));
}
function normal3(ccwSequence) {
  var a = ccwSequence[0];
  var b = ccwSequence[1];
  var c = ccwSequence[2];
  return _normalize(cross(sub(b, a), sub(c, a)));
}
function polynomial(coefs, vectors) {
  var out = [];
  out.length = vectors[0].length;
  out.fill(0);

  for (var i = 0; i < vectors.length; i++) {
    for (var j = 0; j < out.length; j++) {
      out[j] += vectors[i][j] * coefs[i];
    }
  }

  return out;
}
var AXIS_X3 = [1, 0, 0];
var AXIS_Y3 = [0, 1, 0];
var AXIS_Z3 = [0, 0, 1];
var ORIGIN3 = [0, 0, 0];
var BASIS3 = [AXIS_X3, AXIS_Y3, AXIS_Z3];

/***/ }),

/***/ "./web/app/sketcher.js":
/*!*****************************!*\
  !*** ./web/app/sketcher.js ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sketcher_sketcher_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sketcher/sketcher-app */ "./web/app/sketcher/sketcher-app.js");
/* harmony import */ var _sketcher_styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sketcher/styles */ "./web/app/sketcher/styles.js");
/* harmony import */ var _sketcher_viewer2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sketcher/viewer2d */ "./web/app/sketcher/viewer2d.js");
/* harmony import */ var _ui_ui_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ui/ui.js */ "./web/app/ui/ui.js");
/* harmony import */ var _ui_toolkit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ui/toolkit */ "./web/app/ui/toolkit.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/utils */ "./web/app/utils/utils.js");
/* harmony import */ var _sketcher_parametric__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sketcher/parametric */ "./web/app/sketcher/parametric.js");
/* harmony import */ var _utils_jqueryfy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/jqueryfy */ "./web/app/utils/jqueryfy.js");
/* harmony import */ var _css_app_less__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../css/app.less */ "./web/css/app.less");
/* harmony import */ var _css_app_less__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_css_app_less__WEBPACK_IMPORTED_MODULE_8__);










function initializeSketcherApplication() {
  var app = new _sketcher_sketcher_app__WEBPACK_IMPORTED_MODULE_0__["default"]();
  window.__CAD_APP = app;
  var sketchId = app.getSketchId();

  if (sketchId == _sketcher_sketcher_app__WEBPACK_IMPORTED_MODULE_0__["default"].STORAGE_PREFIX + '__sample2D__') {
    var sample = '{"layers":[{"name":"_dim","style":{"lineWidth":1,"strokeStyle":"#bcffc1","fillStyle":"#00FF00"},"data":[{"id":0,"_class":"TCAD.TWO.DiameterDimension","obj":90},{"id":1,"_class":"TCAD.TWO.DiameterDimension","obj":95},{"id":2,"_class":"TCAD.TWO.DiameterDimension","obj":42},{"id":3,"_class":"TCAD.TWO.Dimension","a":5,"b":8,"flip":false},{"id":4,"_class":"TCAD.TWO.DiameterDimension","obj":105}]},{"name":"sketch","style":{"lineWidth":2,"strokeStyle":"#ffffff","fillStyle":"#000000"},"data":[{"id":11,"_class":"TCAD.TWO.Segment","points":[[5,[6,110.1295615870824],[7,313.66509156975803]],[8,[9,419.44198895058975],[10,516.7065215258621]]]},{"id":18,"_class":"TCAD.TWO.Segment","points":[[12,[13,489.1218947877601],[14,477.98601743930897]],[15,[16,481.90945628911174],[17,182.9391540301952]]]},{"id":25,"_class":"TCAD.TWO.Segment","points":[[19,[20,427.6872468325118],[21,163.96220645927505]],[22,[23,349.9023145352797],[24,256.7344291384989]]]},{"id":32,"_class":"TCAD.TWO.Segment","points":[[26,[27,306.81261277555075],[28,273.1404656521002]],[29,[30,135.09050734792822],[31,247.98348666778958]]]},{"id":42,"_class":"TCAD.TWO.Arc","points":[[33,[34,489.1218947877601],[35,477.98601743930897]],[36,[37,419.44198895058975],[38,516.7065215258621]],[39,[40,444.1353623657045],[41,479.08688157090376]]]},{"id":53,"_class":"TCAD.TWO.Arc","points":[[44,[45,427.6872468325118],[46,163.96220645927505]],[47,[48,481.90945628911174],[49,182.9391540301952]],[50,[51,451.2148840882273],[52,183.68960424767275]]]},{"id":64,"_class":"TCAD.TWO.Arc","points":[[55,[56,349.9023145352797],[57,256.7344291384989]],[58,[59,306.81261277555075],[60,273.1404656521002]],[61,[62,313.6665992835383],[63,226.35256652594512]]]},{"id":75,"_class":"TCAD.TWO.Arc","points":[[66,[67,110.1295615870824],[68,313.66509156975803]],[69,[70,135.09050734792822],[71,247.98348666778958]],[72,[73,129.8749213918784],[74,283.58516027516237]]]},{"id":80,"_class":"TCAD.TWO.Circle","c":[77,[78,444.1353623657045],[79,479.08688157090376]],"r":17},{"id":85,"_class":"TCAD.TWO.Circle","c":[82,[83,451.2148840882273],[84,183.68960424767275]],"r":17},{"id":90,"_class":"TCAD.TWO.Circle","c":[87,[88,129.8749213918784],[89,283.58516027516237]],"r":17},{"id":95,"_class":"TCAD.TWO.Circle","c":[92,[93,364.7627927122075],[94,358.27520724354514]],"r":50},{"id":100,"_class":"TCAD.TWO.Circle","c":[97,[98,450.6425914465028],[99,356.1758703461729]],"r":13},{"id":105,"_class":"TCAD.TWO.Circle","c":[102,[103,281.1241663120215],[104,360.3197585470608]],"r":13}]},{"name":"_construction_","style":{"lineWidth":1,"strokeStyle":"#aaaaaa","fillStyle":"#000000"},"data":[{"id":113,"_class":"TCAD.TWO.Segment","points":[[107,[108,366.96497096679207],[109,448.36204633886825]],[110,[111,362.6842565514955],[112,273.2463262825022]]]},{"id":120,"_class":"TCAD.TWO.Segment","points":[[114,[115,254.60331148100178],[116,360.9680624545806]],[117,[118,474.9222739434132],[119,355.5823520325097]]]}]}],"constraints":[["Tangent",[42,18]],["Tangent",[42,11]],["coi",[33,12]],["coi",[36,8]],["Tangent",[53,25]],["Tangent",[53,18]],["coi",[44,19]],["coi",[47,15]],["Tangent",[64,25]],["Tangent",[64,32]],["coi",[55,22]],["coi",[58,26]],["Tangent",[75,11]],["Tangent",[75,32]],["coi",[66,5]],["coi",[69,29]],["coi",[77,39]],["coi",[82,50]],["coi",[87,72]],["RR",[80,85]],["RR",[85,90]],["parallel",[113,18]],["perpendicular",[120,113]],["Symmetry",[92,120]],["PointOnLine",[92,113]],["PointOnLine",[102,120]],["PointOnLine",[97,120]],["RR",[105,100]]]}';
    localStorage.setItem(sketchId, sample);
  }

  app.loadFromLocalStorage();
  app.fit();
  var actionsWin = new _ui_ui_js__WEBPACK_IMPORTED_MODULE_3__["Window"]($('#actions'), app.winManager);
  _ui_ui_js__WEBPACK_IMPORTED_MODULE_3__["bindOpening"]($('#showActions'), actionsWin);
  var addAction = _ui_ui_js__WEBPACK_IMPORTED_MODULE_3__["createActionsWinBuilder"](actionsWin);

  for (var p = 0; p < app._actionsOrder.length; ++p) {
    var act = app.actions[app._actionsOrder[p]];
    addAction(act.desc, act.action);
    $('.act-' + act.id).click(act.action).attr('title', act.desc);
  }

  function infoStr(c) {
    if (c.SettableFields === undefined) return "";
    var info = Object.keys(c.SettableFields).map(function (f) {
      var val = c[f];
      var num = Number(val);

      if (isNaN(num)) {
        num = Number(app.viewer.parametricManager.constantResolver(val));
        return val + "(" + (isNaN(num) ? "?" : num.toFixed(2)) + ")";
      }

      return num.toFixed(2);
    }).join(", ");

    if (info.length != 0) {
      info = " <span style='font-size: 8px;'>[" + info + "]</span>";
    }

    return info;
  }

  var pm = app.viewer.parametricManager;
  var constrList = new _ui_ui_js__WEBPACK_IMPORTED_MODULE_3__["List"]('constrs', {
    items: function items() {
      var theItems = [];

      for (var j = 0; j < pm.system.subSystems.length; j++) {
        var sub = pm.system.subSystems[j];

        for (var i = 0; i < sub.constraints.length; ++i) {
          var constr = sub.constraints[i];

          if (constr.aux !== true && app.constraintFilter[constr.NAME] != true) {
            theItems.push({
              name: constr.UI_NAME + infoStr(constr),
              constr: constr
            });
          }
        }
      }

      theItems.sort(function (a, b) {
        if (a.constr.NAME == 'coi') {
          return b.constr.NAME == 'coi' ? 0 : 1;
        }

        return a.constr.NAME.localeCompare(b.constr.NAME);
      });
      return theItems;
    },
    remove: function remove(item) {
      pm.remove(item.constr);
    },
    mouseleave: function mouseleave(item) {
      app.viewer.deselectAll();
      app.viewer.refresh();
    },
    hover: function hover(item) {
      app.viewer.select(item.constr.getObjects(), true);
      app.viewer.refresh();
    },
    click: function click(item) {
      var c = item.constr;
      if (c.SettableFields === undefined) return;

      for (var f in c.SettableFields) {
        var value = c[f];
        var intro = c.SettableFields[f];
        value = Object(_utils_utils__WEBPACK_IMPORTED_MODULE_5__["askNumber"])(intro, typeof value == "number" ? value.toFixed(4) : value, prompt, pm.constantResolver);

        if (value != null) {
          c[f] = value;
        }
      }

      app.viewer.parametricManager.refresh();
    }
  });
  var constraintsView = app.dock.views['Constraints'];

  function configureConstraintsFilter() {
    var constraintsCaption = constraintsView.node.find('.tool-caption');
    var constraintsFilterBtn = _ui_ui_js__WEBPACK_IMPORTED_MODULE_3__["faBtn"]("filter");
    constraintsFilterBtn.css({
      'float': 'right',
      'margin-right': '10px',
      cursor: 'pointer'
    });
    constraintsCaption.append(constraintsFilterBtn);
    var constraintsFilterWin = new _ui_ui_js__WEBPACK_IMPORTED_MODULE_3__["Window"]($('#constrFilter'), app.winManager);
    _ui_ui_js__WEBPACK_IMPORTED_MODULE_3__["bindOpening"](constraintsFilterBtn, constraintsFilterWin);
    var content = constraintsFilterWin.root.find('.content');
    var constrTypes = [],
        constrType;

    for (var cname in _sketcher_parametric__WEBPACK_IMPORTED_MODULE_6__["Constraints"]) {
      c = _sketcher_parametric__WEBPACK_IMPORTED_MODULE_6__["Constraints"][cname];

      if (c.prototype !== undefined && c.prototype.UI_NAME !== undefined && !c.prototype.aux) {
        constrTypes.push(c);
      }
    }

    constrTypes.sort(function (a, b) {
      if (a.prototype.NAME == 'coi') {
        return b.prototype.NAME == 'coi' ? 0 : -1;
      }

      return a.prototype.UI_NAME.localeCompare(b.prototype.UI_NAME);
    });

    for (var i = 0; i < constrTypes.length; i++) {
      var c = constrTypes[i];

      if (c.prototype !== undefined && c.prototype.UI_NAME !== undefined && !c.prototype.aux) {
        var checkbox = $('<input>', {
          type: 'checkbox',
          checked: 'checked',
          value: c.prototype.NAME
        });
        content.append($('<label>', {
          css: {
            display: 'block',
            'white-space': 'nowrap'
          }
        }).append(checkbox).append(c.prototype.UI_NAME));
        checkbox.change(function () {
          var checkbox = $(this);
          app.constraintFilter[checkbox.val()] = checkbox.is(':checked') != true;
          constrList.refresh();
        });
      }
    }
  }

  configureConstraintsFilter();
  constraintsView.node.append(constrList.ul);
  app.viewer.streams.constraintsUpdate.attach(function () {
    return constrList.refresh();
  });
  constrList.refresh();
  var addingModeRadio = new _ui_toolkit__WEBPACK_IMPORTED_MODULE_4__["InlineRadio"](['sketch', 'construction'], ['sketch', 'construction'], 0);
  app.dock.views['Properties'].node.append('<div>Adding Mode</div>').append(addingModeRadio.root);
  addingModeRadio.root.find('input:radio').change(function () {
    app.viewer.addingRoleMode = addingModeRadio.getValue();
  });
  var layerSelection = new _ui_toolkit__WEBPACK_IMPORTED_MODULE_4__["Combo"]('layerSelection', 'Layer');
  app.dock.views['Properties'].node.append(layerSelection.root);

  var updateLayersList = function updateLayersList() {
    var options = '';

    for (var i = 0; i < app.viewer.layers.length; i++) {
      var layer = app.viewer.layers[i];
      options += "<option value='" + layer.name + "'>" + layer.name + "</option>";
    }

    layerSelection.select.html(options).val(app.viewer.activeLayer.name);
  };

  updateLayersList();
  app.viewer.bus.subscribe("activeLayer", function () {
    updateLayersList();
  });
  layerSelection.select.mousedown(updateLayersList).change(function () {
    var layer = app.viewer.findLayerByName(layerSelection.select.val());

    if (layer != null) {
      app.viewer.activeLayer = layer;
    }
  });
  var dimScale = new _ui_toolkit__WEBPACK_IMPORTED_MODULE_4__["Number"]("Dim Scale", 1, 0.1, 1);
  dimScale.min = 0.1;
  app.dock.views['Properties'].node.append(dimScale.root);
  dimScale.input.on('t-change', function () {
    app.viewer.dimScale = $(this).val();
  });
  app.viewer.bus.subscribe('dimScale', function (value) {
    dimScale.input.val(value);
  });
  var constantTextArea = $('<textarea />', {
    placeholder: 'for example: A = 50',
    css: {
      width: '100%',
      resize: 'vertical',
      background: 'inherit',
      border: 'none',
      color: '#C4E1A4'
    }
  });
  app.viewer.params.subscribe('constantDefinition', 'constantTextArea', function (value) {
    constantTextArea.val(value);
  })();
  constantTextArea.bind("change", function () {
    app.viewer.params.set('constantDefinition', $(this).val(), 'constantTextArea');
  });
  app.dock.views['Dimensions'].node.append(constantTextArea);
}

$(function () {
  return initializeSketcherApplication();
});

/***/ }),

/***/ "./web/app/sketcher/constr/solver.js":
/*!*******************************************!*\
  !*** ./web/app/sketcher/constr/solver.js ***!
  \*******************************************/
/*! exports provided: Param, prepare */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Param", function() { return Param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prepare", function() { return prepare; });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ "./web/app/utils/utils.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
/* harmony import */ var _math_qr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/qr */ "./web/app/math/qr.js");
/* harmony import */ var _math_lm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/lm */ "./web/app/math/lm.js");
/* harmony import */ var _solverConstraints__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./solverConstraints */ "./web/app/sketcher/constr/solverConstraints.js");
/* harmony import */ var _math_optim__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/optim */ "./web/app/math/optim.js");
/* harmony import */ var _math_vec__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../math/vec */ "./web/app/math/vec.js");







/** @constructor */

function Param(id, value, readOnly) {
  this.reset(value);
}

Param.prototype.reset = function (value) {
  this.set(value);
  this.j = -1;
  this.aux = false;
};

Param.prototype.set = function (value, force) {
  if (this.aux && !force) return;
  this.value = value;
};

Param.prototype.get = function () {
  return this.value;
};

Param.prototype.nop = function () {};
/** @constructor */


function System(constraints) {
  this.constraints = constraints;
  this.params = [];

  for (var ci = 0; ci < constraints.length; ++ci) {
    var c = constraints[ci];

    for (var pi = 0; pi < c.params.length; ++pi) {
      var p = c.params[pi];

      if (p.j == -1) {
        p.j = this.params.length;
        this.params.push(p);
      }
    }
  }
}

System.prototype.makeJacobian = function () {
  var jacobi = [];
  var i;
  var j;

  for (i = 0; i < this.constraints.length; i++) {
    jacobi[i] = [];

    for (j = 0; j < this.params.length; j++) {
      jacobi[i][j] = 0;
    }
  }

  for (i = 0; i < this.constraints.length; i++) {
    var c = this.constraints[i];
    var cParams = c.params;
    var grad = [];
    _utils_utils__WEBPACK_IMPORTED_MODULE_0__["fillArray"](grad, 0, cParams.length, 0);
    c.gradient(grad);

    for (var p = 0; p < cParams.length; p++) {
      var param = cParams[p];
      j = param.j;
      jacobi[i][j] = grad[p];
    }
  }

  return jacobi;
};

System.prototype.fillJacobian = function (jacobi) {
  for (var i = 0; i < this.constraints.length; i++) {
    var c = this.constraints[i];
    var cParams = c.params;
    var grad = [];
    _utils_utils__WEBPACK_IMPORTED_MODULE_0__["fillArray"](grad, 0, cParams.length, 0);
    c.gradient(grad);

    for (var p = 0; p < cParams.length; p++) {
      var param = cParams[p];
      var j = param.j;
      jacobi[i][j] = grad[p];
    }
  }

  return jacobi;
};

System.prototype.calcResidual = function (r) {
  var i = 0;
  var err = 0.;

  for (i = 0; i < this.constraints.length; i++) {
    var c = this.constraints[i];
    r[i] = c.error();
    err += r[i] * r[i];
  }

  err *= 0.5;
  return err;
};

System.prototype.calcGrad_ = function (out) {
  var i;

  for (i = 0; i < out.length || i < this.params.length; ++i) {
    out[i][0] = 0;
  }

  for (i = 0; i < this.constraints.length; i++) {
    var c = this.constraints[i];
    var cParams = c.params;
    var grad = [];
    _utils_utils__WEBPACK_IMPORTED_MODULE_0__["fillArray"](grad, 0, cParams.length, 0);
    c.gradient(grad);

    for (var p = 0; p < cParams.length; p++) {
      var param = cParams[p];
      var j = param.j;
      out[j][0] += this.constraints[i].error() * grad[p]; // (10.4)
    }
  }
};

System.prototype.calcGrad = function (out) {
  var i;

  for (i = 0; i < out.length || i < this.params.length; ++i) {
    out[i] = 0;
  }

  for (i = 0; i < this.constraints.length; i++) {
    var c = this.constraints[i];
    var cParams = c.params;
    var grad = [];
    _utils_utils__WEBPACK_IMPORTED_MODULE_0__["fillArray"](grad, 0, cParams.length, 0);
    c.gradient(grad);

    for (var p = 0; p < cParams.length; p++) {
      var param = cParams[p];
      var j = param.j;
      out[j] += this.constraints[i].error() * grad[p]; // (10.4) 
    }
  }
};

System.prototype.fillParams = function (out) {
  for (var p = 0; p < this.params.length; p++) {
    out[p] = this.params[p].get();
  }
};

System.prototype.getParams = function () {
  var out = [];
  this.fillParams(out);
  return out;
};

System.prototype.setParams = function (point) {
  for (var p = 0; p < this.params.length; p++) {
    this.params[p].set(point[p]);
  }
};

System.prototype.error = function () {
  var error = 0;

  for (var i = 0; i < this.constraints.length; i++) {
    error += Math.abs(this.constraints[i].error());
  }

  return error;
};

System.prototype.errorSquare = function () {
  var error = 0;

  for (var i = 0; i < this.constraints.length; i++) {
    var t = this.constraints[i].error();
    error += t * t;
  }

  return error * 0.5;
};

System.prototype.getValues = function () {
  var values = [];

  for (var i = 0; i < this.constraints.length; i++) {
    values[i] = this.constraints[i].error();
  }

  return values;
};

function wrapAux(constrs) {
  for (var i = 0; i < constrs.length; i++) {
    var c = constrs[i];
    var mask = [];
    var needWrap = false;

    for (var j = 0; j < c.params.length; j++) {
      var param = c.params[j];
      mask[j] = param.aux === true;
      needWrap = needWrap || mask[j];
    }

    if (needWrap) {
      constrs[i] = new _solverConstraints__WEBPACK_IMPORTED_MODULE_4__["ConstantWrapper"](c, mask);
    }
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = constrs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var constr = _step.value;

      if (constr.params.length == 0) {
        return constrs.filter(function (c) {
          return c.params.length != 0;
        });
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return constrs;
}

var lock2Equals2 = function lock2Equals2(constrs, locked) {
  var _locked = [];

  for (var i = 0; i < locked.length; ++i) {
    _locked.push(new _solverConstraints__WEBPACK_IMPORTED_MODULE_4__["EqualsTo"]([locked[i]], locked[i].get()));
  }

  return _locked;
};

var _diagnose = function diagnose(sys) {
  if (sys.constraints.length == 0 || sys.params.length == 0) {
    return {
      conflict: false,
      dof: 0
    };
  }

  var jacobian = sys.makeJacobian();
  var qr = new _math_qr__WEBPACK_IMPORTED_MODULE_2__["default"](jacobian);
  return {
    conflict: sys.constraints.length > qr.rank,
    dof: sys.params.length - qr.rank
  };
};

var prepare = function prepare(constrs, locked) {
  var simpleMode = true;

  if (!simpleMode) {
    var lockingConstrs = lock2Equals2(constrs, locked);
    Array.prototype.push.apply(constrs, lockingConstrs);
  }

  constrs = wrapAux(constrs);
  var sys = new System(constrs);

  var model = function model(point) {
    sys.setParams(point);
    return sys.getValues();
  };

  var jacobian = function jacobian(point) {
    sys.setParams(point);
    return sys.makeJacobian();
  };

  var nullResult = {
    evalCount: 0,
    error: 0,
    returnCode: 1
  };

  function solve(rough, alg) {
    //if (simpleMode) return nullResult;
    if (constrs.length == 0) return nullResult;
    if (sys.params.length == 0) return nullResult;

    switch (alg) {
      case 2:
        return solve_lm(sys, model, jacobian, rough);

      case 1:
      default:
        return Object(_math_optim__WEBPACK_IMPORTED_MODULE_5__["dog_leg"])(sys, rough);
    }
  }

  var systemSolver = {
    diagnose: function diagnose() {
      return _diagnose(sys);
    },
    error: function error() {
      return sys.error();
    },
    solveSystem: solve,
    system: sys,
    updateLock: function updateLock(values) {
      for (var i = 0; i < values.length; ++i) {
        if (simpleMode) {
          locked[i].set(values[i]);
        } else {
          lockingConstrs[i].value = values[i];
        }
      }
    }
  };
  return systemSolver;
};

var solve_lm = function solve_lm(sys, model, jacobian, rough) {
  var opt = new _math_lm__WEBPACK_IMPORTED_MODULE_3__["default"](sys.getParams(), Object(_math_vec__WEBPACK_IMPORTED_MODULE_6__["newVector"])(sys.constraints.length), model, jacobian);
  opt.evalMaximalCount = 100 * sys.params.length;
  var eps = rough ? 0.001 : 0.00000001;
  opt.init0(eps, eps, eps);
  var returnCode = 1;

  try {
    var res = opt.doOptimize();
  } catch (e) {
    returnCode = 2;
  }

  sys.setParams(res[0]);
  return {
    evalCount: opt.evalCount,
    error: sys.error(),
    returnCode: returnCode
  };
};



/***/ }),

/***/ "./web/app/sketcher/constr/solverConstraints.js":
/*!******************************************************!*\
  !*** ./web/app/sketcher/constr/solverConstraints.js ***!
  \******************************************************/
/*! exports provided: createByConstraintName, EqualsTo, ConstantWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createByConstraintName", function() { return createByConstraintName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualsTo", function() { return EqualsTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConstantWrapper", function() { return ConstantWrapper; });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ "./web/app/utils/utils.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


/**
 * This intermediate layer should be eliminated since constraint server isn't used anymore
 */

function createByConstraintName(name, params, values) {
  switch (name) {
    case "equal":
      return new Equal(params);

    case "equalsTo":
      return new EqualsTo(params, values[0]);

    case "Diff":
      return new Diff(params, values[0]);

    case "MinLength":
      return new MinLength(params, values[0]);

    case "perpendicular":
      return new Perpendicular(params);

    case "parallel":
      return new Parallel(params);

    case "P2LDistanceSigned":
      return new P2LDistanceSigned(params, values[0]);

    case "P2LDistance":
      return new P2LDistance(params, values[0]);

    case "P2LDistanceV":
      return new P2LDistanceV(params);

    case "P2PDistance":
      return new P2PDistance(params, values[0]);

    case "P2PDistanceV":
      return new P2PDistanceV(params);

    case "PointOnEllipse":
      return new PointOnEllipse(params);

    case "PointOnCurve":
      return new PointOnCurve(params, values[0]);

    case "EllipseTangent":
      return new EllipseTangent(params);

    case "CurveTangent":
      return new CurveTangent(params, values[0]);

    case "angle":
      return new Angle(params);

    case "angleConst":
      var _ = true,
          x = false; // Exclude angle value from parameters

      return new ConstantWrapper(new Angle(params), [x, x, x, x, x, x, x, x, _]);

    case 'LockConvex':
      return new LockConvex(params);

    case 'GreaterThan':
      return new GreaterThan(params, values[0]);
  }
}

function Equal(params) {
  this.params = params;

  this.error = function () {
    return this.params[0].get() - this.params[1].get();
  };

  this.gradient = function (out) {
    out[0] = 1;
    out[1] = -1;
  };
}

function MinLength(params, distance) {
  this.params = params;
  this.distance = distance;
  var p1x = 0;
  var p1y = 1;
  var p2x = 2;
  var p2y = 3;

  this.error = function () {
    var dx = params[p1x].get() - params[p2x].get();
    var dy = params[p1y].get() - params[p2y].get();
    var d = Math.sqrt(dx * dx + dy * dy);
    return d < this.distance ? d - this.distance : 0;
  };

  this.gradient = function (out) {
    var dx = params[p1x].get() - params[p2x].get();
    var dy = params[p1y].get() - params[p2y].get();
    var d = Math.sqrt(dx * dx + dy * dy);

    if (d == 0) {
      d = 0.000001;
    }

    if (d >= this.distance) {
      out[p1x] = 0;
      out[p1y] = 0;
      out[p2x] = 0;
      out[p2y] = 0;
    }

    out[p1x] = dx / d;
    out[p1y] = dy / d;
    out[p2x] = -dx / d;
    out[p2y] = -dy / d;
  };
}

function LockConvex(params) {
  this.params = params;
  var _pcx = 0;
  var _pcy = 1;
  var _pax = 2;
  var _pay = 3;
  var _ptx = 4;
  var _pty = 5;

  this.error = function () {
    var cx = params[_pcx].get();

    var cy = params[_pcy].get();

    var ax = params[_pax].get();

    var ay = params[_pay].get();

    var tx = params[_ptx].get();

    var ty = params[_pty].get();

    var crossProductNorm = (cx - ax) * (ty - ay) - (cy - ay) * (tx - ax);
    var violate = crossProductNorm < 0;
    return violate ? crossProductNorm : 0;
  };

  this.gradient = function (out) {
    var cx = params[_pcx].get();

    var cy = params[_pcy].get();

    var ax = params[_pax].get();

    var ay = params[_pay].get();

    var tx = params[_ptx].get();

    var ty = params[_pty].get();

    out[_pcx] = ty - ay;
    out[_pcy] = ax - tx;
    out[_pax] = cy - ty;
    out[_pay] = tx - cx;
    out[_ptx] = ay - cy;
    out[_pty] = cx - ax;
  };
}

function ConstantWrapper(constr, mask) {
  this.params = [];
  this.grad = [];

  for (var j = 0; j < constr.params.length; j++) {
    if (!mask[j]) {
      this.params.push(constr.params[j]);
    }

    this.grad.push(0);
  }

  this.error = function () {
    return constr.error();
  };

  this.gradient = function (out) {
    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_0__["fillArray"])(this.grad, 0, this.grad.length, 0);
    constr.gradient(this.grad);
    var jj = 0;

    for (var _j = 0; _j < mask.length; _j++) {
      if (!mask[_j]) {
        out[jj++] = this.grad[_j];
      }
    }
  };
}

function Weighted(constr, weight) {
  this.weight = weight;
  this.params = constr.params;
  this.constr = constr;

  this.error = function () {
    return constr.error() * this.weight;
  };

  this.gradient = function (out) {
    constr.gradient(out);

    for (var i = 0; i < out.length; i++) {
      out[i] *= this.weight;
    }
  };
}

function EqualsTo(params, value) {
  this.params = params;
  this.value = value;

  this.error = function () {
    return this.params[0].get() - this.value;
  };

  this.gradient = function (out) {
    out[0] = 1;
  };
}

function Diff(params, value) {
  this.params = params;
  this.value = value;

  this.error = function () {
    return this.params[0].get() - this.params[1].get() - this.value;
  };

  this.gradient = function (out) {
    out[0] = 1;
    out[1] = -1;
  };
}

function P2LDistanceSigned(params, value) {
  var TX = 0;
  var TY = 1;
  var AX = 2;
  var AY = 3;
  var BX = 4;
  var BY = 5;
  this.params = params;
  this.value = value;

  this.error = function () {
    var tx = params[TX].get(),
        ax = params[AX].get(),
        bx = params[BX].get();
    var ty = params[TY].get(),
        ay = params[AY].get(),
        by = params[BY].get();
    var d = Math.sqrt(sq(by - ay) + sq(bx - ax));
    return -(by - ay) * (tx - ax) / d + (bx - ax) * (ty - ay) / d - this.value;
  };

  this.gradient = NumericGradient;
}

function P2LDistance(params, distance) {
  this.params = params;
  this.distance = distance;
  var TX = 0;
  var TY = 1;
  var LP1X = 2;
  var LP1Y = 3;
  var LP2X = 4;
  var LP2Y = 5;

  this.error = function () {
    var x0 = params[TX].get(),
        x1 = params[LP1X].get(),
        x2 = params[LP2X].get();
    var y0 = params[TY].get(),
        y1 = params[LP1Y].get(),
        y2 = params[LP2Y].get();
    var dx = x2 - x1;
    var dy = y2 - y1;
    var d = Math.sqrt(dx * dx + dy * dy);

    if (d == 0) {
      return 0;
    }

    var A = -x0 * dy + y0 * dx + x1 * y2 - x2 * y1;
    return Math.abs(A) / d - this.distance;
  };

  this.gradient = function (out) {
    var x0 = params[TX].get(),
        x1 = params[LP1X].get(),
        x2 = params[LP2X].get();
    var y0 = params[TY].get(),
        y1 = params[LP1Y].get(),
        y2 = params[LP2Y].get();
    var dx = x2 - x1;
    var dy = y2 - y1;
    var d2 = dx * dx + dy * dy;
    var d = Math.sqrt(d2);
    var d3 = d * d2; //    var AA = -x0 * (y2 - y1) + y0 * (x2 - x1) + x1 * y2 - x2 * y1;

    var A = -x0 * dy + y0 * dx + x1 * y2 - x2 * y1;
    var AM = Math.abs(A);
    var j = A < 0 ? -1 : 1;
    out[TX] = j * (y1 - y2) / d;
    out[TY] = j * (x2 - x1) / d;
    out[LP1X] = j * (y2 - y0) / d + AM * dx / d3;
    out[LP1Y] = j * (x0 - x2) / d + AM * dy / d3;
    out[LP2X] = j * (y0 - y1) / d - AM * dx / d3;
    out[LP2Y] = j * (x1 - x0) / d - AM * dy / d3;

    _fixNaN(out);
  };
}

function P2LDistanceV(params) {
  this.params = params; //.slice(0, params.length -1);

  var TX = 0;
  var TY = 1;
  var LP1X = 2;
  var LP1Y = 3;
  var LP2X = 4;
  var LP2Y = 5;
  var D = 6;

  this.error = function () {
    var x0 = params[TX].get(),
        x1 = params[LP1X].get(),
        x2 = params[LP2X].get();
    var y0 = params[TY].get(),
        y1 = params[LP1Y].get(),
        y2 = params[LP2Y].get();
    var dist = this.params[D].get();
    var dx = x2 - x1;
    var dy = y2 - y1;
    var d = Math.sqrt(dx * dx + dy * dy);

    if (d == 0) {
      return 0;
    }

    var A = -x0 * dy + y0 * dx + x1 * y2 - x2 * y1;
    return Math.abs(A) / d - dist;
  };

  this.gradient = function (out) {
    var x0 = params[TX].get(),
        x1 = params[LP1X].get(),
        x2 = params[LP2X].get();
    var y0 = params[TY].get(),
        y1 = params[LP1Y].get(),
        y2 = params[LP2Y].get();
    var dx = x2 - x1;
    var dy = y2 - y1;
    var d2 = dx * dx + dy * dy;
    var d = Math.sqrt(d2);
    var d3 = d * d2; //    var AA = -x0 * (y2 - y1) + y0 * (x2 - x1) + x1 * y2 - x2 * y1;

    var A = -x0 * dy + y0 * dx + x1 * y2 - x2 * y1;
    var AM = Math.abs(A);
    var j = A < 0 ? -1 : 1;
    out[TX] = j * (y1 - y2) / d;
    out[TY] = j * (x2 - x1) / d;
    out[LP1X] = j * (y2 - y0) / d + AM * dx / d3;
    out[LP1Y] = j * (x0 - x2) / d + AM * dy / d3;
    out[LP2X] = j * (y0 - y1) / d - AM * dx / d3;
    out[LP2Y] = j * (x1 - x0) / d - AM * dy / d3;
    out[D] = -1;

    _fixNaN(out);
  };
}

function P2PDistance(params, distance) {
  this.params = params;
  this.distance = distance;
  var p1x = 0;
  var p1y = 1;
  var p2x = 2;
  var p2y = 3;

  this.error = function () {
    var dx = params[p1x].get() - params[p2x].get();
    var dy = params[p1y].get() - params[p2y].get();
    var d = Math.sqrt(dx * dx + dy * dy);
    return d - this.distance;
  };

  this.gradient = function (out) {
    var dx = params[p1x].get() - params[p2x].get();
    var dy = params[p1y].get() - params[p2y].get();
    var d = Math.sqrt(dx * dx + dy * dy);

    if (d == 0) {
      if (this.distance == 0) return;
      d = 0.000001;
    }

    out[p1x] = dx / d;
    out[p1y] = dy / d;
    out[p2x] = -dx / d;
    out[p2y] = -dy / d;
  };
}

function P2PDistanceV(params) {
  this.params = params;
  var p1x = 0;
  var p1y = 1;
  var p2x = 2;
  var p2y = 3;
  var D = 4;

  this.error = function () {
    var dx = params[p1x].get() - params[p2x].get();
    var dy = params[p1y].get() - params[p2y].get();
    var d = Math.sqrt(dx * dx + dy * dy);
    return d - params[D].get();
  };

  this.gradient = function (out) {
    var dx = params[p1x].get() - params[p2x].get();
    var dy = params[p1y].get() - params[p2y].get();
    var d = Math.sqrt(dx * dx + dy * dy);

    if (d == 0) {
      if (params[D].get() == 0) return;
      d = 0.000001;
    }

    out[p1x] = dx / d;
    out[p1y] = dy / d;
    out[p2x] = -dx / d;
    out[p2y] = -dy / d;
    out[D] = -1;
  };
}

function Parallel(params) {
  this.params = params;
  var l1p1x = 0;
  var l1p1y = 1;
  var l1p2x = 2;
  var l1p2y = 3;
  var l2p1x = 4;
  var l2p1y = 5;
  var l2p2x = 6;
  var l2p2y = 7;

  this.error = function () {
    var dx1 = params[l1p1x].get() - params[l1p2x].get();
    var dy1 = params[l1p1y].get() - params[l1p2y].get();
    var dx2 = params[l2p1x].get() - params[l2p2x].get();
    var dy2 = params[l2p1y].get() - params[l2p2y].get();
    return dx1 * dy2 - dy1 * dx2;
  };

  this.gradient = function (out) {
    out[l1p1x] = params[l2p1y].get() - params[l2p2y].get();
    out[l1p2x] = -(params[l2p1y].get() - params[l2p2y].get());
    out[l1p1y] = -(params[l2p1x].get() - params[l2p2x].get());
    out[l1p2y] = params[l2p1x].get() - params[l2p2x].get();
    out[l2p1x] = -(params[l1p1y].get() - params[l1p2y].get());
    out[l2p2x] = params[l1p1y].get() - params[l1p2y].get();
    out[l2p1y] = params[l1p1x].get() - params[l1p2x].get();
    out[l2p2y] = -(params[l1p1x].get() - params[l1p2x].get());
  };
}

function Perpendicular(params) {
  this.params = params;
  var l1p1x = 0;
  var l1p1y = 1;
  var l1p2x = 2;
  var l1p2y = 3;
  var l2p1x = 4;
  var l2p1y = 5;
  var l2p2x = 6;
  var l2p2y = 7;

  this.error = function () {
    var dx1 = params[l1p1x].get() - params[l1p2x].get();
    var dy1 = params[l1p1y].get() - params[l1p2y].get();
    var dx2 = params[l2p1x].get() - params[l2p2x].get();
    var dy2 = params[l2p1y].get() - params[l2p2y].get(); //dot product shows how the lines off to be perpendicular

    return dx1 * dx2 + dy1 * dy2;
  };

  this.gradient = function (out) {
    out[l1p1x] = params[l2p1x].get() - params[l2p2x].get();
    out[l1p2x] = -(params[l2p1x].get() - params[l2p2x].get());
    out[l1p1y] = params[l2p1y].get() - params[l2p2y].get();
    out[l1p2y] = -(params[l2p1y].get() - params[l2p2y].get());
    out[l2p1x] = params[l1p1x].get() - params[l1p2x].get();
    out[l2p2x] = -(params[l1p1x].get() - params[l1p2x].get());
    out[l2p1y] = params[l1p1y].get() - params[l1p2y].get();
    out[l2p2y] = -(params[l1p1y].get() - params[l1p2y].get());
  };
}

function Angle(params) {
  this.params = params;
  var l1p1x = 0;
  var l1p1y = 1;
  var l1p2x = 2;
  var l1p2y = 3;
  var l2p1x = 4;
  var l2p1y = 5;
  var l2p2x = 6;
  var l2p2y = 7;
  var angle = 8;
  var scale = 1000; // we need scale to get same order of measure units(radians are to small)

  function p(ref) {
    return params[ref].get();
  }

  this.error = function () {
    var dx1 = p(l1p2x) - p(l1p1x);
    var dy1 = p(l1p2y) - p(l1p1y);
    var dx2 = p(l2p2x) - p(l2p1x);
    var dy2 = p(l2p2y) - p(l2p1y);
    var a = Math.atan2(dy1, dx1) + p(angle);
    var ca = Math.cos(a);
    var sa = Math.sin(a);
    var x2 = dx2 * ca + dy2 * sa;
    var y2 = -dx2 * sa + dy2 * ca;
    return Math.atan2(y2, x2) * scale;
  };

  this.gradient = function (out) {
    var dx1 = p(l1p2x) - p(l1p1x);
    var dy1 = p(l1p2y) - p(l1p1y);
    var r2 = dx1 * dx1 + dy1 * dy1;
    out[l1p1x] = -dy1 / r2;
    out[l1p1y] = dx1 / r2;
    out[l1p2x] = dy1 / r2;
    out[l1p2y] = -dx1 / r2;
    dx1 = p(l1p2x) - p(l1p1x);
    dy1 = p(l1p2y) - p(l1p1y);
    var dx2 = p(l2p2x) - p(l2p1x);
    var dy2 = p(l2p2y) - p(l2p1y);
    var a = Math.atan2(dy1, dx1) + p(angle);
    var ca = Math.cos(a);
    var sa = Math.sin(a);
    var x2 = dx2 * ca + dy2 * sa;
    var y2 = -dx2 * sa + dy2 * ca;
    r2 = dx2 * dx2 + dy2 * dy2;
    dx2 = -y2 / r2;
    dy2 = x2 / r2;
    out[l2p1x] = -ca * dx2 + sa * dy2;
    out[l2p1y] = -sa * dx2 - ca * dy2;
    out[l2p2x] = ca * dx2 - sa * dy2;
    out[l2p2y] = sa * dx2 + ca * dy2;
    out[angle] = -1;
    rescale(out, scale);
  };
}

function PointOnEllipse(params) {
  this.params = params;
  var PX = 0;
  var PY = 1;
  var EP1X = 2;
  var EP1Y = 3;
  var EP2X = 4;
  var EP2Y = 5;
  var R = 6;

  this.error = function () {
    var px = params[PX].get();
    var py = params[PY].get();
    var ep1x = params[EP1X].get();
    var ep1y = params[EP1Y].get();
    var ep2x = params[EP2X].get();
    var ep2y = params[EP2Y].get();
    var radiusY = params[R].get();
    var centerX = ep1x + (ep2x - ep1x) * 0.5;
    var centerY = ep1y + (ep2y - ep1y) * 0.5;
    var rotation = Math.atan2(ep2y - ep1y, ep2x - ep1x);
    var x = px - centerX;
    var y = py - centerY;
    var polarAngle = Math.atan2(y, x) - rotation;
    var polarRadius = Math.sqrt(x * x + y * y);
    var radiusX = Math.sqrt(sq(ep1x - ep2x) + sq(ep1y - ep2y)) * 0.5;
    var L = Math.sqrt(1 / (sq(Math.cos(polarAngle) / radiusX) + sq(Math.sin(polarAngle) / radiusY)));
    return L - polarRadius;
  };

  this.gradient = NumericGradient;
}

function PointOnCurve(params, curve) {
  this.params = params;
  var PX = 0;
  var PY = 1;
  var pt = [0, 0, 0];

  this.error = function () {
    var px = params[PX].get();
    var py = params[PY].get();
    pt[0] = px;
    pt[1] = py;
    var u = curve.param(pt);
    var p = curve.point(u);
    return Math.sqrt(sq(p[0] - px) + sq(p[1] - py));
  };

  this.gradient = NumericGradient;
}

function CurveTangent(params, curve) {
  this.params = params;
  var tmp = [0, 0, 0];
  var P1X = 0;
  var P1Y = 1;
  var P2X = 2;
  var P2Y = 3;
  var TX = 4;
  var TY = 5;

  this.error = function () {
    var x1 = params[P1X].get();
    var y1 = params[P1Y].get();
    var x2 = params[P2X].get();
    var y2 = params[P2Y].get();
    var tx = params[TX].get();
    var ty = params[TY].get();
    tmp[0] = tx;
    tmp[1] = ty;
    var t = curve.param(tmp);

    var _curve$eval = curve.eval(t, 1),
        _curve$eval2 = _slicedToArray(_curve$eval, 2),
        P = _curve$eval2[0],
        D = _curve$eval2[1];

    var l = Math.sqrt(sq(D[0]) + sq(D[1]));
    var vx = -D[1] / l;
    var vy = D[0] / l;
    return Math.abs(vx * (P[0] - x1) + vy * (P[1] - y1)) + Math.abs(vx * (P[0] - x2) + vy * (P[1] - y2));
  };

  this.gradient = NumericGradient;
}

function EllipseTangent(params) {
  this.params = params;
  var P1X = 0;
  var P1Y = 1;
  var P2X = 2;
  var P2Y = 3;
  var EP1X = 4;
  var EP1Y = 5;
  var EP2X = 6;
  var EP2Y = 7;
  var R = 8;

  this.error = function (gr) {
    var p1x = params[P1X].get();
    var p1y = params[P1Y].get();
    var p2x = params[P2X].get();
    var p2y = params[P2Y].get();
    var ep1x = params[EP1X].get();
    var ep1y = params[EP1Y].get();
    var ep2x = params[EP2X].get();
    var ep2y = params[EP2Y].get();
    var radiusY = params[R].get();
    var axisX = ep2x - ep1x;
    var axisY = ep2y - ep1y;
    var radiusX = Math.sqrt(sq(axisX) + sq(axisY)) * 0.5;
    var scaleToCircleSpace = radiusY / radiusX;
    var rotation = -Math.atan2(axisY, axisX);

    function tr(x, y) {
      var xx = x * Math.cos(rotation) - y * Math.sin(rotation);
      var yy = x * Math.sin(rotation) + y * Math.cos(rotation);
      xx *= scaleToCircleSpace;
      return {
        x: xx,
        y: yy
      };
    }

    var axis = tr(axisX, axisY);
    var p1 = tr(p1x, p1y);
    var p2 = tr(p2x, p2y);
    var ep1 = tr(ep1x, ep1y);
    var centerX = ep1.x + axis.x * 0.5;
    var centerY = ep1.y + axis.y * 0.5;
    var normalX = -(p2.y - p1.y);
    var normalY = p2.x - p1.x;
    var normalD = Math.sqrt(sq(normalX) + sq(normalY));
    normalX /= normalD;
    normalY /= normalD; //this length of normal of line to center 

    var perpendicularLength = (centerX - p1.x) * normalX + (centerY - p1.y) * normalY;

    if (perpendicularLength < 0) {
      perpendicularLength *= -1;
    } else {}

    return radiusY - perpendicularLength; //*1000;
  };

  this.gradient = NumericGradient;
}

function GreaterThan(params, limit) {
  this.params = params;

  this.error = function () {
    var value = this.params[0].get();
    var error = value <= limit ? limit - value : 0;
    console.log("GreaterThan: " + error + ", value: " + value);
    return error;
  };

  this.gradient = function (out) {
    out[0] = -1;
  };
}

function NumericGradient(out) {
  var _this = this;

  var h = 1;

  var approx = function approx(param) {
    var fx = _this.error();

    _this.params[param].set(_this.params[param].get() + h);

    var fhx = _this.error();

    _this.params[param].set(_this.params[param].get() - h);

    return (fhx - fx) / h;
  };

  for (var i = 0; i < out.length; i++) {
    out[i] = approx(i);
  }
}

function _fixNaN(grad) {
  for (var i = 0; i < grad.length; i++) {
    if (isNaN(grad[i])) {
      grad[i] = 0;
    }
  }
}

function rescale(grad, factor) {
  for (var i = 0; i < grad.length; i++) {
    grad[i] *= factor;
  }
}

var sq = function sq(x) {
  return x * x;
};



/***/ }),

/***/ "./web/app/sketcher/constraints.js":
/*!*****************************************!*\
  !*** ./web/app/sketcher/constraints.js ***!
  \*****************************************/
/*! exports provided: Constraints, Coincident */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Constraints", function() { return Constraints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Coincident", function() { return Coincident; });
/* harmony import */ var _shapes_ref__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shapes/ref */ "./web/app/sketcher/shapes/ref.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/math */ "./web/app/math/math.js");
/* harmony import */ var _modules_math_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../modules/math/vector */ "./modules/math/vector.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }





var AbstractConstraint = function AbstractConstraint() {
  _classCallCheck(this, AbstractConstraint);
};

var Constraints = {
  Factory: {}
}; // ------------------------------------------------------------------------------------------------------------------ //

var Coincident =
/*#__PURE__*/
function (_AbstractConstraint) {
  _inherits(Coincident, _AbstractConstraint);

  _createClass(Coincident, null, [{
    key: "deserialize",
    value: function deserialize(refs, data) {
      return new Coincident(refs(data[0]), refs(data[1]));
    }
  }]);

  function Coincident(a, b) {
    var _this;

    _classCallCheck(this, Coincident);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Coincident).call(this));

    _defineProperty(_assertThisInitialized(_this), "reducible", true);

    _this.a = a;
    _this.b = b;
    a.linked.push(b);
    b.linked.push(a);
    return _this;
  }

  _createClass(Coincident, [{
    key: "getSolveData",
    value: function getSolveData() {
      return [['equal', [this.a._x, this.b._x], []], ['equal', [this.a._y, this.b._y], []]];
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return [this.NAME, [this.a.id, this.b.id]];
    }
  }, {
    key: "getObjects",
    value: function getObjects() {
      return [this.a, this.b];
    }
  }]);

  return Coincident;
}(AbstractConstraint);
Constraints.Coincident = Coincident;
Constraints.Coincident.prototype.NAME = 'coi';
Constraints.Coincident.prototype.UI_NAME = 'Coincident';
Constraints.Factory[Coincident.prototype.NAME] = Coincident.deserialize; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */

Constraints.RadiusOffset = function (arc1, arc2, offset) {
  this.arc1 = arc1;
  this.arc2 = arc2;
  this.offset = offset;
};

Constraints.RadiusOffset.prototype.NAME = 'RadiusOffset';
Constraints.RadiusOffset.prototype.UI_NAME = 'Radius Offset';

Constraints.RadiusOffset.prototype.getSolveData = function (resolver) {
  return [['Diff', [this.arc1.r, this.arc2.r], [resolver(this.offset)]]];
};

Constraints.RadiusOffset.prototype.serialize = function () {
  return [this.NAME, [this.arc1.id, this.arc2.id, this.offset]];
};

Constraints.Factory[Constraints.RadiusOffset.prototype.NAME] = function (refs, data) {
  return new Constraints.RadiusOffset(refs(data[0]), refs(data[1]), data[2]);
};

Constraints.RadiusOffset.prototype.getObjects = function () {
  return [this.arc1, this.arc2];
};

Constraints.RadiusOffset.prototype.SettableFields = {
  'offset': "Enter the offset"
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */

Constraints.Lock = function (p, c) {
  this.p = p;
  this.c = c;
};

Constraints.Lock.prototype.NAME = 'lock';
Constraints.Lock.prototype.UI_NAME = 'Lock';

Constraints.Lock.prototype.getSolveData = function () {
  return [['equalsTo', [this.p._x], [this.c.x]], ['equalsTo', [this.p._y], [this.c.y]]];
};

Constraints.Lock.prototype.serialize = function () {
  return [this.NAME, [this.p.id, this.c]];
};

Constraints.Factory[Constraints.Lock.prototype.NAME] = function (refs, data) {
  return new Constraints.Lock(refs(data[0]), data[1]);
};

Constraints.Lock.prototype.getObjects = function () {
  return [this.p];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.Parallel = function (l1, l2) {
  this.l1 = l1;
  this.l2 = l2;
};

Constraints.Parallel.prototype.NAME = 'parallel';
Constraints.Parallel.prototype.UI_NAME = 'Parallel';

Constraints.Parallel.prototype.getSolveData = function () {
  var params = [];
  this.l1.collectParams(params);
  this.l2.collectParams(params);
  return [[this.NAME, params, []]];
};

Constraints.Parallel.prototype.serialize = function () {
  return [this.NAME, [this.l1.id, this.l2.id]];
};

Constraints.Factory[Constraints.Parallel.prototype.NAME] = function (refs, data) {
  return new Constraints.Parallel(refs(data[0]), refs(data[1]));
};

Constraints.Parallel.prototype.getObjects = function () {
  return [this.l1, this.l2];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.Perpendicular = function (l1, l2) {
  this.l1 = l1;
  this.l2 = l2;
};

Constraints.Perpendicular.prototype.NAME = 'perpendicular';
Constraints.Perpendicular.prototype.UI_NAME = 'Perpendicular';

Constraints.Perpendicular.prototype.getSolveData = function () {
  var params = [];
  this.l1.collectParams(params);
  this.l2.collectParams(params);
  return [[this.NAME, params, []]];
};

Constraints.Perpendicular.prototype.serialize = function () {
  return [this.NAME, [this.l1.id, this.l2.id]];
};

Constraints.Factory[Constraints.Perpendicular.prototype.NAME] = function (refs, data) {
  return new Constraints.Perpendicular(refs(data[0]), refs(data[1]));
};

Constraints.Perpendicular.prototype.getObjects = function () {
  return [this.l1, this.l2];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.P2LDistanceSigned = function (p, a, b, d) {
  this.p = p;
  this.a = a;
  this.b = b;
  this.d = d;
};

Constraints.P2LDistanceSigned.prototype.NAME = 'P2LDistanceSigned';
Constraints.P2LDistanceSigned.prototype.UI_NAME = 'Distance P & L';

Constraints.P2LDistanceSigned.prototype.getSolveData = function (resolver) {
  var params = [];
  this.p.collectParams(params);
  this.a.collectParams(params);
  this.b.collectParams(params);
  return [[this.NAME, params, [resolver(this.d)]]];
};

Constraints.P2LDistanceSigned.prototype.serialize = function () {
  return [this.NAME, [this.p.id, this.a.id, this.b.id, this.d]];
};

Constraints.Factory[Constraints.P2LDistanceSigned.prototype.NAME] = function (refs, data) {
  return new Constraints.P2LDistanceSigned(refs(data[0]), refs(data[1]), refs(data[2]), data[3]);
};

Constraints.P2LDistanceSigned.prototype.getObjects = function () {
  var collector = new Constraints.ParentsCollector();
  collector.check(this.a);
  collector.check(this.b);
  collector.parents.push(this.p);
  return collector.parents;
};

Constraints.P2LDistanceSigned.prototype.SettableFields = {
  'd': "Enter the distance"
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */

Constraints.P2LDistance = function (p, l, d) {
  this.p = p;
  this.l = l;
  this.d = d;
};

Constraints.P2LDistance.prototype.NAME = 'P2LDistance';
Constraints.P2LDistance.prototype.UI_NAME = 'Distance P & L';

Constraints.P2LDistance.prototype.getSolveData = function (resolver) {
  var params = [];
  this.p.collectParams(params);
  this.l.collectParams(params);
  return [[this.NAME, params, [resolver(this.d)]]];
};

Constraints.P2LDistance.prototype.serialize = function () {
  return [this.NAME, [this.p.id, this.l.id, this.d]];
};

Constraints.Factory[Constraints.P2LDistance.prototype.NAME] = function (refs, data) {
  return new Constraints.P2LDistance(refs(data[0]), refs(data[1]), data[2]);
};

Constraints.P2LDistance.prototype.getObjects = function () {
  return [this.p, this.l];
};

Constraints.P2LDistance.prototype.SettableFields = {
  'd': "Enter the distance"
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */

Constraints.MinLength = function (a, b, min) {
  this.a = a;
  this.b = b;
  this.min = min;
};

Constraints.MinLength.prototype.aux = true;
Constraints.MinLength.prototype.NAME = 'MinLength';
Constraints.MinLength.prototype.UI_NAME = 'MinLength';

Constraints.MinLength.prototype.getSolveData = function () {
  var params = [];
  this.a.collectParams(params);
  this.b.collectParams(params);
  return [[this.NAME, params, [this.min]]];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.P2LDistanceV = function (p, l, d) {
  this.p = p;
  this.l = l;
  this.d = d;
};

Constraints.P2LDistanceV.prototype.aux = true;
Constraints.P2LDistanceV.prototype.NAME = 'P2LDistanceV';
Constraints.P2LDistanceV.prototype.UI_NAME = 'Distance P & L';

Constraints.P2LDistanceV.prototype.getSolveData = function () {
  var params = [];
  this.p.collectParams(params);
  this.l.collectParams(params);
  params.push(this.d);
  return [[this.NAME, params]];
}; // We don't serialize auxiliary constraints
//
//Constraints.P2LDistanceV.prototype.serialize = function() {
//  return [this.NAME, [this.p.id, this.l.id, this.d.id]];
//};
//
//Constraints.Factory[Constraints.P2LDistanceV.prototype.NAME] = function(refs, data) {
//  return new Constraints.P2LDistanceV(refs(data[0]), refs(data[1]), refs(data[2]));
//};
// ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.P2PDistance = function (p1, p2, d) {
  this.p1 = p1;
  this.p2 = p2;
  this.d = d;
};

Constraints.P2PDistance.prototype.NAME = 'P2PDistance';
Constraints.P2PDistance.prototype.UI_NAME = 'Distance Points';

Constraints.P2PDistance.prototype.getSolveData = function (resolver) {
  var params = [];
  this.p1.collectParams(params);
  this.p2.collectParams(params);
  return [[this.NAME, params, [resolver(this.d)]]];
};

Constraints.P2PDistance.prototype.serialize = function () {
  return [this.NAME, [this.p1.id, this.p2.id, this.d]];
};

Constraints.Factory[Constraints.P2PDistance.prototype.NAME] = function (refs, data) {
  return new Constraints.P2PDistance(refs(data[0]), refs(data[1]), data[2]);
};

Constraints.P2PDistance.prototype.getObjects = function () {
  return [this.p1, this.p2];
};

Constraints.P2PDistance.prototype.SettableFields = {
  'd': "Enter the distance"
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */

Constraints.P2PDistanceV = function (p1, p2, d) {
  this.p1 = p1;
  this.p2 = p2;
  this.d = d;
};

Constraints.P2PDistanceV.prototype.aux = true;
Constraints.P2PDistanceV.prototype.NAME = 'P2PDistanceV';
Constraints.P2PDistanceV.prototype.UI_NAME = 'Distance Points';

Constraints.P2PDistanceV.prototype.getSolveData = function () {
  var params = [];
  this.p1.collectParams(params);
  this.p2.collectParams(params);
  params.push(this.d);
  return [[this.NAME, params]];
}; // We don't serialize auxiliary constraints
//
//Constraints.P2PDistanceV.prototype.serialize = function() {
//  return [this.NAME, [this.p1.id, this.p2.id, this.d.id]];
//};
//
//Constraints.Factory[Constraints.P2PDistanceV.prototype.NAME] = function(refs, data) {
//  return new Constraints.P2PDistanceV(refs(data[0]), refs(data[1]), refs(data[2]));
//};
// ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.GreaterThan = function (p, limit) {
  this.p = p;
  this.limit = limit;
};

Constraints.GreaterThan.prototype.aux = true;
Constraints.GreaterThan.prototype.NAME = 'GreaterThan';
Constraints.GreaterThan.prototype.UI_NAME = 'Greater Than';

Constraints.GreaterThan.prototype.getSolveData = function () {
  return [[this.NAME, [this.p], [this.limit]]];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.Radius = function (arc, d) {
  this.arc = arc;
  this.d = d;
};

Constraints.Radius.prototype.NAME = 'Radius';
Constraints.Radius.prototype.UI_NAME = 'Radius Value';

Constraints.Radius.prototype.getSolveData = function (resolver) {
  return [['equalsTo', [this.arc.r], [resolver(this.d)]]];
};

Constraints.Radius.prototype.serialize = function () {
  return [this.NAME, [this.arc.id, this.d]];
};

Constraints.Factory[Constraints.Radius.prototype.NAME] = function (refs, data) {
  return new Constraints.Radius(refs(data[0]), data[1]);
};

Constraints.Radius.prototype.getObjects = function () {
  return [this.arc];
};

Constraints.Radius.prototype.SettableFields = {
  'd': "Enter the radius value"
}; // ------------------------------------------------------------------------------------------------------------------ // 

/** @constructor */

Constraints.RR = function (arc1, arc2) {
  this.arc1 = arc1;
  this.arc2 = arc2;
};

Constraints.RR.prototype.NAME = 'RR';
Constraints.RR.prototype.UI_NAME = 'Radius Equality'; //Constraints.RR.prototype.reducible = true;

Constraints.RR.prototype.getSolveData = function () {
  return [['equal', [this.arc1.r, this.arc2.r], []]];
};

Constraints.RR.prototype.serialize = function () {
  return [this.NAME, [this.arc1.id, this.arc2.id]];
};

Constraints.Factory[Constraints.RR.prototype.NAME] = function (refs, data) {
  return new Constraints.RR(refs(data[0]), refs(data[1]));
};

Constraints.RR.prototype.getObjects = function () {
  return [this.arc1, this.arc2];
}; // ------------------------------------------------------------------------------------------------------------------ // 

/** @constructor */


Constraints.LL = function (line1, line2) {
  this.line1 = line1;
  this.line2 = line2;
  this.length = new _shapes_ref__WEBPACK_IMPORTED_MODULE_0__["Ref"](_math_math__WEBPACK_IMPORTED_MODULE_1__["distanceAB"](line1.a, line1.b));
};

Constraints.LL.prototype.NAME = 'LL';
Constraints.LL.prototype.UI_NAME = 'Lines Equality';

Constraints.LL.prototype.getSolveData = function () {
  var params1 = [];
  var params2 = [];
  this.line1.collectParams(params1);
  this.line2.collectParams(params2);
  params1.push(this.length);
  params2.push(this.length);
  return [['P2PDistanceV', params1, []], ['P2PDistanceV', params2, []]];
};

Constraints.LL.prototype.serialize = function () {
  return [this.NAME, [this.line1.id, this.line2.id]];
};

Constraints.Factory[Constraints.LL.prototype.NAME] = function (refs, data) {
  return new Constraints.LL(refs(data[0]), refs(data[1]));
};

Constraints.LL.prototype.getObjects = function () {
  return [this.line1, this.line2];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.Vertical = function (line) {
  this.line = line;
};

Constraints.Vertical.prototype.NAME = 'Vertical';
Constraints.Vertical.prototype.UI_NAME = 'Vertical'; //Constraints.Vertical.prototype.reducible = true;

Constraints.Vertical.prototype.getSolveData = function () {
  return [['equal', [this.line.a._x, this.line.b._x], []]];
};

Constraints.Vertical.prototype.serialize = function () {
  return [this.NAME, [this.line.id]];
};

Constraints.Factory[Constraints.Vertical.prototype.NAME] = function (refs, data) {
  return new Constraints.Vertical(refs(data[0]));
};

Constraints.Vertical.prototype.getObjects = function () {
  return [this.line];
}; // ------------------------------------------------------------------------------------------------------------------ // 

/** @constructor */


Constraints.Horizontal = function (line) {
  this.line = line;
};

Constraints.Horizontal.prototype.NAME = 'Horizontal';
Constraints.Horizontal.prototype.UI_NAME = 'Horizontal'; //Constraints.Horizontal.prototype.reducible = true;

Constraints.Horizontal.prototype.getSolveData = function () {
  return [['equal', [this.line.a._y, this.line.b._y], []]];
};

Constraints.Horizontal.prototype.serialize = function () {
  return [this.NAME, [this.line.id]];
};

Constraints.Factory[Constraints.Horizontal.prototype.NAME] = function (refs, data) {
  return new Constraints.Horizontal(refs(data[0]));
};

Constraints.Horizontal.prototype.getObjects = function () {
  return [this.line];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.Tangent = function (arc, line) {
  this.arc = arc;
  this.line = line;
};

Constraints.Tangent.prototype.NAME = 'Tangent';
Constraints.Tangent.prototype.UI_NAME = 'Tangent';

Constraints.Tangent.prototype.getSolveData = function () {
  var params = [];
  this.arc.c.collectParams(params);
  this.line.collectParams(params);
  params.push(this.arc.r);
  return [['P2LDistanceV', params, []]];
};

Constraints.Tangent.prototype.serialize = function () {
  return [this.NAME, [this.arc.id, this.line.id]];
};

Constraints.Factory[Constraints.Tangent.prototype.NAME] = function (refs, data) {
  return new Constraints.Tangent(refs(data[0]), refs(data[1]));
};

Constraints.Tangent.prototype.getObjects = function () {
  return [this.arc, this.line];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.PointOnLine = function (point, line) {
  this.point = point;
  this.line = line;
};

Constraints.PointOnLine.prototype.NAME = 'PointOnLine';
Constraints.PointOnLine.prototype.UI_NAME = 'Point On Line';

Constraints.PointOnLine.prototype.getSolveData = function () {
  var params = [];
  this.point.collectParams(params);
  this.line.collectParams(params);
  return [['P2LDistance', params, [0]]];
};

Constraints.PointOnLine.prototype.serialize = function () {
  return [this.NAME, [this.point.id, this.line.id]];
};

Constraints.Factory[Constraints.PointOnLine.prototype.NAME] = function (refs, data) {
  return new Constraints.PointOnLine(refs(data[0]), refs(data[1]));
};

Constraints.PointOnLine.prototype.getObjects = function () {
  return [this.point, this.line];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.PointOnArc = function (point, arc) {
  this.point = point;
  this.arc = arc;
};

Constraints.PointOnArc.prototype.NAME = 'PointOnArc';
Constraints.PointOnArc.prototype.UI_NAME = 'Point On Arc';

Constraints.PointOnArc.prototype.getSolveData = function () {
  var params = [];
  this.point.collectParams(params);
  this.arc.c.collectParams(params);
  params.push(this.arc.r);
  return [['P2PDistanceV', params, []]];
};

Constraints.PointOnArc.prototype.serialize = function () {
  return [this.NAME, [this.point.id, this.arc.id]];
};

Constraints.Factory[Constraints.PointOnArc.prototype.NAME] = function (refs, data) {
  return new Constraints.PointOnArc(refs(data[0]), refs(data[1]));
};

Constraints.PointOnArc.prototype.getObjects = function () {
  return [this.point, this.arc];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.PointOnCurve = function (point, curveObject) {
  this.point = point;
  this.curveObject = curveObject;
};

Constraints.PointOnCurve.prototype.NAME = 'PointOnCurve';
Constraints.PointOnCurve.prototype.UI_NAME = 'Point On Curve';

Constraints.PointOnCurve.prototype.getSolveData = function () {
  var params = [];
  this.point.collectParams(params);
  return [['PointOnCurve', params, [this.curveObject.curve]]];
};

Constraints.PointOnCurve.prototype.serialize = function () {
  return [this.NAME, [this.point.id, this.curveObject.id]];
};

Constraints.Factory[Constraints.PointOnCurve.prototype.NAME] = function (refs, data) {
  return new Constraints.PointOnCurve(refs(data[0]), refs(data[1]));
};

Constraints.PointOnCurve.prototype.getObjects = function () {
  return [this.point, this.curveObject];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.PointOnEllipseInternal = function (point, ellipse) {
  this.point = point;
  this.ellipse = ellipse;
};

Constraints.PointOnEllipseInternal.prototype.NAME = 'PointOnEllipseI';
Constraints.PointOnEllipseInternal.prototype.UI_NAME = 'Point On Ellipse';
Constraints.PointOnEllipseInternal.prototype.aux = true;

Constraints.PointOnEllipseInternal.prototype.getSolveData = function () {
  var params = [];
  this.point.collectParams(params);
  this.ellipse.ep1.collectParams(params);
  this.ellipse.ep2.collectParams(params);
  params.push(this.ellipse.r);
  return [['PointOnEllipse', params, []]];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.PointOnEllipse = function (point, ellipse) {
  Constraints.PointOnEllipseInternal.call(this, point, ellipse);
};

Constraints.PointOnEllipse.prototype.NAME = 'PointOnEllipse';
Constraints.PointOnEllipse.prototype.UI_NAME = 'Point On Ellipse';

Constraints.PointOnEllipse.prototype.getSolveData = function () {
  return Constraints.PointOnEllipseInternal.prototype.getSolveData.call(this);
};

Constraints.PointOnEllipse.prototype.serialize = function () {
  return [this.NAME, [this.point.id, this.ellipse.id]];
};

Constraints.Factory[Constraints.PointOnEllipse.prototype.NAME] = function (refs, data) {
  return new Constraints.PointOnEllipse(refs(data[0]), refs(data[1]));
};

Constraints.PointOnEllipse.prototype.getObjects = function () {
  return [this.point, this.ellipse];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.EllipseTangent = function (line, ellipse) {
  this.line = line;
  this.ellipse = ellipse;
};

Constraints.EllipseTangent.prototype.NAME = 'EllipseTangent';
Constraints.EllipseTangent.prototype.UI_NAME = 'Tangent Ellipse';

Constraints.EllipseTangent.prototype.getSolveData = function () {
  var params = [];
  this.line.collectParams(params);
  this.ellipse.ep1.collectParams(params);
  this.ellipse.ep2.collectParams(params);
  params.push(this.ellipse.r);
  return [['EllipseTangent', params, []]];
};

Constraints.EllipseTangent.prototype.serialize = function () {
  return [this.NAME, [this.line.id, this.ellipse.id]];
};

Constraints.Factory[Constraints.EllipseTangent.prototype.NAME] = function (refs, data) {
  return new Constraints.EllipseTangent(refs(data[0]), refs(data[1]));
};

Constraints.EllipseTangent.prototype.getObjects = function () {
  return [this.line, this.ellipse];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.CurveTangent = function (line, curveObject) {
  this.line = line;
  this.curveObject = curveObject;

  var _this$curveObject$cur = this.curveObject.curve.domain(),
      _this$curveObject$cur2 = _slicedToArray(_this$curveObject$cur, 2),
      uMin = _this$curveObject$cur2[0],
      uMax = _this$curveObject$cur2[1];

  var initPoint = this.curveObject.curve.point(0.5 * (uMin + uMax));
  this.tx = new _shapes_ref__WEBPACK_IMPORTED_MODULE_0__["Ref"](initPoint[0]);
  this.ty = new _shapes_ref__WEBPACK_IMPORTED_MODULE_0__["Ref"](initPoint[1]);
};

Constraints.CurveTangent.prototype.NAME = 'CurveTangent';
Constraints.CurveTangent.prototype.UI_NAME = 'Curve Curve';

Constraints.CurveTangent.prototype.getSolveData = function () {
  var params = [];
  this.line.collectParams(params);
  params.push(this.tx);
  params.push(this.ty);
  return [['CurveTangent', params, [this.curveObject.curve]]];
};

Constraints.CurveTangent.prototype.serialize = function () {
  return [this.NAME, [this.line.id, this.curveObject.id]];
};

Constraints.Factory[Constraints.CurveTangent.prototype.NAME] = function (refs, data) {
  return new Constraints.CurveTangent(refs(data[0]), refs(data[1]));
};

Constraints.CurveTangent.prototype.getObjects = function () {
  return [this.line, this.curveObject];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.PointInMiddle = function (point, line) {
  this.point = point;
  this.line = line;
  this.length = new _shapes_ref__WEBPACK_IMPORTED_MODULE_0__["Ref"](_math_math__WEBPACK_IMPORTED_MODULE_1__["distanceAB"](line.a, line.b) / 2);
};

Constraints.PointInMiddle.prototype.NAME = 'PointInMiddle';
Constraints.PointInMiddle.prototype.UI_NAME = 'Point In the Middle';

Constraints.PointInMiddle.prototype.getSolveData = function () {
  var params1 = [];
  var params2 = [];
  this.line.a.collectParams(params1);
  this.point.collectParams(params1);
  params1.push(this.length);
  this.line.b.collectParams(params2);
  this.point.collectParams(params2);
  params2.push(this.length);
  return [['P2PDistanceV', params1, []], ['P2PDistanceV', params2, []]];
};

Constraints.PointInMiddle.prototype.serialize = function () {
  return [this.NAME, [this.point.id, this.line.id]];
};

Constraints.Factory[Constraints.PointInMiddle.prototype.NAME] = function (refs, data) {
  return new Constraints.PointInMiddle(refs(data[0]), refs(data[1]));
};

Constraints.PointInMiddle.prototype.getObjects = function () {
  return [this.point, this.line];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.Symmetry = function (point, line) {
  this.point = point;
  this.line = line;
  this.length = new _shapes_ref__WEBPACK_IMPORTED_MODULE_0__["Ref"](_math_math__WEBPACK_IMPORTED_MODULE_1__["distanceAB"](line.a, line.b) / 2);
};

Constraints.Symmetry.prototype.NAME = 'Symmetry';
Constraints.Symmetry.prototype.UI_NAME = 'Symmetry';

Constraints.Symmetry.prototype.getSolveData = function (resolver) {
  var pointInMiddleData = Constraints.PointInMiddle.prototype.getSolveData.call(this, [resolver]);
  var pointOnLineData = Constraints.PointOnLine.prototype.getSolveData.call(this, [resolver]);
  return pointInMiddleData.concat(pointOnLineData);
};

Constraints.Symmetry.prototype.serialize = function () {
  return [this.NAME, [this.point.id, this.line.id]];
};

Constraints.Factory[Constraints.Symmetry.prototype.NAME] = function (refs, data) {
  return new Constraints.Symmetry(refs(data[0]), refs(data[1]));
};

Constraints.Symmetry.prototype.getObjects = function () {
  return [this.point, this.line];
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.Angle = function (p1, p2, p3, p4, angle) {
  this.p1 = p1;
  this.p2 = p2;
  this.p3 = p3;
  this.p4 = p4;
  this._angle = new _shapes_ref__WEBPACK_IMPORTED_MODULE_0__["Ref"](0);
  this.angle = angle;
};

Constraints.Angle.prototype.NAME = 'Angle';
Constraints.Angle.prototype.UI_NAME = 'Lines Angle';

Constraints.Angle.prototype.getSolveData = function (resolver) {
  this._angle.set(resolver(this.angle) / 180 * Math.PI);

  var params = [];
  this.p1.collectParams(params);
  this.p2.collectParams(params);
  this.p3.collectParams(params);
  this.p4.collectParams(params);
  params.push(this._angle);
  return [['angleConst', params, []]];
};

Constraints.Angle.prototype.serialize = function () {
  return [this.NAME, [this.p1.id, this.p2.id, this.p3.id, this.p4.id, this.angle]];
};

Constraints.Factory[Constraints.Angle.prototype.NAME] = function (refs, data) {
  return new Constraints.Angle(refs(data[0]), refs(data[1]), refs(data[2]), refs(data[3]), data[4]);
};

Constraints.Angle.prototype.getObjects = function () {
  var collector = new Constraints.ParentsCollector();
  collector.check(this.p1);
  collector.check(this.p2);
  collector.check(this.p3);
  collector.check(this.p4);
  return collector.parents;
};

Constraints.Angle.prototype.SettableFields = {
  'angle': "Enter the angle value"
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */

Constraints.LockConvex = function (c, a, t) {
  this.c = c;
  this.a = a;
  this.t = t;
};

Constraints.LockConvex.prototype.NAME = 'LockConvex';
Constraints.LockConvex.prototype.UI_NAME = 'Lock Convexity';

Constraints.LockConvex.prototype.getSolveData = function () {
  var params = [];
  this.c.collectParams(params);
  this.a.collectParams(params);
  this.t.collectParams(params);
  return [['LockConvex', params, []]];
};

Constraints.LockConvex.prototype.serialize = function () {
  return [this.NAME, [this.c.id, this.a.id, this.t.id]];
};

Constraints.Factory[Constraints.LockConvex.prototype.NAME] = function (refs, data) {
  return new Constraints.LockConvex(refs(data[0]), refs(data[1]), refs(data[2]));
};

Constraints.LockConvex.prototype.getObjects = function () {
  var collector = new Constraints.ParentsCollector();
  collector.check(this.c);
  collector.check(this.a);
  collector.check(this.t);
  return collector.parents;
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.Mirror = function (reflectionLine, objects, reflectedObjects) {
  var _this2 = this;

  this.reflectionLine = reflectionLine;
  this.objects = objects;
  this.dir = new _modules_math_vector__WEBPACK_IMPORTED_MODULE_2__["default"]();
  this.updateDir();

  if (!reflectedObjects) {
    reflectedObjects = objects.map(function (o) {
      var copy = o.copy();
      copy.virtualOf = o.id;
      copy.aux = true;
      copy.role = 'virtual';
      o.layer.add(copy);

      _this2.reflect(o, copy);

      return copy;
    });
  }

  reflectedObjects.forEach(function (copy, i) {
    copy.virtualOf = _this2.objects[i].id;
    copy.aux = true;
    copy.role = 'virtual';
  });
  this.reflectedObjects = reflectedObjects;
};

Constraints.Mirror.prototype.NAME = 'Mirror';
Constraints.Mirror.prototype.UI_NAME = 'Mirror';
Constraints.Mirror.prototype.GENERATOR = true;

Constraints.Mirror.prototype.updateDir = function () {
  this.dir.set(-(this.reflectionLine.b._y.get() - this.reflectionLine.a._y.get()), this.reflectionLine.b._x.get() - this.reflectionLine.a._x.get(), 0)._normalize();
};

Constraints.Mirror.prototype.reflect = function (source, dest) {
  var _this3 = this;

  var origin = this.reflectionLine.a.toVector();

  var pointMirroring = function pointMirroring(x, y) {
    var pt = new _modules_math_vector__WEBPACK_IMPORTED_MODULE_2__["default"](x, y, 0);

    var proj = _this3.dir.dot(pt.minus(origin));

    return _this3.dir.multiply(-proj * 2)._plus(pt);
  };

  source.mirror(dest, pointMirroring);
};

Constraints.Mirror.prototype.getSolveData = function () {
  return [];
};

Constraints.Mirror.prototype.serialize = function () {
  var ids = [this.reflectionLine.id];

  for (var i = 0; i < this.objects.length; i++) {
    ids.push(this.objects[i].id);
    ids.push(this.reflectedObjects[i].id);
  }

  return [this.NAME, ids];
};

Constraints.Factory[Constraints.Mirror.prototype.NAME] = function (refs, data) {
  var _data = _toArray(data),
      rlId = _data[0],
      objectIds = _data.slice(1);

  var objects = [];
  var reflectedObjects = [];

  for (var i = 0; i < objectIds.length; i += 2) {
    objects.push(refs(objectIds[i]));
    reflectedObjects.push(refs(objectIds[i + 1]));
  }

  return new Constraints.Mirror(refs(rlId), objects, reflectedObjects);
};

Constraints.Mirror.prototype.getObjects = function () {
  return [this.reflectionLine].concat(_toConsumableArray(this.objects));
};

Constraints.Mirror.prototype.visitParams = function (callback) {
  this.reflectionLine.visitParams(callback);
  this.objects.forEach(function (o) {
    return o.visitParams(callback);
  });
};

Constraints.Mirror.prototype.visitGeneratedParams = function (callback) {
  this.reflectedObjects.forEach(function (o) {
    return o.visitParams(callback);
  });
};

Constraints.Mirror.prototype.updateGeneratedObjects = function () {
  this.updateDir();

  for (var i = 0; i < this.objects.length; i++) {
    this.reflect(this.objects[i], this.reflectedObjects[i]);
  }
};

Constraints.Mirror.prototype.getGeneratedObjects = function () {
  return this.reflectedObjects;
}; // ------------------------------------------------------------------------------------------------------------------ //

/** @constructor */


Constraints.Fillet = function (point1, point2, arc) {
  this.point1 = point1;
  this.point2 = point2;
  this.arc = arc;
  this.contraints = [new Constraints.Tangent(arc, point1.parent), new Constraints.Tangent(arc, point2.parent), new Constraints.Coincident(arc.a, point1), new Constraints.Coincident(arc.b, point2)];
};

Constraints.Fillet.prototype.NAME = 'Fillet';
Constraints.Fillet.prototype.UI_NAME = 'Fillet';

Constraints.Fillet.prototype.getSolveData = function () {
  var solveData = [];
  this.contraints.forEach(function (c) {
    return c.getSolveData().forEach(function (d) {
      return solveData.push(d);
    });
  });
  return solveData;
};

Constraints.Fillet.prototype.serialize = function () {
  return [this.NAME, [this.point1.id, this.point2.id, this.arc.id]];
};

Constraints.Factory[Constraints.Fillet.prototype.NAME] = function (refs, data) {
  return new Constraints.Fillet(refs(data[0]), refs(data[1]), refs(data[2]));
};

Constraints.Fillet.prototype.getObjects = function () {
  var objects = [];
  this.contraints.forEach(function (c) {
    return c.getObjects().forEach(function (o) {
      return objects.push(o);
    });
  });
  return objects;
};

Constraints.Fillet.prototype.validate = function () {
  function validOn(p, arc, left) {
    var op = p.parent.opposite(p);
    var opV = op.toVector();

    var dir = p.toVector()._minus(opV)._normalize();

    var centerDir = arc.c.toVector()._minus(opV)._normalize();

    var z = centerDir.cross(dir).z;
    return left === z < 0;
  }

  return validOn(this.point1, this.arc, true) && validOn(this.point2, this.arc, false);
};

Constraints.ParentsCollector = function () {
  this.parents = [];
  var parents = this.parents;
  var index = {};

  function add(obj) {
    if (index[obj.id] === undefined) {
      index[obj.id] = obj;
      parents.push(obj);
    }
  }

  this.check = function (obj) {
    if (obj.parent !== null) {
      add(obj.parent);
    } else {
      add(obj);
    }
  };
};

/***/ }),

/***/ "./web/app/sketcher/fetchers.js":
/*!**************************************!*\
  !*** ./web/app/sketcher/fetchers.js ***!
  \**************************************/
/*! exports provided: twoPoints, points, arkCirc, generic, pointAndLine, line, lines, arcCircAndLine, twoLines, sketchObjects */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "twoPoints", function() { return twoPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "points", function() { return points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arkCirc", function() { return arkCirc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generic", function() { return generic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointAndLine", function() { return pointAndLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "line", function() { return line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lines", function() { return lines; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arcCircAndLine", function() { return arcCircAndLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "twoLines", function() { return twoLines; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sketchObjects", function() { return sketchObjects; });
function twoPoints(objs) {
  var points = [];

  for (var i = 0; i < objs.length; ++i) {
    if (objs[i]._class == 'TCAD.TWO.EndPoint') {
      points.push(objs[i]);
    } else if (objs[i]._class == 'TCAD.TWO.Segment') {
      points.push(objs[i].a);
      points.push(objs[i].b);
    }
  }

  if (points.length < 2) {
    throw "Illegal Argument. Constraint requires 2 points or 1 line.";
  }

  return points;
}
function points(objs) {
  var points = [];

  for (var i = 0; i < objs.length; ++i) {
    objs[i].accept(function (o) {
      if (o._class === 'TCAD.TWO.EndPoint') {
        points.push(o);
      }

      return true;
    });
  }

  if (points.length == 0) {
    throw "Illegal Argument. Constraint requires at least 1 point/line/arc/circle.";
  }

  return points;
}
function arkCirc(objs, min) {
  var arcs = [];

  for (var i = 0; i < objs.length; ++i) {
    if (objs[i]._class === 'TCAD.TWO.Arc' || objs[i]._class === 'TCAD.TWO.Circle') {
      arcs.push(objs[i]);
    }
  }

  if (arcs.length < min) {
    throw "Illegal Argument. Constraint requires at least " + min + " arcs/circles.";
  }

  return arcs;
}
function generic(objs, types, min) {
  var result = [];

  for (var i = 0; i < objs.length; ++i) {
    if (types.indexOf(objs[i]._class) > -1) {
      result.push(objs[i]);
    }
  }

  if (result.length < min) {
    throw "Illegal Argument. Constraint requires at least " + min + " of " + types;
  }

  return result;
}
function pointAndLine(objs) {
  var point = null;
  var line = null;

  for (var i = 0; i < objs.length; ++i) {
    if (objs[i]._class == 'TCAD.TWO.EndPoint') {
      point = objs[i];
    } else if (objs[i]._class == 'TCAD.TWO.Segment') {
      line = objs[i];
    }
  }

  if (point == null || line == null) {
    throw "Illegal Argument. Constraint requires point and line.";
  }

  return [point, line];
}
function line(objs) {
  for (var i = 0; i < objs.length; ++i) {
    if (objs[i]._class == 'TCAD.TWO.Segment') {
      return objs[i];
    }
  }

  throw "Illegal Argument. Constraint requires a line.";
}
function lines(objs) {
  return objs.filter(function (o) {
    return o._class == 'TCAD.TWO.Segment';
  });
}
function arcCircAndLine(objs) {
  var arc = null;
  var line = null;

  for (var i = 0; i < objs.length; ++i) {
    if (objs[i]._class === 'TCAD.TWO.Arc' || objs[i]._class === 'TCAD.TWO.Circle') {
      arc = objs[i];
    } else if (objs[i]._class == 'TCAD.TWO.Segment') {
      line = objs[i];
    }
  }

  if (arc == null || line == null) {
    throw "Illegal Argument. Constraint requires arc and line.";
  }

  return [arc, line];
}
function twoLines(objs) {
  var lines = [];

  for (var i = 0; i < objs.length; ++i) {
    if (objs[i]._class == 'TCAD.TWO.Segment') {
      lines.push(objs[i]);
    }
  }

  if (lines.length < 2) {
    throw "Illegal Argument. Constraint requires 2 lines.";
  }

  return lines;
}
function sketchObjects(objs, silent, matching) {
  var fetched = [];

  for (var i = 0; i < objs.length; ++i) {
    for (var j = 0; j < matching.length; j++) {
      if (objs[i]._class == matching[j]) {
        fetched[j] = objs[i];
        matching[j] = null;
      }
    }
  }

  if (fetched.length != matching.length) {
    if (silent) {
      return null;
    } else {
      throw "Illegal Argument. " + matching + " required";
    }
  }

  return fetched;
}

/***/ }),

/***/ "./web/app/sketcher/history.js":
/*!*************************************!*\
  !*** ./web/app/sketcher/history.js ***!
  \*************************************/
/*! exports provided: HistoryManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HistoryManager", function() { return HistoryManager; });
/* harmony import */ var diff_match_patch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! diff-match-patch */ "./node_modules/diff-match-patch/index.js");
/* harmony import */ var diff_match_patch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(diff_match_patch__WEBPACK_IMPORTED_MODULE_0__);

/** @constructor */

function HistoryManager(viewer) {
  this.viewer = viewer;
  this.dmp = new diff_match_patch__WEBPACK_IMPORTED_MODULE_0___default.a();
  this.init(this.viewer.io.serializeSketch());
}

HistoryManager.prototype.init = function (sketchData) {
  this.lastCheckpoint = sketchData;
  this.diffs = [];
  this.historyPointer = -1;
};

HistoryManager.prototype.undo = function () {
  var currentState = this.viewer.io.serializeSketch();

  if (currentState == this.lastCheckpoint) {
    if (this.historyPointer != -1) {
      var diff = this.diffs[this.historyPointer];
      this.lastCheckpoint = this.applyDiff(this.lastCheckpoint, diff);
      this.viewer.io.loadSketch(this.lastCheckpoint);
      this.viewer.fullHeavyUIRefresh();
      this.historyPointer--;
    }
  } else {
    var diffToCurr = this.getDiff(currentState, this.lastCheckpoint);

    if (this.historyPointer != this.diffs.length - 1) {
      this.diffs.splice(this.historyPointer + 1, this.diffs.length - this.historyPointer + 1);
    }

    this.diffs.push(diffToCurr);
    this.viewer.io.loadSketch(this.lastCheckpoint);
    this.viewer.fullHeavyUIRefresh();
  }
};

HistoryManager.prototype.lightCheckpoint = function (weight) {
  this._counter += weight;

  if (this._counter >= 100) {
    this.checkpoint();
  }
};

HistoryManager.prototype.checkpoint = function () {
  try {
    this._checkpoint();
  } catch (e) {
    console.log(e);
  }
};

HistoryManager.prototype._checkpoint = function () {
  this._counter = 0;
  var currentState = this.viewer.io.serializeSketch();

  if (currentState == this.lastCheckpoint) {
    return;
  }

  var diffToCurr = this.getDiff(currentState, this.lastCheckpoint);

  if (this.historyPointer != this.diffs.length - 1) {
    this.diffs.splice(this.historyPointer + 1, this.diffs.length - this.historyPointer + 1);
  }

  this.diffs.push(diffToCurr);
  this.historyPointer = this.diffs.length - 1;
  this.lastCheckpoint = currentState;
};

HistoryManager.prototype.redo = function () {
  var currentState = this.viewer.io.serializeSketch();

  if (currentState != this.lastCheckpoint) {
    return;
  }

  if (this.historyPointer != this.diffs.length - 1 && this.diffs.length != 0) {
    this.historyPointer++;
    var diff = this.diffs[this.historyPointer];
    this.lastCheckpoint = this.applyDiffInv(this.lastCheckpoint, diff);
    this.viewer.io.loadSketch(this.lastCheckpoint);
    this.viewer.fullHeavyUIRefresh();
  }
};

HistoryManager.prototype.applyDiff = function (text1, diff) {
  var dmp = this.dmp;
  var results = dmp.patch_apply(diff, text1);
  return results[0];
};

HistoryManager.prototype.applyDiffInv = function (text1, diff) {
  this.reversePatch(diff);
  var result = this.applyDiff(text1, diff);
  this.reversePatch(diff);
  return result;
};

HistoryManager.prototype.reversePatch = function (plist) {
  for (var i = 0; i < plist.length; i++) {
    var patch = plist[i];

    for (var j = 0; j < patch.diffs.length; j++) {
      var diff = patch.diffs[j];
      diff[0] *= -1;
    }
  }
};

HistoryManager.prototype.getDiff = function (text1, text2) {
  var dmp = this.dmp;
  var diff = dmp.diff_main(text1, text2, true);

  if (diff.length > 2) {
    dmp.diff_cleanupSemantic(diff);
  }

  var patch_list = dmp.patch_make(text1, text2, diff); //var patch_text = dmp.patch_toText(patch_list);
  //console.log(patch_list);

  return patch_list;
};



/***/ }),

/***/ "./web/app/sketcher/id-generator.js":
/*!******************************************!*\
  !*** ./web/app/sketcher/id-generator.js ***!
  \******************************************/
/*! exports provided: Generator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Generator", function() { return Generator; });
var ID_COUNTER = 0;
var Generator = {
  genID: function genID() {
    return ID_COUNTER++;
  },
  resetIDGenerator: function resetIDGenerator(value) {
    ID_COUNTER = value;
  }
};

/***/ }),

/***/ "./web/app/sketcher/input-manager.js":
/*!*******************************************!*\
  !*** ./web/app/sketcher/input-manager.js ***!
  \*******************************************/
/*! exports provided: InputManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputManager", function() { return InputManager; });
/* harmony import */ var _keymaps_default__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keymaps/default */ "./web/app/sketcher/keymaps/default.js");
/* harmony import */ var mousetrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mousetrap */ "./node_modules/mousetrap/mousetrap.js");
/* harmony import */ var mousetrap__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(mousetrap__WEBPACK_IMPORTED_MODULE_1__);


function InputManager(app) {
  var _this = this;

  this.app = app;
  this.keymap = _keymaps_default__WEBPACK_IMPORTED_MODULE_0__["keymap"];

  var _loop = function _loop() {
    var action = _Object$keys[_i];
    mousetrap__WEBPACK_IMPORTED_MODULE_1___default.a.bind(_keymaps_default__WEBPACK_IMPORTED_MODULE_0__["keymap"][action], function (e) {
      return _this.app.actions[action].action(e);
    });
  };

  for (var _i = 0, _Object$keys = Object.keys(_keymaps_default__WEBPACK_IMPORTED_MODULE_0__["keymap"]); _i < _Object$keys.length; _i++) {
    _loop();
  }
}

/***/ }),

/***/ "./web/app/sketcher/io.js":
/*!********************************!*\
  !*** ./web/app/sketcher/io.js ***!
  \********************************/
/*! exports provided: IO, BBox, Types */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IO", function() { return IO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BBox", function() { return BBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Types", function() { return Types; });
/* harmony import */ var _id_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id-generator */ "./web/app/sketcher/id-generator.js");
/* harmony import */ var _viewer2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewer2d */ "./web/app/sketcher/viewer2d.js");
/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./styles */ "./web/app/sketcher/styles.js");
/* harmony import */ var _shapes_arc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shapes/arc */ "./web/app/sketcher/shapes/arc.js");
/* harmony import */ var _shapes_point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shapes/point */ "./web/app/sketcher/shapes/point.js");
/* harmony import */ var _shapes_segment__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shapes/segment */ "./web/app/sketcher/shapes/segment.js");
/* harmony import */ var _shapes_circle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shapes/circle */ "./web/app/sketcher/shapes/circle.js");
/* harmony import */ var _shapes_ellipse__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shapes/ellipse */ "./web/app/sketcher/shapes/ellipse.js");
/* harmony import */ var _shapes_elliptical_arc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shapes/elliptical-arc */ "./web/app/sketcher/shapes/elliptical-arc.js");
/* harmony import */ var _shapes_bezier_curve__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./shapes/bezier-curve */ "./web/app/sketcher/shapes/bezier-curve.js");
/* harmony import */ var _shapes_dim__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./shapes/dim */ "./web/app/sketcher/shapes/dim.js");
/* harmony import */ var _parametric__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./parametric */ "./web/app/sketcher/parametric.js");
/* harmony import */ var _utils_hashmap__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utils/hashmap */ "./web/app/utils/hashmap.js");
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
/* harmony import */ var gems_exportTextData__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! gems/exportTextData */ "./modules/gems/exportTextData.js");
/* harmony import */ var _brep_geom_curves_nurbsCurve__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../brep/geom/curves/nurbsCurve */ "./web/app/brep/geom/curves/nurbsCurve.js");
/* harmony import */ var _shapes_nurbsObject__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./shapes/nurbsObject */ "./web/app/sketcher/shapes/nurbsObject.js");
/* harmony import */ var _system__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./system */ "./web/app/sketcher/system.js");


















var Types = {
  END_POINT: 'TCAD.TWO.EndPoint',
  SEGMENT: 'TCAD.TWO.Segment',
  ARC: 'TCAD.TWO.Arc',
  CIRCLE: 'TCAD.TWO.Circle',
  ELLIPSE: 'TCAD.TWO.Ellipse',
  ELL_ARC: 'TCAD.TWO.EllipticalArc',
  BEZIER: 'TCAD.TWO.BezierCurve',
  NURBS: 'TCAD.TWO.NurbsObject',
  DIM: 'TCAD.TWO.Dimension',
  HDIM: 'TCAD.TWO.HDimension',
  VDIM: 'TCAD.TWO.VDimension',
  DDIM: 'TCAD.TWO.DiameterDimension'
};
IO.BOUNDARY_LAYER_NAME = "__bounds__";
/** @constructor */

function IO(viewer) {
  this.viewer = viewer;
}

IO.prototype.loadSketch = function (sketchData) {
  return this._loadSketch(JSON.parse(sketchData));
};

IO.prototype.serializeSketch = function () {
  return JSON.stringify(this._serializeSketch());
};

IO.prototype._loadSketch = function (sketch) {
  this.cleanUpData();
  var index = {};

  function endPoint(p) {
    var id = p[0];
    var ep = index[id];

    if (ep !== undefined) {
      return;
    }

    ep = new _shapes_point__WEBPACK_IMPORTED_MODULE_4__["EndPoint"](p[1][1], p[2][1]);
    index[p[1][0]] = ep._x;
    index[p[2][0]] = ep._y;
    index[id] = ep;
    return ep;
  }

  var layerIdGen = 0;

  function getLayer(viewer, name) {
    if (name === undefined) {
      name = "layer_" + layerIdGen++;
    } else {
      if (name === viewer.dimLayer.name) {
        return viewer.dimLayer;
      }

      for (var i = 0; i < viewer.layers.length; ++i) {
        if (name === viewer.layers[i].name) {
          return viewer.layers[i];
        }
      }
    }

    var layer = viewer.createLayer(name, _styles__WEBPACK_IMPORTED_MODULE_2__["Styles"].DEFAULT);
    viewer.layers.push(layer);
    return layer;
  }

  var T = Types;
  var maxEdge = 0;
  var sketchLayers = sketch['layers'];
  var boundary = sketch['boundary'];
  var boundaryNeedsUpdate = !(boundary === undefined || boundary == null);

  if (sketchLayers !== undefined) {
    for (var l = 0; l < sketchLayers.length; ++l) {
      var ioLayer = sketchLayers[l];
      var layerName = ioLayer['name'];
      var boundaryProcessing = layerName == IO.BOUNDARY_LAYER_NAME && boundaryNeedsUpdate;
      var layer = getLayer(this.viewer, layerName);
      if (!!ioLayer.style) layer.style = ioLayer.style;
      layer.readOnly = !!ioLayer.readOnly;
      var layerData = ioLayer['data'];

      for (i = 0; i < layerData.length; ++i) {
        var obj = layerData[i];
        var skobj = null;
        var _class = obj['_class'];
        var aux = !!obj['aux'];
        var role = obj['role']; //support legacy format

        if (!role) {
          role = layerName === '_construction_' ? 'construction' : null;
        }

        if (boundaryProcessing) {
          if (_class === T.SEGMENT && boundary.lines.length == 0) continue;else if (_class === T.ARC && boundary.arcs.length == 0) continue;else if (_class === T.CIRCLE && boundary.circles.length == 0) continue;
        }

        if (_class === T.SEGMENT) {
          var points = obj['points'];
          var a = endPoint(points[0]);
          var b = endPoint(points[1]);
          skobj = new _shapes_segment__WEBPACK_IMPORTED_MODULE_5__["Segment"](a, b);
        } else if (_class === T.END_POINT) {
          skobj = endPoint(obj['location']);
        } else if (_class === T.ARC) {
          var _points = obj['points'];

          var _a = endPoint(_points[0]);

          var _b = endPoint(_points[1]);

          var c = endPoint(_points[2]);
          skobj = new _shapes_arc__WEBPACK_IMPORTED_MODULE_3__["Arc"](_a, _b, c);
        } else if (_class === T.CIRCLE) {
          var _c = endPoint(obj['c']);

          skobj = new _shapes_circle__WEBPACK_IMPORTED_MODULE_6__["Circle"](_c);
          skobj.r.set(obj['r']);
        } else if (_class === T.ELLIPSE) {
          var ep1 = endPoint(obj['ep1']);
          var ep2 = endPoint(obj['ep2']);
          skobj = new _shapes_ellipse__WEBPACK_IMPORTED_MODULE_7__["Ellipse"](ep1, ep2);
          skobj.r.set(obj['r']);
        } else if (_class === T.ELL_ARC) {
          var _ep = endPoint(obj['ep1']);

          var _ep2 = endPoint(obj['ep2']);

          var _a2 = endPoint(obj['a']);

          var _b2 = endPoint(obj['b']);

          skobj = new _shapes_elliptical_arc__WEBPACK_IMPORTED_MODULE_8__["EllipticalArc"](_ep, _ep2, _a2, _b2);
          skobj.r.set(obj['r']);
        } else if (_class === T.BEZIER) {
          var _a3 = endPoint(obj['a']);

          var _b3 = endPoint(obj['b']);

          var cp1 = endPoint(obj['cp1']);
          var cp2 = endPoint(obj['cp2']);
          skobj = new _shapes_bezier_curve__WEBPACK_IMPORTED_MODULE_9__["BezierCurve"](_a3, _b3, cp1, cp2);
        } else if (_class === T.HDIM) {
          skobj = new _shapes_dim__WEBPACK_IMPORTED_MODULE_10__["HDimension"](obj['a'], obj['b']);
          skobj.flip = obj['flip'];
        } else if (_class === T.VDIM) {
          skobj = new _shapes_dim__WEBPACK_IMPORTED_MODULE_10__["VDimension"](obj['a'], obj['b']);
          skobj.flip = obj['flip'];
        } else if (_class === T.DIM) {
          skobj = new _shapes_dim__WEBPACK_IMPORTED_MODULE_10__["Dimension"](obj['a'], obj['b']);
          skobj.flip = obj['flip'];
        } else if (_class === T.DDIM) {
          skobj = new _shapes_dim__WEBPACK_IMPORTED_MODULE_10__["DiameterDimension"](obj['obj']);
        }

        if (skobj != null) {
          skobj.role = role;
          if (!aux) skobj.stabilize(this.viewer);
          if (aux) skobj.accept(function (o) {
            o.aux = true;
            return true;
          });

          if (obj['edge'] !== undefined) {
            skobj.edge = obj['edge'];
            maxEdge = Math.max(maxEdge, skobj.edge);
          }

          layer.add(skobj);
          index[obj['id']] = skobj; //reindex non point children to recover constraints

          var childrenIds = obj['children'];

          if (childrenIds) {
            var children = nonPointChildren(skobj);

            for (var childIdx = 0; childIdx < childrenIds.length; childIdx++) {
              index[childrenIds[childIdx]] = children[childIdx];
            }
          }
        }

        if (boundaryProcessing) {
          if (_class === T.SEGMENT) this.synchLine(skobj, boundary.lines.shift());else if (_class === T.ARC) this.synchArc(skobj, boundary.arcs.shift());else if (_class === T.CIRCLE) this.synchCircle(skobj, boundary.circles.shift());
        }
      }
    }
  }

  for (i = 0; i < this.viewer.dimLayer.objects.length; ++i) {
    obj = this.viewer.dimLayer.objects[i];

    if (obj._class === T.DIM || obj._class === T.HDIM || obj._class === T.VDIM) {
      obj.a = index[obj.a];
      obj.b = index[obj.b];
    } else if (obj._class === T.DDIM) {
      obj.obj = index[obj.obj];
    }
  }

  if (boundaryNeedsUpdate) {
    this.addNewBoundaryObjects(boundary, maxEdge);
  }

  var boundaryLayer = this.viewer.findLayerByName(IO.BOUNDARY_LAYER_NAME);

  if (boundaryLayer != null) {
    this.linkEndPoints(boundaryLayer.objects);
  }

  var sketchConstraints = sketch['constraints'];

  if (sketchConstraints !== undefined) {
    for (var i = 0; i < sketchConstraints.length; ++i) {
      try {
        var _c2 = this.parseConstr(sketchConstraints[i], index);

        this.viewer.parametricManager._add(_c2);
      } catch (msg) {
        console.info("Skipping. " + msg);
      }
    }

    this.viewer.parametricManager.notify();
  }

  var constants = sketch['constants'];

  if (constants !== undefined) {
    this.viewer.params.constantDefinition = constants;
  }
};

IO.prototype.linkEndPoints = function (objects) {
  var index = _utils_hashmap__WEBPACK_IMPORTED_MODULE_12__["HashTable"].forVector2d();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = objects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var obj = _step.value;
      obj.accept(function (o) {
        if (o._class == Types.END_POINT) {
          var equalPoint = index.get(o);

          if (equalPoint == null) {
            index.put(o, o);
          } else {
            o.linked.push(equalPoint);
            equalPoint.linked.push(o);
          }
        }

        return true;
      });
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

IO.prototype.synchLine = function (skobj, edgeObj) {
  skobj.a.x = edgeObj.a.x;
  skobj.a.y = edgeObj.a.y;
  skobj.b.x = edgeObj.b.x;
  skobj.b.y = edgeObj.b.y;
};

IO.prototype.synchArc = function (skobj, edgeObj) {
  skobj.a.x = edgeObj.a.x;
  skobj.a.y = edgeObj.a.y;
  skobj.b.x = edgeObj.b.x;
  skobj.b.y = edgeObj.b.y;
  skobj.c.x = edgeObj.c.x;
  skobj.c.y = edgeObj.c.y;
};

IO.prototype.synchCircle = function (skobj, edgeObj) {
  skobj.c.x = edgeObj.c.x;
  skobj.c.y = edgeObj.c.y;
  skobj.r.set(edgeObj.r);
};

IO.prototype.addNewBoundaryObjects = function (boundary, maxEdge) {
  var boundaryLayer = this.viewer.findLayerByName(IO.BOUNDARY_LAYER_NAME);

  if (boundaryLayer === null) {
    boundaryLayer = this.viewer.createLayer(IO.BOUNDARY_LAYER_NAME, _styles__WEBPACK_IMPORTED_MODULE_2__["Styles"].BOUNDS);
    this.viewer.layers.splice(0, 0, boundaryLayer);
  }

  boundaryLayer.readOnly = true;
  boundaryLayer.style = _styles__WEBPACK_IMPORTED_MODULE_2__["Styles"].BOUNDS;
  var i,
      obj,
      id = maxEdge + 1;

  function __processAux(obj) {
    obj.edge = id++;
    obj.accept(function (o) {
      o.aux = true;
      return true;
    });
  }

  for (i = 0; i < boundary.lines.length; ++i) {
    var edge = boundary.lines[i];
    var seg = this.viewer.addSegment(edge.a.x, edge.a.y, edge.b.x, edge.b.y, boundaryLayer);

    __processAux(seg);
  }

  for (i = 0; i < boundary.arcs.length; ++i) {
    var a = boundary.arcs[i];
    var arc = new _shapes_arc__WEBPACK_IMPORTED_MODULE_3__["Arc"](new _shapes_point__WEBPACK_IMPORTED_MODULE_4__["EndPoint"](a.a.x, a.a.y), new _shapes_point__WEBPACK_IMPORTED_MODULE_4__["EndPoint"](a.b.x, a.b.y), new _shapes_point__WEBPACK_IMPORTED_MODULE_4__["EndPoint"](a.c.x, a.c.y));
    boundaryLayer.objects.push(arc);

    __processAux(arc);
  }

  for (i = 0; i < boundary.circles.length; ++i) {
    obj = boundary.circles[i];
    var circle = new _shapes_circle__WEBPACK_IMPORTED_MODULE_6__["Circle"](new _shapes_point__WEBPACK_IMPORTED_MODULE_4__["EndPoint"](obj.c.x, obj.c.y));
    circle.r.set(obj.r);
    boundaryLayer.objects.push(circle);

    __processAux(circle);
  }

  for (i = 0; i < boundary.nurbses.length; ++i) {
    var nurbsData = boundary.nurbses[i];
    var nurbs = new _shapes_nurbsObject__WEBPACK_IMPORTED_MODULE_16__["NurbsObject"](_brep_geom_curves_nurbsCurve__WEBPACK_IMPORTED_MODULE_15__["default"].deserialize(nurbsData), new _shapes_point__WEBPACK_IMPORTED_MODULE_4__["EndPoint"](), new _shapes_point__WEBPACK_IMPORTED_MODULE_4__["EndPoint"]());
    boundaryLayer.objects.push(nurbs);

    __processAux(nurbs);
  }
};

IO.prototype.cleanUpData = function () {
  for (var l = 0; l < this.viewer.layers.length; ++l) {
    var layer = this.viewer.layers[l];

    if (layer.objects.length != 0) {
      layer.objects = [];
    }
  }

  this.viewer.deselectAll();
  _id_generator__WEBPACK_IMPORTED_MODULE_0__["Generator"].resetIDGenerator(0);

  if (this.viewer.parametricManager.system.subSystems.length !== 0) {
    this.viewer.parametricManager.system = new _system__WEBPACK_IMPORTED_MODULE_17__["System"]();
    this.viewer.parametricManager.notify();
  }
};

IO.prototype._serializeSketch = function () {
  var sketch = {}; //sketch.boundary = boundary;

  sketch['layers'] = [];

  function point(p) {
    return [p.id, [p._x.id, p.x], [p._y.id, p.y]];
  }

  var T = Types;
  var toSave = [this.viewer.dimLayers, this.viewer.layers];

  for (var t = 0; t < toSave.length; ++t) {
    var layers = toSave[t];

    for (var l = 0; l < layers.length; ++l) {
      var layer = layers[l];
      var toLayer = {
        'name': layer.name,
        style: layer.style,
        readOnly: layer.readOnly,
        'data': []
      };
      sketch['layers'].push(toLayer);

      for (var i = 0; i < layer.objects.length; ++i) {
        var obj = layer.objects[i];
        var to = {
          'id': obj.id,
          '_class': obj._class,
          role: obj.role
        };
        if (obj.aux) to.aux = obj.aux;
        if (obj.edge !== undefined) to.edge = obj.edge;
        toLayer['data'].push(to);

        if (obj._class === T.SEGMENT) {
          to['points'] = [point(obj.a), point(obj.b)];
        } else if (obj._class === T.END_POINT) {
          to['location'] = point(obj);
        } else if (obj._class === T.ARC) {
          to['points'] = [point(obj.a), point(obj.b), point(obj.c)];
        } else if (obj._class === T.CIRCLE) {
          to['c'] = point(obj.c);
          to['r'] = obj.r.get();
        } else if (obj._class === T.ELLIPSE) {
          to['ep1'] = point(obj.ep1);
          to['ep2'] = point(obj.ep2);
          to['r'] = obj.r.get();
        } else if (obj._class === T.ELL_ARC) {
          to['ep1'] = point(obj.ep1);
          to['ep2'] = point(obj.ep2);
          to['a'] = point(obj.a);
          to['b'] = point(obj.b);
          to['r'] = obj.r.get();
        } else if (obj._class === T.BEZIER) {
          to['a'] = point(obj.a);
          to['b'] = point(obj.b);
          to['cp1'] = point(obj.cp1);
          to['cp2'] = point(obj.cp2);
        } else if (obj._class === T.DIM || obj._class === T.HDIM || obj._class === T.VDIM) {
          to['a'] = obj.a.id;
          to['b'] = obj.b.id;
          to['flip'] = obj.flip;
        } else if (obj._class === T.DDIM) {
          to['obj'] = obj.obj.id;
        }

        var children = nonPointChildren(obj).map(function (c) {
          return c.id;
        });

        if (children.length != 0) {
          to['children'] = children;
        }
      }
    }
  }

  var constrs = sketch['constraints'] = [];
  var subSystems = this.viewer.parametricManager.system.subSystems;

  for (var j = 0; j < subSystems.length; j++) {
    var sub = subSystems[j];

    for (i = 0; i < sub.constraints.length; ++i) {
      if (!sub.constraints[i].aux) {
        constrs.push(this.serializeConstr(sub.constraints[i]));
      }
    }
  }

  var constantDefinition = this.viewer.params.constantDefinition;

  if (constantDefinition !== undefined && constantDefinition != null && !/^\s*$/.test(constantDefinition)) {
    sketch['constants'] = constantDefinition;
  }

  return sketch;
};

function nonPointChildren(obj) {
  var children = [];
  obj.accept(function (o) {
    if (o._class !== Types.END_POINT) {
      children.push(o);
    }

    return true;
  });
  return children;
}

IO.prototype.parseConstr = function (c, index) {
  var name = c[0];
  var ps = c[1];

  function find(id) {
    var p = index[id];

    if (!p) {
      throw "Constraint " + name + " refers to nonexistent object.";
    }

    return p;
  }

  var constrCreate = _parametric__WEBPACK_IMPORTED_MODULE_11__["Constraints"].Factory[name];

  if (constrCreate === undefined) {
    throw "Constraint " + name + " doesn't exist.";
  }

  return constrCreate(find, ps);
};

IO.prototype.serializeConstr = function (c) {
  return c.serialize();
};

function _format(str, args) {
  if (args.length == 0) return str;
  var i = 0;
  return str.replace(/\$/g, function () {
    if (args === undefined || args[i] === undefined) throw "format arguments mismatch";
    var val = args[i];
    if (typeof val === 'number') val = val.toPrecision();
    i++;
    return val;
  });
}
/** @constructor */


function PrettyColors() {
  var colors = ["#000000", "#00008B", "#006400", "#8B0000", "#FF8C00", "#E9967A"];
  var colIdx = 0;

  this.next = function () {
    return colors[colIdx++ % colors.length];
  };
}
/** @constructor */


function TextBuilder() {
  this.data = "";

  this.fline = function (chunk, args) {
    this.data += _format(chunk, args) + "\n";
  };

  this.line = function (chunk) {
    this.data += chunk + "\n";
  };

  this.number = function (n) {
    this.data += n.toPrecision();
  };

  this.numberln = function (n) {
    this.number(n);
    this.data += "\n";
  };
}
/** @constructor */


function BBox() {
  var bbox = [Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE];
  var T = Types;

  this.checkLayers = function (layers) {
    for (var l = 0; l < layers.length; ++l) {
      for (var i = 0; i < layers[l].objects.length; ++i) {
        this.check(layers[l].objects[i]);
      }
    }
  };

  this.check = function (obj) {
    var _this = this;

    if (obj._class === T.SEGMENT) {
      this.checkBounds(obj.a.x, obj.a.y);
      this.checkBounds(obj.b.x, obj.b.y);
    } else if (obj._class === T.END_POINT) {
      this.checkBounds(obj.x, obj.y);
    } else if (obj._class === T.ARC) {
      this.checkCircBounds(obj.c.x, obj.c.y, obj.r.get());
    } else if (obj._class === T.CIRCLE) {
      this.checkCircBounds(obj.c.x, obj.c.y, obj.r.get());
    } else if (obj._class === T.ELLIPSE || obj._class === T.ELL_ARC) {
      this.checkCircBounds(obj.centerX, obj.centerY, Math.max(obj.radiusX, obj.radiusY));
    } else if (obj) {
      obj.accept(function (o) {
        if (o._class == T.END_POINT) {
          _this.checkBounds(o.x, o.y);
        }

        return true;
      }); //    } else if (obj._class === T.DIM || obj._class === T.HDIM || obj._class === T.VDIM) {
    }
  };

  this.isValid = function () {
    return bbox[0] != Number.MAX_VALUE;
  };

  this.checkBounds = function (x, y) {
    bbox[0] = Math.min(bbox[0], x);
    bbox[1] = Math.min(bbox[1], y);
    bbox[2] = Math.max(bbox[2], x);
    bbox[3] = Math.max(bbox[3], y);
  };

  this.checkCircBounds = function (x, y, r) {
    this.checkBounds(x + r, y + r);
    this.checkBounds(x - r, y + r);
    this.checkBounds(x - r, y - r);
    this.checkBounds(x - r, y + r);
  };

  this.inc = function (by) {
    bbox[0] -= by;
    bbox[1] -= by;
    bbox[2] += by;
    bbox[3] += by;
  };

  this.width = function () {
    return bbox[2] - bbox[0];
  };

  this.height = function () {
    return bbox[3] - bbox[1];
  };

  this.bbox = bbox;
}

IO.prototype.getWorkspaceToExport = function () {
  return [this.viewer.layers];
};

IO.prototype.getLayersToExport = function () {
  var ws = this.getWorkspaceToExport();
  var toExport = [];

  for (var t = 0; t < ws.length; ++t) {
    var layers = ws[t];

    for (var l = 0; l < layers.length; ++l) {
      var layer = layers[l];
      toExport.push(layer);
    }
  }

  return toExport;
};

IO.prototype.svgExport = function () {
  var T = Types;
  var out = new TextBuilder();
  var bbox = new BBox();
  var a = new math_vector__WEBPACK_IMPORTED_MODULE_13__["default"]();
  var b = new math_vector__WEBPACK_IMPORTED_MODULE_13__["default"]();
  var prettyColors = new PrettyColors();
  var toExport = this.getLayersToExport();

  for (var l = 0; l < toExport.length; ++l) {
    var layer = toExport[l];
    var color = prettyColors.next();
    out.fline('<g id="$" fill="$" stroke="$" stroke-width="$">', [layer.name, "none", color, '2']);

    for (var i = 0; i < layer.objects.length; ++i) {
      var obj = layer.objects[i];
      if (obj._class !== T.END_POINT) bbox.check(obj);

      if (obj._class === T.SEGMENT) {
        out.fline('<line x1="$" y1="$" x2="$" y2="$" />', [obj.a.x, obj.a.y, obj.b.x, obj.b.y]);
      } else if (obj._class === T.ARC) {
        a.set(obj.a.x - obj.c.x, obj.a.y - obj.c.y, 0);
        b.set(obj.b.x - obj.c.x, obj.b.y - obj.c.y, 0);
        var dir = a.cross(b).z > 0 ? 0 : 1;
        var r = obj.r.get();
        out.fline('<path d="M $ $ A $ $ 0 $ $ $ $" />', [obj.a.x, obj.a.y, r, r, dir, 1, obj.b.x, obj.b.y]);
      } else if (obj._class === T.CIRCLE) {
        out.fline('<circle cx="$" cy="$" r="$" />', [obj.c.x, obj.c.y, obj.r.get()]); //      } else if (obj._class === T.DIM || obj._class === T.HDIM || obj._class === T.VDIM) {
      }
    }

    out.line('</g>');
  }

  bbox.inc(20);
  return _format("<svg viewBox='$ $ $ $'>\n", bbox.bbox) + out.data + "</svg>";
};

IO.prototype.dxfExport = function () {
  var T = Types;
  var out = new TextBuilder();
  var bbox = new BBox();
  var toExport = this.getLayersToExport();
  var i;
  bbox.checkLayers(toExport);
  out.line("999");
  out.line("js.parametric.sketcher");
  out.line("0");
  out.line("SECTION");
  out.line("2");
  out.line("HEADER");
  out.line("9");
  out.line("$ACADVER");
  out.line("1");
  out.line("AC1006");
  out.line("9");
  out.line("$INSBASE");
  out.line("10");
  out.line("0");
  out.line("20");
  out.line("0");
  out.line("30");
  out.line("0");
  out.line("9");
  out.line("$EXTMIN");
  out.line("10");
  out.numberln(bbox.bbox[0]);
  out.line("20");
  out.numberln(bbox.bbox[1]);
  out.line("9");
  out.line("$EXTMAX");
  out.line("10");
  out.numberln(bbox.bbox[2]);
  out.line("20");
  out.numberln(bbox.bbox[3]);
  out.line("0");
  out.line("ENDSEC");
  out.line("0");
  out.line("SECTION");
  out.line("2");
  out.line("TABLES");

  for (i = 0; i < toExport.length; i++) {
    out.line("0");
    out.line("LAYER");
    out.line("2");
    out.line("" + (i + 1));
    out.line("70");
    out.line("64");
    out.line("62");
    out.line("7");
    out.line("6");
    out.line("CONTINUOUS");
  }

  out.line("0");
  out.line("ENDTAB");
  out.line("0");
  out.line("ENDSEC");
  out.line("0");
  out.line("SECTION");
  out.line("2");
  out.line("BLOCKS");
  out.line("0");
  out.line("ENDSEC");
  out.line("0");
  out.line("SECTION");
  out.line("2");
  out.line("ENTITIES");

  for (var l = 0; l < toExport.length; l++) {
    var lid = l + 1;
    var layer = toExport[l];

    for (i = 0; i < layer.objects.length; ++i) {
      var obj = layer.objects[i];

      if (obj._class === T.END_POINT) {
        out.line("0");
        out.line("POINT");
        out.line("8");
        out.line(lid);
        out.line("10");
        out.numberln(obj.x);
        out.line("20");
        out.numberln(obj.y);
        out.line("30");
        out.line("0");
      } else if (obj._class === T.SEGMENT) {
        out.line("0");
        out.line("LINE");
        out.line("8");
        out.line(lid); //out.line("62"); color
        //out.line("4");

        out.line("10");
        out.numberln(obj.a.x);
        out.line("20");
        out.numberln(obj.a.y);
        out.line("30");
        out.line("0");
        out.line("11");
        out.numberln(obj.b.x);
        out.line("21");
        out.numberln(obj.b.y);
        out.line("31");
        out.line("0");
      } else if (obj._class === T.ARC) {
        out.line("0");
        out.line("ARC");
        out.line("8");
        out.line(lid);
        out.line("10");
        out.numberln(obj.c.x);
        out.line("20");
        out.numberln(obj.c.y);
        out.line("30");
        out.line("0");
        out.line("40");
        out.numberln(obj.r.get());
        out.line("50");
        out.numberln(obj.getStartAngle() * (180 / Math.PI));
        out.line("51");
        out.numberln(obj.getEndAngle() * (180 / Math.PI));
      } else if (obj._class === T.CIRCLE) {
        out.line("0");
        out.line("CIRCLE");
        out.line("8");
        out.line(lid);
        out.line("10");
        out.numberln(obj.c.x);
        out.line("20");
        out.numberln(obj.c.y);
        out.line("30");
        out.line("0");
        out.line("40");
        out.numberln(obj.r.get()); //      } else if (obj._class === T.DIM || obj._class === T.HDIM || obj._class === T.VDIM) {
      }
    }
  }

  out.line("0");
  out.line("ENDSEC");
  out.line("0");
  out.line("EOF");
  return out.data;
};

IO.exportTextData = gems_exportTextData__WEBPACK_IMPORTED_MODULE_14__["default"];


/***/ }),

/***/ "./web/app/sketcher/keymaps/default.js":
/*!*********************************************!*\
  !*** ./web/app/sketcher/keymaps/default.js ***!
  \*********************************************/
/*! exports provided: keymap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keymap", function() { return keymap; });
var keymap = {
  'save': 'ctrl+s',
  'open': 'ctrl+o',
  'new': 'ctrl+n',
  'terminal': '`',
  'info': 'F1'
};

/***/ }),

/***/ "./web/app/sketcher/parametric.js":
/*!****************************************!*\
  !*** ./web/app/sketcher/parametric.js ***!
  \****************************************/
/*! exports provided: Constraints, ParametricManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricManager", function() { return ParametricManager; });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils */ "./web/app/utils/utils.js");
/* harmony import */ var _shapes_ref__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shapes/ref */ "./web/app/sketcher/shapes/ref.js");
/* harmony import */ var _constr_solver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constr/solver */ "./web/app/sketcher/constr/solver.js");
/* harmony import */ var _constr_solverConstraints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constr/solverConstraints */ "./web/app/sketcher/constr/solverConstraints.js");
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/math */ "./web/app/math/math.js");
/* harmony import */ var _fetchers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fetchers */ "./web/app/sketcher/fetchers.js");
/* harmony import */ var _io__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./io */ "./web/app/sketcher/io.js");
/* harmony import */ var _shapes_sketch_object__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shapes/sketch-object */ "./web/app/sketcher/shapes/sketch-object.js");
/* harmony import */ var _system__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./system */ "./web/app/sketcher/system.js");
/* harmony import */ var _constraints__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./constraints */ "./web/app/sketcher/constraints.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Constraints", function() { return _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"]; });

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }











/** @constructor */

var ParametricManager =
/*#__PURE__*/
function () {
  function ParametricManager(viewer) {
    _classCallCheck(this, ParametricManager);

    this.viewer = viewer;
    this.system = new _system__WEBPACK_IMPORTED_MODULE_9__["System"]();
    this.constantTable = {};
    this.viewer.params.define('constantDefinition', null);
    this.viewer.params.subscribe('constantDefinition', 'parametricManager', this.onConstantsExternalChange, this)();
    this.constantResolver = this.createConstantResolver();

    this.messageSink = function (msg) {
      return alert(msg);
    };
  }

  _createClass(ParametricManager, [{
    key: "subSystems",
    get: function get() {
      return this.system.subSystems;
    }
  }]);

  return ParametricManager;
}();

ParametricManager.prototype.createConstantResolver = function () {
  var pm = this;
  return function (value) {
    var _value = pm.constantTable[value];

    if (_value !== undefined) {
      value = _value;
    } else if (typeof value != 'number') {
      console.error("unable to resolve constant " + value);
    }

    return value;
  };
};

ParametricManager.prototype.notify = function (event) {
  this.viewer.streams.constraintsUpdate.next(event);
};

ParametricManager.prototype.rebuildConstantTable = function (constantDefinition) {
  this.constantTable = {};
  if (constantDefinition == null) return;
  var lines = constantDefinition.split('\n');
  var prefix = "(function() { \n";

  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    var m = line.match(/^\s*([^\s]+)\s*=(.+)$/);

    if (m != null && m.length == 3) {
      var constant = m[1];

      try {
        var value = eval(prefix + "return " + m[2] + "; \n})()");
        this.constantTable[constant] = value;
        prefix += "const " + constant + " = " + value + ";\n";
      } catch (e) {
        console.log(e);
      }
    }
  }
};

ParametricManager.prototype.onConstantsExternalChange = function (constantDefinition) {
  this.rebuildConstantTable(constantDefinition);
  this.refresh();
};

ParametricManager.prototype.defineNewConstant = function (name, value) {
  var constantDefinition = this.viewer.params.constantDefinition;
  var constantText = name + ' = ' + value;

  if (constantDefinition) {
    constantDefinition += '\n' + constantText;
  } else {
    constantDefinition = constantText;
  }

  this.rebuildConstantTable(constantDefinition); //disabling onConstantsExternalChange since we don't need re-solve  

  this.viewer.params.set('constantDefinition', constantDefinition, 'parametricManager');
};

ParametricManager.prototype.tune = function (subSystem) {};

ParametricManager.prototype._add = function (constr) {
  this.system.add(constr);
};

ParametricManager.prototype.checkRedundancy = function (subSystem, causingSubject) {
  var solver = this.prepare([]);

  if (solver.hasConflicts()) {
    this.messageSink("Most likely this " + causingSubject + " constraint is CONFLICTING!");
  }
};

ParametricManager.prototype.refresh = function () {
  this.solve();
  this.notify();
  this.viewer.refresh();
};

ParametricManager.prototype.add = function (constr) {
  this.viewer.historyManager.checkpoint();

  this._add(constr);

  this.checkRedundancy(constr.NAME);
  this.refresh();
};

ParametricManager.prototype.addAll = function (constrs) {
  for (var i = 0; i < constrs.length; i++) {
    var subSystem = this._add(constrs[i]);

    this.checkRedundancy(constrs[i].NAME);
  }

  this.refresh();
};

ParametricManager.prototype.cleanUpOnRemove = function (constr) {
  if (constr.NAME === 'coi') {
    this.unlinkObjects(constr.a, constr.b);
  }
};

ParametricManager.prototype.remove = function (constr) {
  this.viewer.historyManager.checkpoint();
  this.cleanUpOnRemove(constr);
  this.system.remove(constr);

  if (constr.GENERATOR) {
    this.removeObjects(constr.getGeneratedObjects());
  }

  this.refresh();
};

ParametricManager.prototype.removeObjects = function (objects) {
  var _this = this;

  var toRemove = new Set();
  var dependants = [];
  objects.forEach(function (obj) {
    return obj.visitParams(function (p) {
      var constraints = _this.system.paramToConstraintsIndex.get(p);

      if (constraints) {
        constraints.forEach(function (constr) {
          if (constr.GENERATOR) {
            constr.getGeneratedObjects().forEach(function (o) {
              return dependants.push(o);
            });
          }
        });
      }
    });
  });
  objects.forEach(function (obj) {
    return obj.visitParams(function (p) {
      var constraints = _this.system.paramToConstraintsIndex.get(p);

      if (constraints) {
        constraints.forEach(function (constr) {
          toRemove.add(constr);
        });
      }
    });
  });
  objects.forEach(function (obj) {
    if (obj.layer != null) {
      obj.layer.remove(obj);
    }
  });

  if (toRemove.size !== 0) {
    toRemove.forEach(function (constr) {
      _this.cleanUpOnRemove(constr);
    });
    var survivedConstraints = [];
    this.system.constraints.forEach(function (c) {
      if (!toRemove.has(c)) {
        survivedConstraints.push(c);
      }
    });
    this.system.setConstraints(survivedConstraints);
    this.notify();
  }

  if (dependants.length > 0) {
    this.removeObjects(dependants);
  }
};

ParametricManager.prototype.lock = function (objs) {
  var p = _fetchers__WEBPACK_IMPORTED_MODULE_6__["points"](objs);

  for (var i = 0; i < p.length; ++i) {
    this._add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].Lock(p[i], {
      x: p[i].x,
      y: p[i].y
    }));
  }

  this.refresh();
};

ParametricManager.prototype.vertical = function (objs) {
  this.addAll(_fetchers__WEBPACK_IMPORTED_MODULE_6__["lines"](objs).map(function (line) {
    return new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].Vertical(line);
  }));
};

ParametricManager.prototype.horizontal = function (objs) {
  this.addAll(_fetchers__WEBPACK_IMPORTED_MODULE_6__["lines"](objs).map(function (line) {
    return new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].Horizontal(line);
  }));
};

ParametricManager.prototype.parallel = function (objs) {
  var lines = _fetchers__WEBPACK_IMPORTED_MODULE_6__["lines"](objs);
  var constraints = [];

  for (var i = 1; i < lines.length; i++) {
    constraints.push(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].Parallel(lines[i - 1], lines[i]));
  }

  this.addAll(constraints);
};

ParametricManager.prototype.perpendicular = function (objs) {
  var lines = _fetchers__WEBPACK_IMPORTED_MODULE_6__["twoLines"](objs);
  this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].Perpendicular(lines[0], lines[1]));
};

ParametricManager.prototype.lockConvex = function (objs, warnCallback) {
  var lines = _fetchers__WEBPACK_IMPORTED_MODULE_6__["twoLines"](objs);
  var l1 = lines[0];
  var l2 = lines[1];
  var pts = [l1.a, l1.b, l2.a, l2.b];

  function isLinked(p1, p2) {
    for (var i = 0; i < p1.linked.length; ++i) {
      if (p1.linked[i].id === p2.id) {
        return true;
      }
    }

    return false;
  }

  function swap(arr, i1, i2) {
    var _ = arr[i1];
    arr[i1] = arr[i2];
    arr[i2] = _;
  }

  if (isLinked(pts[0], pts[2])) {
    swap(pts, 0, 1);
  } else if (isLinked(pts[0], pts[3])) {
    swap(pts, 0, 1);
    swap(pts, 2, 3);
  } else if (isLinked(pts[1], pts[3])) {
    swap(pts, 2, 3);
  } else if (isLinked(pts[1], pts[2])) {//we are good
  } else {
    warnCallback("Lines must be connected");
    return;
  }

  var c = pts[0];
  var a = pts[1];
  var t = pts[3]; // ||ac x at|| > 0 

  var crossNorma = (c.x - a.x) * (t.y - a.y) - (c.y - a.y) * (t.x - a.x);

  if (crossNorma < 0) {
    var _ = c;
    c = t;
    t = _;
  }

  this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].LockConvex(c, a, t));
};

ParametricManager.prototype.tangent = function (objs) {
  var curves = _fetchers__WEBPACK_IMPORTED_MODULE_6__["generic"](objs, ['TCAD.TWO.NurbsObject'], 0);
  var ellipses = _fetchers__WEBPACK_IMPORTED_MODULE_6__["generic"](objs, ['TCAD.TWO.Ellipse', 'TCAD.TWO.EllipticalArc'], 0);
  var lines = _fetchers__WEBPACK_IMPORTED_MODULE_6__["generic"](objs, ['TCAD.TWO.Segment'], 1);

  if (ellipses.length > 0) {
    this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].EllipseTangent(lines[0], ellipses[0]));
  } else if (curves.length > 0) {
    this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].CurveTangent(lines[0], curves[0]));
  } else {
    var arcs = _fetchers__WEBPACK_IMPORTED_MODULE_6__["generic"](objs, ['TCAD.TWO.Arc', 'TCAD.TWO.Circle'], 1);
    this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].Tangent(arcs[0], lines[0]));
  }
};

ParametricManager.prototype.rr = function (arcs) {
  var prev = arcs[0];

  for (var i = 1; i < arcs.length; ++i) {
    this._add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].RR(prev, arcs[i]));

    prev = arcs[i];
  }

  this.refresh();
};

ParametricManager.prototype.ll = function (lines) {
  var prev = lines[0];

  for (var i = 1; i < lines.length; ++i) {
    this._add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].LL(prev, lines[i]));

    prev = lines[i];
  }

  this.refresh();
};

ParametricManager.prototype.entityEquality = function (objs) {
  var arcs = _fetchers__WEBPACK_IMPORTED_MODULE_6__["generic"](objs, ['TCAD.TWO.Arc', 'TCAD.TWO.Circle'], 0);
  var lines = _fetchers__WEBPACK_IMPORTED_MODULE_6__["generic"](objs, ['TCAD.TWO.Segment'], 0);
  if (arcs.length > 0) this.rr(arcs);
  if (lines.length > 0) this.ll(lines);
};

ParametricManager.prototype.p2lDistance = function (objs, promptCallback) {
  var pl = _fetchers__WEBPACK_IMPORTED_MODULE_6__["pointAndLine"](objs);
  var target = pl[0];
  var segment = pl[1];
  var ex = new math_vector__WEBPACK_IMPORTED_MODULE_4__["default"](-(segment.b.y - segment.a.y), segment.b.x - segment.a.x).normalize();
  var distance = Math.abs(ex.dot(new math_vector__WEBPACK_IMPORTED_MODULE_4__["default"](segment.a.x - target.x, segment.a.y - target.y)));
  var promptDistance = _utils_utils__WEBPACK_IMPORTED_MODULE_0__["askNumber"](_constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].P2LDistance.prototype.SettableFields.d, distance.toFixed(2), promptCallback, this.constantResolver);

  if (promptDistance != null) {
    this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].P2LDistance(target, segment, promptDistance));
  }
};

ParametricManager.prototype.pointInMiddle = function (objs) {
  var pl = _fetchers__WEBPACK_IMPORTED_MODULE_6__["pointAndLine"](objs);
  this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].PointInMiddle(pl[0], pl[1]));
};

ParametricManager.prototype.symmetry = function (objs) {
  var pl = _fetchers__WEBPACK_IMPORTED_MODULE_6__["pointAndLine"](objs);
  this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].Symmetry(pl[0], pl[1]));
};

ParametricManager.prototype.pointOnArc = function (objs) {
  var points = _fetchers__WEBPACK_IMPORTED_MODULE_6__["generic"](objs, ['TCAD.TWO.EndPoint'], 1);
  var arcs = _fetchers__WEBPACK_IMPORTED_MODULE_6__["generic"](objs, ['TCAD.TWO.Arc', 'TCAD.TWO.Circle', 'TCAD.TWO.Ellipse', 'TCAD.TWO.EllipticalArc', 'TCAD.TWO.NurbsObject'], 1);
  var arc = arcs[0];

  if (arc._class === 'TCAD.TWO.Ellipse' || arc._class === 'TCAD.TWO.EllipticalArc') {
    this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].PointOnEllipse(points[0], arc));
  } else if (arc._class === 'TCAD.TWO.NurbsObject') {
    this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].PointOnCurve(points[0], arc));
  } else {
    this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].PointOnArc(points[0], arc));
  }
};

ParametricManager.prototype.pointOnLine = function (objs) {
  var pl = _fetchers__WEBPACK_IMPORTED_MODULE_6__["pointAndLine"](objs);
  var target = pl[0];
  var segment = pl[1];
  this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].PointOnLine(target, segment));
};

ParametricManager.prototype.llAngle = function (objs, promptCallback) {
  var lines = _fetchers__WEBPACK_IMPORTED_MODULE_6__["generic"](objs, 'TCAD.TWO.Segment', 2);
  var l1 = lines[0];
  var l2 = lines[1];
  var points = [l1.a, l1.b, l2.a, l2.b];

  if (l1.b.x < l1.a.x) {
    points[0] = l1.b;
    points[1] = l1.a;
  }

  if (l2.b.x < l2.a.x) {
    points[2] = l2.b;
    points[3] = l2.a;
  }

  var dx1 = points[1].x - points[0].x;
  var dy1 = points[1].y - points[0].y;
  var dx2 = points[3].x - points[2].x;
  var dy2 = points[3].y - points[2].y;
  var angle = Math.atan2(dy2, dx2) - Math.atan2(dy1, dx1);
  angle *= 1 / Math.PI * 180;
  angle = _utils_utils__WEBPACK_IMPORTED_MODULE_0__["askNumber"](_constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].Angle.prototype.SettableFields.angle, angle.toFixed(2), promptCallback, this.constantResolver);
  if (angle === null) return;
  this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].Angle(points[0], points[1], points[2], points[3], angle));
};

ParametricManager.prototype.p2pDistance = function (objs, promptCallback) {
  var p = _fetchers__WEBPACK_IMPORTED_MODULE_6__["twoPoints"](objs);
  var distance = new math_vector__WEBPACK_IMPORTED_MODULE_4__["default"](p[1].x - p[0].x, p[1].y - p[0].y).length();
  var promptDistance = _utils_utils__WEBPACK_IMPORTED_MODULE_0__["askNumber"](_constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].P2PDistance.prototype.SettableFields.d, distance.toFixed(2), promptCallback, this.constantResolver);

  if (promptDistance != null) {
    this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].P2PDistance(p[0], p[1], promptDistance));
  }
};

ParametricManager.prototype.radius = function (objs, promptCallback) {
  var arcs = _fetchers__WEBPACK_IMPORTED_MODULE_6__["arkCirc"](objs, 1);
  var radius = arcs[0].r.get();
  var promptDistance = _utils_utils__WEBPACK_IMPORTED_MODULE_0__["askNumber"](_constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].Radius.prototype.SettableFields.d, radius.toFixed(2), promptCallback, this.constantResolver);

  if (promptDistance != null) {
    for (var i = 0; i < arcs.length; ++i) {
      this._add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].Radius(arcs[i], promptDistance));
    }

    this.refresh();
  }
};

ParametricManager.prototype.mirror = function (objs, promptCallback) {
  var reflectionLine = null;
  var source = [];
  objs.forEach(function (o) {
    if (o._class === _io__WEBPACK_IMPORTED_MODULE_7__["Types"].SEGMENT && reflectionLine === null) {
      reflectionLine = o;
    } else {
      source.push(o);
    }
  });

  if (reflectionLine === null || source.length === 0) {
    throw "Illegal Argument. Constraint requires at least 1 line and 1 object";
  }

  this.add(new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].Mirror(reflectionLine, source));
};

ParametricManager.prototype._linkObjects = function (objs) {
  var i;
  var masterIdx = -1;

  for (i = 0; i < objs.length; ++i) {
    if (ParametricManager.isAux(objs[i])) {
      if (masterIdx !== -1) {
        throw "not allowed to have a coincident constraint between two or more auxiliary objects";
      }

      masterIdx = i;
    }
  }

  if (masterIdx === -1) masterIdx = objs.length - 1;

  for (i = 0; i < objs.length; ++i) {
    if (i === masterIdx) continue;
    objs[i].x = objs[masterIdx].x;
    objs[i].y = objs[masterIdx].y;
    var c = new _constraints__WEBPACK_IMPORTED_MODULE_10__["Constraints"].Coincident(objs[i], objs[masterIdx]);

    this._add(c);
  }
};

ParametricManager.prototype.linkObjects = function (objs) {
  this._linkObjects(objs);

  this.notify();
};

ParametricManager.prototype.unlinkObjects = function (a, b) {
  function _unlink(a, b) {
    for (var i = 0; i < a.linked.length; ++i) {
      var obj = a.linked[i];

      if (obj.id === b.id) {
        a.linked.splice(i, 1);
        break;
      }
    }
  }

  _unlink(a, b);

  _unlink(b, a);
};

ParametricManager.prototype.findCoincidentConstraint = function (point1, point2) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = this.subSystems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var subSys = _step.value;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = subSys.constraints[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var c = _step2.value;

          if (c.NAME === 'coi' && (c.a.id === point1.id && c.b.id === point2.id || c.b.id === point1.id && c.a.id === point2.id)) {
            return c;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return null;
};

ParametricManager.prototype.coincident = function (objs) {
  if (objs.length == 0) return;
  this.linkObjects(objs);
  this.solve();
  this.viewer.refresh();
};

ParametricManager.prototype.getSolveData = function () {
  var sdata = [];

  for (var i = 0; i < this.subSystems.length; i++) {
    this.__getSolveData(this.subSystems[i].constraints, sdata);
  }

  return sdata;
};

ParametricManager.prototype.__getSolveData = function (constraints, out) {
  for (var i = 0; i < constraints.length; ++i) {
    var constraint = constraints[i];
    var data = constraint.getSolveData(this.constantResolver);

    for (var j = 0; j < data.length; ++j) {
      data[j].push(constraint.reducible !== undefined);
      out.push(data[j]);
    }
  }

  return out;
};

ParametricManager.prototype.solve = function (lock, extraConstraints, disabledObjects) {
  var solver = this.prepare(lock, extraConstraints, disabledObjects);
  solver.solve(false);
};

ParametricManager.prototype.prepare = function (locked, extraConstraints, disabledObjects) {
  var orderedSubsystems = [];
  this.system.traverse(function (s) {
    return orderedSubsystems.push(s);
  }, function () {
    return console.error("Circular mirror constraints. System constrained incorrectly");
  });
  return this._prepare(locked, orderedSubsystems, extraConstraints, disabledObjects);
};

ParametricManager.prototype._prepare = function (locked, subSystems, extraConstraints, disabledObjects) {
  var solvers = [];

  for (var i = 0; i < subSystems.length; i++) {
    solvers.push(this.prepareForSubSystem(locked, subSystems[i].constraints, extraConstraints, disabledObjects));
  }

  if (subSystems.length === 0 && locked && locked.length !== 0) {
    solvers.push(this.prepareForSubSystem(locked, [], extraConstraints, disabledObjects));
  }

  var viewer = this.viewer;
  return {
    solvers: solvers,
    solve: function solve(rough) {
      for (var _i = 0; _i < solvers.length; _i++) {
        var alg = _i < subSystems.length ? subSystems[_i].alg : 1;

        var res = solvers[_i].solve(rough, alg);

        if (res.returnCode !== 1) {
          alg = alg === 1 ? 2 : 1; //if (solvers[i].solve(rough, alg).returnCode == 1) {
          //subSystems[i].alg = alg;
          //}
        }

        for (var _i2 = 0; _i2 < solvers.length; _i2++) {
          solvers[_i2].sync();
        }

        subSystems.forEach(function (subSystem) {
          subSystem.constraints.forEach(function (constr) {
            if (constr.GENERATOR) {
              constr.updateGeneratedObjects();
              constr.getGeneratedObjects().forEach(function (o) {
                return o.visitParams(function (p) {
                  for (var _i3 = 0; _i3 < solvers.length; _i3++) {
                    solvers[_i3].updateParameter(p);
                  }
                });
              });
            }
          });
        });
      }

      viewer.equalizeLinkedEndpoints();
    },
    updateParameter: function updateParameter(p) {
      for (var _i4 = 0; _i4 < solvers.length; _i4++) {
        solvers[_i4].updateParameter(p);
      }
    },
    updateLock: function updateLock(values) {
      for (var _i5 = 0; _i5 < solvers.length; _i5++) {
        solvers[_i5].updateLock(values);
      }
    },
    hasConflicts: function hasConflicts() {
      for (var _i6 = 0; _i6 < solvers.length; _i6++) {
        if (solvers[_i6].diagnose().conflict) {
          return true;
        }
      }

      return false;
    }
  };
};

ParametricManager.isAux = function (obj, disabledObjects) {
  while (!!obj) {
    if (!!obj.aux || disabledObjects !== undefined && disabledObjects.has(obj)) {
      return true;
    }

    obj = obj.parent;
  }

  return false;
};

ParametricManager.fetchAuxParams = function (system, auxParams, auxDict, disabledObjects) {
  disabledObjects = disabledObjects != undefined ? new Set(disabledObjects) : undefined;

  for (var i = 0; i < system.length; ++i) {
    for (var p = 0; p < system[i][1].length; ++p) {
      var parameter = system[i][1][p];

      if (parameter.obj !== undefined) {
        if (ParametricManager.isAux(parameter.obj, disabledObjects)) {
          if (auxDict[parameter.id] === undefined) {
            auxDict[parameter.id] = parameter;
            auxParams.push(parameter);
          }
        }
      }
    }
  }
};

ParametricManager.__toId = function (v) {
  return v.id;
};

ParametricManager.reduceSystem = function (system, readOnlyParams) {
  var info = {
    idToParam: {},
    linkedParams: [],
    reducedConstraints: {},
    reducedParams: {}
  };
  var links = [];

  function Link(a, b, constr) {
    this.a = a;
    this.b = b;
    this.constr = constr;
    this.invalid = false;
    this.processed = false;
  }

  var c,
      pi,
      paramToConstraints = {};

  for (i = 0; i < system.length; ++i) {
    c = system[i];

    if (c[3] !== true) {
      for (pi = 0; pi < c[1].length; pi++) {
        var param = c[1][pi];
        var paramConstrs = paramToConstraints[param.id];

        if (paramConstrs === undefined) {
          paramConstrs = [];
          paramToConstraints[param.id] = paramConstrs;
        }

        paramConstrs.push(i);
      }
    }
  }

  for (i = 0; i < system.length; ++i) {
    c = system[i];

    if (c[3] === true) {
      //Reduce flag
      var cp1 = c[1][0];
      var cp2 = c[1][1];
      links.push(new Link(cp1, cp2, i));
    }
  }

  function intersect(array1, array2) {
    if (!array1 || !array2) return false;
    return array1.filter(function (n) {
      return array2.indexOf(n) != -1;
    }).length != 0;
  }

  function shared(param1, param2) {
    if (param1 == param2) return false;
    var assoc0 = paramToConstraints[param1];
    var assoc1 = paramToConstraints[param2];
    return intersect(assoc0, assoc1);
  }

  var linkTuples = [];

  function mergeLinks(startIndex, into) {
    var linkI = links[startIndex];
    if (linkI.processed) return;
    linkI.processed = true;
    into.push(linkI);

    for (var j = startIndex + 1; j < links.length; j++) {
      var linkJ = links[j];

      if (linkI.a.id == linkJ.a.id || linkI.a.id == linkJ.b.id || linkI.b.id == linkJ.a.id || linkI.b.id == linkJ.b.id) {
        mergeLinks(j, into);
      }
    }
  }

  for (i = 0; i < links.length; i++) {
    if (links[i].processed) continue;
    var linkTuple = [];
    linkTuples.push(linkTuple);
    mergeLinks(i, linkTuple);
  }

  function resolveConflicts() {
    for (var i = 0; i < linkTuples.length; i++) {
      var tuple = linkTuples[i];

      for (var j = 0; j < tuple.length; j++) {
        var linkA = tuple[j];
        if (linkA.invalid) continue;

        if (shared(linkA.a.id, linkA.b.id)) {
          linkA.invalid = true;
          continue;
        }

        for (var k = j + 1; k < tuple.length; k++) {
          var linkB = tuple[k];

          if (shared(linkA.a.id, linkB.a.id) || shared(linkA.a.id, linkB.b.id) || shared(linkA.b.id, linkB.a.id) || shared(linkA.b.id, linkB.b.id)) {
            linkB.invalid = true;
          }
        }
      }
    }
  }

  resolveConflicts();

  function _merge(arr1, arr2) {
    for (var i = 0; i < arr2.length; ++i) {
      if (arr1.indexOf(arr2[i]) < 0) {
        arr1.push(arr2[i]);
      }
    }
  }

  function linksToTuples(linkTuples) {
    var tuples = [];

    for (var i = 0; i < linkTuples.length; i++) {
      var linkTuple = linkTuples[i];
      var tuple = [];
      tuples.push(tuple);

      for (var j = 0; j < linkTuple.length; j++) {
        var link = linkTuple[j];

        if (!link.invalid) {
          _merge(tuple, [link.a.id, link.b.id]);

          info.reducedConstraints[link.constr] = true;
          info.idToParam[link.a.id] = link.a;
          info.idToParam[link.b.id] = link.b;
        }
      }
    }

    return tuples;
  }

  var tuples = linksToTuples(linkTuples);

  for (var i = 0; i < tuples.length; ++i) {
    var tuple = tuples[i];
    info.linkedParams.push(tuple);

    for (var mi = 0; mi < readOnlyParams.length; ++mi) {
      var masterParam = readOnlyParams[mi];
      var masterIdx = tuple.indexOf(masterParam.id);

      if (masterIdx >= 0) {
        var tmp = tuple[0];
        tuple[0] = tuple[masterIdx];
        tuple[masterIdx] = tmp;
        break;
      }
    }
  }

  for (var ei = 0; ei < info.linkedParams.length; ++ei) {
    var master = info.linkedParams[ei][0];

    for (i = 1; i < info.linkedParams[ei].length; ++i) {
      info.reducedParams[info.linkedParams[ei][i]] = master;
    }
  }

  return info;
};

ParametricManager.prototype.prepareForSubSystem = function (locked, subSystemConstraints, extraConstraints, disabledObjects) {
  locked = locked || [];
  var constrs = [];
  var solverParamsDict = {};
  var system = [];
  var auxParams = [];
  var auxDict = {};

  this.__getSolveData(subSystemConstraints, system);

  if (!!extraConstraints) this.__getSolveData(extraConstraints, system);
  ParametricManager.fetchAuxParams(system, auxParams, auxDict, disabledObjects);
  var readOnlyParams = auxParams.concat(locked);
  var reduceInfo = ParametricManager.reduceSystem(system, readOnlyParams);

  function getSolverParam(p) {
    var doNotCreate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var master = reduceInfo.reducedParams[p.id];

    if (master !== undefined) {
      p = reduceInfo.idToParam[master];
    }

    var _p = solverParamsDict[p.id];

    if (_p === undefined && !doNotCreate) {
      if (p.__cachedParam__ === undefined) {
        _p = new _constr_solver__WEBPACK_IMPORTED_MODULE_2__["Param"](p.id, p.get());
        p.__cachedParam__ = _p;
      } else {
        _p = p.__cachedParam__;

        _p.reset(p.get());
      }

      _p._backingParam = p;
      solverParamsDict[p.id] = _p;
    }

    return _p;
  }

  (function pickupAuxiliaryInfoFromSlaves() {
    for (var i = 0; i < reduceInfo.linkedParams.length; ++i) {
      var linkedParams = reduceInfo.linkedParams[i];
      var master = linkedParams[0];
      if (auxDict[master] !== undefined) continue;

      for (var j = 1; j < linkedParams.length; j++) {
        var slave = linkedParams[j];

        if (auxDict[slave] !== undefined) {
          auxDict[master] = true;
          break;
        }
      }
    }
  })();

  for (var i = 0; i < system.length; ++i) {
    var sdata = system[i];
    var params = [];

    for (var p = 0; p < sdata[1].length; ++p) {
      var param = sdata[1][p];
      var solverParam = getSolverParam(param);
      solverParam.aux = auxDict[solverParam._backingParam.id] !== undefined;
      params.push(solverParam);
    }

    if (reduceInfo.reducedConstraints[i] === true) continue;

    var _constr = Object(_constr_solverConstraints__WEBPACK_IMPORTED_MODULE_3__["createByConstraintName"])(sdata[0], params, sdata[2]);

    constrs.push(_constr);
  }

  var lockedSolverParams = [];

  for (var _p2 = 0; _p2 < locked.length; ++_p2) {
    lockedSolverParams[_p2] = getSolverParam(locked[_p2]);
  }

  var solver = Object(_constr_solver__WEBPACK_IMPORTED_MODULE_2__["prepare"])(constrs, lockedSolverParams);

  function solve(rough, alg) {
    return solver.solveSystem(rough, alg);
  }

  var viewer = this.viewer;

  function sync() {
    for (var paramId in solverParamsDict) {
      var solverParam = solverParamsDict[paramId];
      if (!!solverParam._backingParam.aux) continue;

      solverParam._backingParam.set(solverParam.get());
    } //Make sure all coincident constraints are equal


    for (var ei = 0; ei < reduceInfo.linkedParams.length; ++ei) {
      var master = reduceInfo.idToParam[reduceInfo.linkedParams[ei][0]];

      for (var i = 1; i < reduceInfo.linkedParams[ei].length; ++i) {
        var slave = reduceInfo.idToParam[reduceInfo.linkedParams[ei][i]];
        slave.set(master.get());
      }
    }
  }

  function updateParameter(p) {
    var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var solverParam = getSolverParam(p);

    if (solverParam) {
      solverParam.set(p.get(), force);
    }
  }

  solver.solve = solve;
  solver.sync = sync;
  solver.updateParameter = updateParameter;
  return solver;
};




/***/ }),

/***/ "./web/app/sketcher/shapes/arc.js":
/*!****************************************!*\
  !*** ./web/app/sketcher/shapes/arc.js ***!
  \****************************************/
/*! exports provided: Arc */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Arc", function() { return Arc; });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ "./web/app/utils/utils.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
/* harmony import */ var _ref__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ref */ "./web/app/sketcher/shapes/ref.js");
/* harmony import */ var _parametric__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parametric */ "./web/app/sketcher/parametric.js");
/* harmony import */ var _sketch_object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sketch-object */ "./web/app/sketcher/shapes/sketch-object.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }







var Arc =
/*#__PURE__*/
function (_SketchObject) {
  _inherits(Arc, _SketchObject);

  function Arc(a, b, c) {
    var _this;

    _classCallCheck(this, Arc);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Arc).call(this));
    _this.a = a;
    _this.b = b;
    _this.c = c;
    a.parent = _assertThisInitialized(_this);
    b.parent = _assertThisInitialized(_this);
    c.parent = _assertThisInitialized(_this);

    _this.children.push(a, b, c);

    _this.r = new _ref__WEBPACK_IMPORTED_MODULE_3__["Ref"](0);
    _this.r.value = _this.distanceA();
    _this.r.obj = _assertThisInitialized(_this);
    return _this;
  }

  _createClass(Arc, [{
    key: "visitParams",
    value: function visitParams(callback) {
      this.a.visitParams(callback);
      this.b.visitParams(callback);
      this.c.visitParams(callback);
      callback(this.r);
    }
  }, {
    key: "getReferencePoint",
    value: function getReferencePoint() {
      return this.c;
    }
  }, {
    key: "translateImpl",
    value: function translateImpl(dx, dy) {
      this.a.translate(dx, dy);
      this.b.translate(dx, dy);
      this.c.translate(dx, dy);
    }
  }, {
    key: "radiusForDrawing",
    value: function radiusForDrawing() {
      return this.distanceA();
    }
  }, {
    key: "distanceA",
    value: function distanceA() {
      return _math_math__WEBPACK_IMPORTED_MODULE_1__["distance"](this.a.x, this.a.y, this.c.x, this.c.y);
    }
  }, {
    key: "distanceB",
    value: function distanceB() {
      return _math_math__WEBPACK_IMPORTED_MODULE_1__["distance"](this.b.x, this.b.y, this.c.x, this.c.y);
    }
  }, {
    key: "getStartAngle",
    value: function getStartAngle() {
      return Math.atan2(this.a.y - this.c.y, this.a.x - this.c.x);
    }
  }, {
    key: "getEndAngle",
    value: function getEndAngle() {
      return Math.atan2(this.b.y - this.c.y, this.b.x - this.c.x);
    }
  }, {
    key: "drawImpl",
    value: function drawImpl(ctx, scale) {
      ctx.beginPath();
      var r = this.radiusForDrawing();
      var startAngle = this.getStartAngle();
      var endAngle;

      if (_math_math__WEBPACK_IMPORTED_MODULE_1__["areEqual"](this.a.x, this.b.x, _math_math__WEBPACK_IMPORTED_MODULE_1__["TOLERANCE"]) && _math_math__WEBPACK_IMPORTED_MODULE_1__["areEqual"](this.a.y, this.b.y, _math_math__WEBPACK_IMPORTED_MODULE_1__["TOLERANCE"])) {
        endAngle = startAngle + 2 * Math.PI;
      } else {
        endAngle = this.getEndAngle();
      }

      ctx.arc(this.c.x, this.c.y, r, startAngle, endAngle);
      var distanceB = this.distanceB();

      if (Math.abs(r - distanceB) * scale > 1) {
        var adj = r / distanceB;
        ctx.save();
        ctx.setLineDash([7 / scale]);
        ctx.lineTo(this.b.x, this.b.y);
        ctx.moveTo(this.b.x + (this.b.x - this.c.x) / adj, this.b.y + (this.b.y - this.c.y) / adj);
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.stroke();
      }
    }
  }, {
    key: "isPointInsideSector",
    value: function isPointInsideSector(x, y) {
      var ca = new math_vector__WEBPACK_IMPORTED_MODULE_2__["default"](this.a.x - this.c.x, this.a.y - this.c.y);
      var cb = new math_vector__WEBPACK_IMPORTED_MODULE_2__["default"](this.b.x - this.c.x, this.b.y - this.c.y);
      var ct = new math_vector__WEBPACK_IMPORTED_MODULE_2__["default"](x - this.c.x, y - this.c.y);

      ca._normalize();

      cb._normalize();

      ct._normalize();

      var cosAB = ca.dot(cb);
      var cosAT = ca.dot(ct);
      var isInside = cosAT >= cosAB;
      var abInverse = ca.cross(cb).z < 0;
      var atInverse = ca.cross(ct).z < 0;
      var result;

      if (abInverse) {
        result = !atInverse || !isInside;
      } else {
        result = !atInverse && isInside;
      }

      return result;
    }
  }, {
    key: "normalDistance",
    value: function normalDistance(aim) {
      var isInsideSector = this.isPointInsideSector(aim.x, aim.y);

      if (isInsideSector) {
        return Math.abs(_math_math__WEBPACK_IMPORTED_MODULE_1__["distance"](aim.x, aim.y, this.c.x, this.c.y) - this.radiusForDrawing());
      } else {
        return Math.min(_math_math__WEBPACK_IMPORTED_MODULE_1__["distance"](aim.x, aim.y, this.a.x, this.a.y), _math_math__WEBPACK_IMPORTED_MODULE_1__["distance"](aim.x, aim.y, this.b.x, this.b.y));
      }
    }
  }, {
    key: "stabilize",
    value: function stabilize(viewer) {
      this.r.set(this.distanceA());

      viewer.parametricManager._add(new _parametric__WEBPACK_IMPORTED_MODULE_4__["Constraints"].P2PDistanceV(this.b, this.c, this.r));

      viewer.parametricManager._add(new _parametric__WEBPACK_IMPORTED_MODULE_4__["Constraints"].P2PDistanceV(this.a, this.c, this.r));
    }
  }, {
    key: "copy",
    value: function copy() {
      return new Arc(this.a.copy(), this.b.copy(), this.c.copy());
    }
  }, {
    key: "mirror",
    value: function mirror(dest, mirroringFunc) {
      this.a.mirror(dest.b, mirroringFunc);
      this.b.mirror(dest.a, mirroringFunc);
      this.c.mirror(dest.c, mirroringFunc);
    }
  }]);

  return Arc;
}(_sketch_object__WEBPACK_IMPORTED_MODULE_5__["SketchObject"]);
Arc.prototype._class = 'TCAD.TWO.Arc';

/***/ }),

/***/ "./web/app/sketcher/shapes/basis-origin.js":
/*!*************************************************!*\
  !*** ./web/app/sketcher/shapes/basis-origin.js ***!
  \*************************************************/
/*! exports provided: BasisOrigin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasisOrigin", function() { return BasisOrigin; });
/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shape */ "./web/app/sketcher/shapes/shape.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


var BasisOrigin =
/*#__PURE__*/
function (_Shape) {
  _inherits(BasisOrigin, _Shape);

  function BasisOrigin(basis, viewer) {
    var _this;

    _classCallCheck(this, BasisOrigin);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BasisOrigin).call(this));
    _this.viewer = viewer;
    _this.inverseX = false;
    _this.inverseY = false;
    _this.lineWidth = 100;
    _this.xColor = '#FF0000';
    _this.yColor = '#00FF00';
    return _this;
  }

  _createClass(BasisOrigin, [{
    key: "draw",
    value: function draw(ctx, scale) {
      ctx.save();

      if (this.inverseX) {
        this.xScale = -1;
        this.xShift = this.lineWidth + 10;
      } else {
        this.xScale = 1;
        this.xShift = 10;
      }

      if (this.inverseY) {
        this.yScale = -1;
        this.yShift = this.viewer.canvas.height - this.lineWidth - 10;
      } else {
        this.yScale = 1;
        this.yShift = this.viewer.canvas.height - 10;
      }

      ctx.setTransform(this.xScale, 0, 0, this.yScale, this.xShift, this.yShift);
      ctx.beginPath();
      ctx.lineWidth = 1;
      ctx.strokeStyle = this.yColor;
      var headA = 1;
      var headB = 10;
      ctx.moveTo(0.5, 0);
      ctx.lineTo(0.5, -this.lineWidth);
      ctx.moveTo(0, -this.lineWidth);
      ctx.lineTo(headA, 0 - this.lineWidth + headB);
      ctx.moveTo(0, -this.lineWidth);
      ctx.lineTo(-headA, -this.lineWidth + headB);
      ctx.closePath();
      ctx.stroke();
      ctx.beginPath();
      ctx.strokeStyle = this.xColor;
      ctx.moveTo(0, 0.5);
      ctx.lineTo(this.lineWidth, 0.5);
      ctx.moveTo(this.lineWidth, 0);
      ctx.lineTo(this.lineWidth - headB, headA);
      ctx.moveTo(this.lineWidth, 0);
      ctx.lineTo(this.lineWidth - headB, -headA);
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }
  }]);

  return BasisOrigin;
}(_shape__WEBPACK_IMPORTED_MODULE_0__["Shape"]);

/***/ }),

/***/ "./web/app/sketcher/shapes/bezier-curve.js":
/*!*************************************************!*\
  !*** ./web/app/sketcher/shapes/bezier-curve.js ***!
  \*************************************************/
/*! exports provided: BezierCurve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BezierCurve", function() { return BezierCurve; });
/* harmony import */ var _ref__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ref */ "./web/app/sketcher/shapes/ref.js");
/* harmony import */ var _sketch_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sketch-object */ "./web/app/sketcher/shapes/sketch-object.js");
/* harmony import */ var _segment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./segment */ "./web/app/sketcher/shapes/segment.js");
/* harmony import */ var _math_bezier_cubic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/bezier-cubic */ "./web/app/math/bezier-cubic.js");
/* harmony import */ var _math_convex_hull__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/convex-hull */ "./web/app/math/convex-hull.js");
/* harmony import */ var _shapes_draw_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shapes/draw-utils */ "./web/app/sketcher/shapes/draw-utils.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }








var BezierCurve =
/*#__PURE__*/
function (_SketchObject) {
  _inherits(BezierCurve, _SketchObject);

  function BezierCurve(a, b, cp1, cp2) {
    var _this;

    _classCallCheck(this, BezierCurve);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BezierCurve).call(this));
    _this.a = a;
    _this.b = b;
    _this.cp1 = cp1;
    _this.cp2 = cp2;

    _this.addChild(new _segment__WEBPACK_IMPORTED_MODULE_2__["Segment"](a, cp1));

    _this.addChild(new _segment__WEBPACK_IMPORTED_MODULE_2__["Segment"](b, cp2));

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var c = _step.value;
        c.role = 'objectConstruction';
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return _this;
  }

  _createClass(BezierCurve, [{
    key: "visitParams",
    value: function visitParams(callback) {
      this.a.visitParams(callback);
      this.b.visitParams(callback);
      this.cp1.visitParams(callback);
      this.cp2.visitParams(callback);
    }
  }, {
    key: "normalDistance",
    value: function normalDistance(aim, scale) {
      this.hull = Object(_math_convex_hull__WEBPACK_IMPORTED_MODULE_4__["ConvexHull2D"])([this.a, this.b, this.cp1, this.cp2]);
      this.hull = _math_math__WEBPACK_IMPORTED_MODULE_6__["polygonOffset"](this.hull, 1 + 0.3 / scale);

      if (_math_math__WEBPACK_IMPORTED_MODULE_6__["isPointInsidePolygon"](aim, this.hull)) {
        this.lut = Object(_math_bezier_cubic__WEBPACK_IMPORTED_MODULE_3__["LUT"])(this.a, this.b, this.cp1, this.cp2, scale);
        return this.closestNormalDistance(aim, this.lut);
      }

      return -1;
    }
  }, {
    key: "closestNormalDistance",
    value: function closestNormalDistance(aim, segments) {
      var hero = -1;

      for (var p = segments.length - 1, q = 0; q < segments.length; p = q++) {
        var dist = Math.min(_segment__WEBPACK_IMPORTED_MODULE_2__["Segment"].calcNormalDistance(aim, segments[p], segments[q]));

        if (dist != -1) {
          hero = hero == -1 ? dist : Math.min(dist, hero);
        }
      }

      return hero;
    }
  }, {
    key: "drawImpl",
    value: function drawImpl(ctx, scale, viewer) {
      ctx.beginPath();
      ctx.moveTo(this.a.x, this.a.y);
      ctx.bezierCurveTo(this.cp1.x, this.cp1.y, this.cp2.x, this.cp2.y, this.b.x, this.b.y);
      ctx.stroke(); //debug lut and hull
      //this.drawLUTAndHull();
    }
  }, {
    key: "drawLUTAndHull",
    value: function drawLUTAndHull() {
      if (this.lut) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.lut[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var p = _step2.value;
            _shapes_draw_utils__WEBPACK_IMPORTED_MODULE_5__["DrawPoint"](ctx, p.x, p.y, 3, scale);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        ctx.moveTo(this.hull[0].x, this.hull[0].y);
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this.hull[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _p = _step3.value;
            ctx.lineTo(_p.x, _p.y);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        ctx.stroke();
      }
    }
  }]);

  return BezierCurve;
}(_sketch_object__WEBPACK_IMPORTED_MODULE_1__["SketchObject"]);
BezierCurve.prototype._class = 'TCAD.TWO.BezierCurve';
var RECOVER_LENGTH = 100;

/***/ }),

/***/ "./web/app/sketcher/shapes/circle.js":
/*!*******************************************!*\
  !*** ./web/app/sketcher/shapes/circle.js ***!
  \*******************************************/
/*! exports provided: Circle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return Circle; });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ "./web/app/utils/utils.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
/* harmony import */ var _tools_circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/circle */ "./web/app/sketcher/tools/circle.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point */ "./web/app/sketcher/shapes/point.js");
/* harmony import */ var _ref__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ref */ "./web/app/sketcher/shapes/ref.js");
/* harmony import */ var _sketch_object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sketch-object */ "./web/app/sketcher/shapes/sketch-object.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }







var Circle =
/*#__PURE__*/
function (_SketchObject) {
  _inherits(Circle, _SketchObject);

  function Circle(c) {
    var _this;

    _classCallCheck(this, Circle);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this));
    _this.c = c;
    c.parent = _assertThisInitialized(_this);

    _this.children.push(c);

    _this.r = new _ref__WEBPACK_IMPORTED_MODULE_4__["Ref"](0);
    _this.r.obj = _assertThisInitialized(_this);
    return _this;
  }

  _createClass(Circle, [{
    key: "visitParams",
    value: function visitParams(callback) {
      this.c.visitParams(callback);
      callback(this.r);
    }
  }, {
    key: "getReferencePoint",
    value: function getReferencePoint() {
      return this.c;
    }
  }, {
    key: "translateImpl",
    value: function translateImpl(dx, dy) {
      this.c.translate(dx, dy);
    }
  }, {
    key: "drawImpl",
    value: function drawImpl(ctx, scale) {
      ctx.beginPath();
      ctx.arc(this.c.x, this.c.y, this.r.get(), 0, 2 * Math.PI);
      ctx.stroke();
    }
  }, {
    key: "normalDistance",
    value: function normalDistance(aim) {
      return Math.abs(_math_math__WEBPACK_IMPORTED_MODULE_1__["distance"](aim.x, aim.y, this.c.x, this.c.y) - this.r.get());
    }
  }]);

  return Circle;
}(_sketch_object__WEBPACK_IMPORTED_MODULE_5__["SketchObject"]);
Circle.prototype._class = 'TCAD.TWO.Circle';

/***/ }),

/***/ "./web/app/sketcher/shapes/dim.js":
/*!****************************************!*\
  !*** ./web/app/sketcher/shapes/dim.js ***!
  \****************************************/
/*! exports provided: Dimension, HDimension, VDimension, DiameterDimension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dimension", function() { return Dimension; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HDimension", function() { return HDimension; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VDimension", function() { return VDimension; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiameterDimension", function() { return DiameterDimension; });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils */ "./web/app/utils/utils.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
/* harmony import */ var _sketch_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sketch-object */ "./web/app/sketcher/shapes/sketch-object.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var LinearDimension =
/*#__PURE__*/
function (_SketchObject) {
  _inherits(LinearDimension, _SketchObject);

  function LinearDimension(a, b) {
    var _this;

    _classCallCheck(this, LinearDimension);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(LinearDimension).call(this));
    _this.a = a;
    _this.b = b;
    _this.flip = false;
    return _this;
  }

  _createClass(LinearDimension, [{
    key: "visitParams",
    value: function visitParams(callback) {}
  }, {
    key: "getReferencePoint",
    value: function getReferencePoint() {
      return this.a;
    }
  }, {
    key: "translateImpl",
    value: function translateImpl(dx, dy) {}
  }, {
    key: "getA",
    value: function getA() {
      return this.a;
    }
  }, {
    key: "getB",
    value: function getB() {
      return this.b;
    }
  }, {
    key: "drawImpl",
    value: function drawImpl(ctx, scale, viewer) {
      var off = 30 * viewer.dimScale;
      var textOff = getTextOff(viewer.dimScale);
      var a, b, startA, startB;

      if (this.flip) {
        a = this.getB();
        b = this.getA();
        startA = this.b;
        startB = this.a;
      } else {
        a = this.getA();
        b = this.getB();
        startA = this.a;
        startB = this.b;
      }

      var d = _math_math__WEBPACK_IMPORTED_MODULE_1__["distanceAB"](a, b);

      var _vx = -(b.y - a.y);

      var _vy = b.x - a.x; //normalize


      var _vxn = _vx / d;

      var _vyn = _vy / d;

      _vx = _vxn * off;
      _vy = _vyn * off;
      ctx.beginPath();

      var _ax = a.x + _vx;

      var _ay = a.y + _vy;

      var _bx = b.x + _vx;

      var _by = b.y + _vy;

      ctx.moveTo(_ax, _ay);
      ctx.lineTo(_bx, _by);

      function drawRef(start, x, y) {
        var vec = new math_vector__WEBPACK_IMPORTED_MODULE_2__["default"](x - start.x, y - start.y);

        vec._normalize();

        vec._multiply(7 * viewer.dimScale);

        ctx.moveTo(start.x, start.y);
        ctx.lineTo(x, y);
        ctx.lineTo(x + vec.x, y + vec.y);
      }

      drawRef(startA, _ax, _ay);
      drawRef(startB, _bx, _by);
      ctx.closePath();
      ctx.stroke();

      function drawArrow(x, y) {
        var s1 = 50;
        var s2 = 20;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - s1, y - s2);
        ctx.closePath();
        ctx.stroke();
      } //  drawArrow(_ax, _ay);
      //  drawArrow(_bx, _by);


      ctx.font = 12 * viewer.dimScale + "px Arial";
      var txt = d.toFixed(2);
      var h = d / 2 - ctx.measureText(txt).width / 2;

      if (h > 0) {
        var tx = _ax + _vxn * textOff - -_vyn * h;
        var ty = _ay + _vyn * textOff - _vxn * h;
        ctx.save();
        ctx.translate(tx, ty);
        ctx.rotate(-Math.atan2(_vxn, _vyn));
        ctx.scale(1, -1);
        ctx.fillText(txt, 0, 0);
        ctx.restore();
      }
    }
  }, {
    key: "normalDistance",
    value: function normalDistance(aim) {
      return -1;
    }
  }]);

  return LinearDimension;
}(_sketch_object__WEBPACK_IMPORTED_MODULE_3__["SketchObject"]);

var Dimension =
/*#__PURE__*/
function (_LinearDimension) {
  _inherits(Dimension, _LinearDimension);

  function Dimension(a, b) {
    _classCallCheck(this, Dimension);

    return _possibleConstructorReturn(this, _getPrototypeOf(Dimension).call(this, a, b));
  }

  return Dimension;
}(LinearDimension);
Dimension.prototype._class = 'TCAD.TWO.Dimension';
var HDimension =
/*#__PURE__*/
function (_LinearDimension2) {
  _inherits(HDimension, _LinearDimension2);

  function HDimension(a, b) {
    _classCallCheck(this, HDimension);

    return _possibleConstructorReturn(this, _getPrototypeOf(HDimension).call(this, a, b));
  }

  _createClass(HDimension, [{
    key: "getA",
    value: function getA() {
      return this.a;
    }
  }, {
    key: "getB",
    value: function getB() {
      return {
        x: this.b.x,
        y: this.a.y
      };
    }
  }]);

  return HDimension;
}(LinearDimension);
HDimension.prototype._class = 'TCAD.TWO.HDimension';
var VDimension =
/*#__PURE__*/
function (_LinearDimension3) {
  _inherits(VDimension, _LinearDimension3);

  function VDimension(a, b) {
    _classCallCheck(this, VDimension);

    return _possibleConstructorReturn(this, _getPrototypeOf(VDimension).call(this, a, b));
  }

  _createClass(VDimension, [{
    key: "getA",
    value: function getA() {
      return this.a;
    }
  }, {
    key: "getB",
    value: function getB() {
      return {
        x: this.a.x,
        y: this.b.y
      };
    }
  }]);

  return VDimension;
}(LinearDimension);
VDimension.prototype._class = 'TCAD.TWO.VDimension';
var DiameterDimension =
/*#__PURE__*/
function (_SketchObject2) {
  _inherits(DiameterDimension, _SketchObject2);

  function DiameterDimension(obj) {
    var _this2;

    _classCallCheck(this, DiameterDimension);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(DiameterDimension).call(this));
    _this2.obj = obj;
    _this2.angle = Math.PI / 4;
    return _this2;
  }

  _createClass(DiameterDimension, [{
    key: "visitParams",
    value: function visitParams(callback) {}
  }, {
    key: "getReferencePoint",
    value: function getReferencePoint() {}
  }, {
    key: "translateImpl",
    value: function translateImpl(dx, dy) {}
  }, {
    key: "drawImpl",
    value: function drawImpl(ctx, scale, viewer) {
      if (this.obj == null) return;

      if (this.obj._class === 'TCAD.TWO.Circle') {
        this.drawForCircle(ctx, scale, viewer);
      } else if (this.obj._class === 'TCAD.TWO.Arc') {
        this.drawForArc(ctx, scale, viewer);
      }
    }
  }, {
    key: "drawForCircle",
    value: function drawForCircle(ctx, scale, viewer) {
      var c = new math_vector__WEBPACK_IMPORTED_MODULE_2__["default"]().setV(this.obj.c);
      var r = this.obj.r.get();
      var angled = new math_vector__WEBPACK_IMPORTED_MODULE_2__["default"](r * Math.cos(this.angle), r * Math.sin(this.angle), 0);
      var a = c.minus(angled);
      var b = c.plus(angled);
      var textOff = getTextOff(viewer.dimScale);
      var d = 2 * r;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.closePath();
      ctx.stroke();
      var fontSize = 12 * viewer.dimScale;
      ctx.font = fontSize + "px Arial";
      var txt = String.fromCharCode(216) + ' ' + d.toFixed(2);
      var textWidth = ctx.measureText(txt).width;
      var h = d / 2 - textWidth / 2;

      var _vx = -(b.y - a.y);

      var _vy = b.x - a.x; //normalize


      var _vxn = _vx / d;

      var _vyn = _vy / d;

      function drawText(tx, ty) {
        ctx.save();
        ctx.translate(tx, ty);
        ctx.rotate(-Math.atan2(_vxn, _vyn));
        ctx.scale(1, -1);
        ctx.fillText(txt, 0, 0);
        ctx.restore();
      }

      var tx, ty;

      if (h - fontSize * .3 > 0) {
        // take into account font size to not have circle overlap symbols
        tx = a.x + _vxn * textOff - -_vyn * h;
        ty = a.y + _vyn * textOff - _vxn * h;
        drawText(tx, ty);
      } else {
        var off = 2 * viewer.dimScale;

        angled._normalize();

        var extraLine = angled.multiply(textWidth + off * 2);
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(b.x + extraLine.x, b.y + extraLine.y);
        ctx.closePath();
        ctx.stroke();

        angled._multiply(off);

        tx = b.x + _vxn * textOff + angled.x;
        ty = b.y + _vyn * textOff + angled.y;
        drawText(tx, ty);
      }
    }
  }, {
    key: "drawForArc",
    value: function drawForArc(ctx, scale, viewer) {
      var r = this.obj.distanceA();
      var hxn = Math.cos(this.angle);
      var hyn = Math.sin(this.angle);
      var vxn = -hyn;
      var vyn = hxn; //fix angle if needed

      if (!this.obj.isPointInsideSector(this.obj.c.x + hxn, this.obj.c.y + hyn)) {
        var cosA = hxn * (this.obj.a.x - this.obj.c.x) + hyn * (this.obj.a.y - this.obj.c.y);
        var cosB = hxn * (this.obj.b.x - this.obj.c.x) + hyn * (this.obj.b.y - this.obj.c.y);

        if (cosA - hxn > cosB - hxn) {
          this.angle = this.obj.getStartAngle();
        } else {
          this.angle = this.obj.getEndAngle();
        }
      }

      var vertOff = getTextOff(viewer.dimScale);
      var horOff = 5 * viewer.dimScale;
      var fontSize = 12 * viewer.dimScale;
      ctx.font = fontSize + "px Arial";
      var txt = 'R ' + r.toFixed(2);
      var textWidth = ctx.measureText(txt).width;
      var startX = this.obj.c.x + hxn * r;
      var startY = this.obj.c.y + hyn * r;
      var lineLength = textWidth + horOff * 2;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(startX + hxn * lineLength, startY + hyn * lineLength);
      ctx.closePath();
      ctx.stroke();
      var tx = startX + vxn * vertOff + hxn * horOff;
      var ty = startY + vyn * vertOff + hyn * horOff;
      ctx.save();
      ctx.translate(tx, ty);
      ctx.rotate(-Math.atan2(vxn, vyn));
      ctx.scale(1, -1);
      ctx.fillText(txt, 0, 0);
      ctx.restore();
    }
  }, {
    key: "normalDistance",
    value: function normalDistance(aim) {
      return -1;
    }
  }]);

  return DiameterDimension;
}(_sketch_object__WEBPACK_IMPORTED_MODULE_3__["SketchObject"]);
DiameterDimension.prototype._class = 'TCAD.TWO.DiameterDimension';

function getTextOff(scale) {
  return 3 * scale;
}

/***/ }),

/***/ "./web/app/sketcher/shapes/draw-utils.js":
/*!***********************************************!*\
  !*** ./web/app/sketcher/shapes/draw-utils.js ***!
  \***********************************************/
/*! exports provided: DrawPoint, SetStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DrawPoint", function() { return DrawPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetStyle", function() { return SetStyle; });
function DrawPoint(ctx, x, y, rad, scale) {
  ctx.beginPath();
  ctx.arc(x, y, rad / scale, 0, 2 * Math.PI, false);
  ctx.fill();
}
function SetStyle(style, ctx, scale) {
  ctx.lineWidth = style.lineWidth / scale;
  ctx.strokeStyle = style.strokeStyle;
  ctx.fillStyle = style.fillStyle;
}

/***/ }),

/***/ "./web/app/sketcher/shapes/ellipse.js":
/*!********************************************!*\
  !*** ./web/app/sketcher/shapes/ellipse.js ***!
  \********************************************/
/*! exports provided: Ellipse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ellipse", function() { return Ellipse; });
/* harmony import */ var _ref__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ref */ "./web/app/sketcher/shapes/ref.js");
/* harmony import */ var _sketch_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sketch-object */ "./web/app/sketcher/shapes/sketch-object.js");
/* harmony import */ var _parametric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parametric */ "./web/app/sketcher/parametric.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var Ellipse =
/*#__PURE__*/
function (_SketchObject) {
  _inherits(Ellipse, _SketchObject);

  function Ellipse(ep1, ep2) {
    var _this;

    _classCallCheck(this, Ellipse);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Ellipse).call(this));
    _this.ep1 = ep1;
    _this.ep2 = ep2;

    _this.addChild(_this.ep1);

    _this.addChild(_this.ep2);

    _this.r = new _ref__WEBPACK_IMPORTED_MODULE_0__["Ref"](0);

    _this.r.set(_this.radiusX * 0.5);

    _this.r.obj = _assertThisInitialized(_this);
    return _this;
  }

  _createClass(Ellipse, [{
    key: "recoverIfNecessary",
    value: function recoverIfNecessary() {
      var recovered = false;

      if (_math_math__WEBPACK_IMPORTED_MODULE_3__["distanceAB"](this.ep1, this.ep2) <= _math_math__WEBPACK_IMPORTED_MODULE_3__["TOLERANCE"]) {
        this.ep1.translate(-RECOVER_LENGTH, -RECOVER_LENGTH);
        this.ep2.translate(RECOVER_LENGTH, RECOVER_LENGTH);
        recovered = true;
      }

      if (this.radiusY <= 0.1) {
        this.r.set(RECOVER_LENGTH);
        recovered = true;
      }

      return recovered;
    }
  }, {
    key: "visitParams",
    value: function visitParams(callback) {
      this.ep1.visitParams(callback);
      this.ep2.visitParams(callback);
      callback(this.r);
    }
  }, {
    key: "drawImpl",
    value: function drawImpl(ctx, scale) {
      ctx.beginPath();
      var radiusX = Math.max(this.radiusX, 1e-8);
      var radiusY = Math.max(this.radiusY, 1e-8);
      ctx.ellipse(this.centerX, this.centerY, radiusX, radiusY, this.rotation, 0, 2 * Math.PI);
      ctx.stroke();
    }
  }, {
    key: "toEllipseCoordinateSystem",
    value: function toEllipseCoordinateSystem(point) {
      var x = point.x - this.centerX;
      var y = point.y - this.centerY;
      var angle = Math.atan2(y, x) - this.rotation;
      var radius = _math_math__WEBPACK_IMPORTED_MODULE_3__["distance"](0, 0, x, y);
      x = radius * Math.cos(angle);
      y = radius * Math.sin(angle);
      return {
        x: x,
        y: y,
        angle: angle,
        radius: radius
      };
    }
  }, {
    key: "radiusAtAngle",
    value: function radiusAtAngle(angle) {
      return Math.sqrt(1 / (sq(Math.cos(angle) / this.radiusX) + sq(Math.sin(angle) / this.radiusY)));
    }
  }, {
    key: "normalDistance",
    value: function normalDistance(aim) {
      var polarPoint = this.toEllipseCoordinateSystem(aim);
      var L = this.radiusAtAngle(polarPoint.angle);
      return Math.abs(polarPoint.radius - L);
    }
  }, {
    key: "rotation",
    get: function get() {
      return Math.atan2(this.ep2.y - this.ep1.y, this.ep2.x - this.ep1.x);
    }
  }, {
    key: "radiusX",
    get: function get() {
      return _math_math__WEBPACK_IMPORTED_MODULE_3__["distance"](this.ep1.x, this.ep1.y, this.ep2.x, this.ep2.y) * 0.5;
    }
  }, {
    key: "radiusY",
    get: function get() {
      return this.r.get();
    }
  }, {
    key: "centerX",
    get: function get() {
      return this.ep1.x + (this.ep2.x - this.ep1.x) * 0.5;
    }
  }, {
    key: "centerY",
    get: function get() {
      return this.ep1.y + (this.ep2.y - this.ep1.y) * 0.5;
    }
  }], [{
    key: "findMinorRadius",
    value: function findMinorRadius(majorRadius, pntRadius, pntAngle) {
      return Math.abs(Math.sin(pntAngle) / Math.sqrt(1 / sq(pntRadius) - sq(Math.cos(pntAngle) / majorRadius)));
    }
  }]);

  return Ellipse;
}(_sketch_object__WEBPACK_IMPORTED_MODULE_1__["SketchObject"]);
Ellipse.prototype._class = 'TCAD.TWO.Ellipse';

var sq = function sq(a) {
  return a * a;
};

var RECOVER_LENGTH = 100;

/***/ }),

/***/ "./web/app/sketcher/shapes/elliptical-arc.js":
/*!***************************************************!*\
  !*** ./web/app/sketcher/shapes/elliptical-arc.js ***!
  \***************************************************/
/*! exports provided: EllipticalArc */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipticalArc", function() { return EllipticalArc; });
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ellipse */ "./web/app/sketcher/shapes/ellipse.js");
/* harmony import */ var _parametric__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parametric */ "./web/app/sketcher/parametric.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/utils */ "./web/app/utils/utils.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var EllipticalArc =
/*#__PURE__*/
function (_Ellipse) {
  _inherits(EllipticalArc, _Ellipse);

  function EllipticalArc(ep1, ep2, a, b) {
    var _this;

    _classCallCheck(this, EllipticalArc);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EllipticalArc).call(this, ep1, ep2));
    _this.a = a;
    _this.b = b;

    _this.addChild(a);

    _this.addChild(b); //we'd like to have angles points have higher selection order 


    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_3__["swap"])(_this.children, 0, _this.children.length - 2);
    Object(_utils_utils__WEBPACK_IMPORTED_MODULE_3__["swap"])(_this.children, 1, _this.children.length - 1);
    return _this;
  }

  _createClass(EllipticalArc, [{
    key: "stabilize",
    value: function stabilize(viewer) {
      viewer.parametricManager._add(new _parametric__WEBPACK_IMPORTED_MODULE_1__["Constraints"].PointOnEllipseInternal(this.b, this));

      viewer.parametricManager._add(new _parametric__WEBPACK_IMPORTED_MODULE_1__["Constraints"].PointOnEllipseInternal(this.a, this));
    }
  }, {
    key: "drawImpl",
    value: function drawImpl(ctx, scale) {
      ctx.beginPath();
      var radiusX = Math.max(this.radiusX, 1e-8);
      var radiusY = Math.max(this.radiusY, 1e-8);
      var aAngle = this.drawAngle(this.a);
      var bAngle;

      if (_math_math__WEBPACK_IMPORTED_MODULE_2__["areEqual"](this.a.x, this.b.x, _math_math__WEBPACK_IMPORTED_MODULE_2__["TOLERANCE"]) && _math_math__WEBPACK_IMPORTED_MODULE_2__["areEqual"](this.a.y, this.b.y, _math_math__WEBPACK_IMPORTED_MODULE_2__["TOLERANCE"])) {
        bAngle = aAngle + 2 * Math.PI;
      } else {
        bAngle = this.drawAngle(this.b);
      }

      ctx.ellipse(this.centerX, this.centerY, radiusX, radiusY, this.rotation, aAngle, bAngle);
      ctx.stroke();
    }
  }, {
    key: "drawAngle",
    value: function drawAngle(point) {
      var deformScale = this.radiusY / this.radiusX;
      var x = point.x - this.centerX;
      var y = point.y - this.centerY;
      var rotation = -this.rotation;
      var xx = x * Math.cos(rotation) - y * Math.sin(rotation);
      var yy = x * Math.sin(rotation) + y * Math.cos(rotation);
      xx *= deformScale;
      return Math.atan2(yy, xx);
    }
  }]);

  return EllipticalArc;
}(_ellipse__WEBPACK_IMPORTED_MODULE_0__["Ellipse"]);
EllipticalArc.prototype._class = 'TCAD.TWO.EllipticalArc';

/***/ }),

/***/ "./web/app/sketcher/shapes/nurbsObject.js":
/*!************************************************!*\
  !*** ./web/app/sketcher/shapes/nurbsObject.js ***!
  \************************************************/
/*! exports provided: NurbsObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NurbsObject", function() { return NurbsObject; });
/* harmony import */ var _sketch_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sketch-object */ "./web/app/sketcher/shapes/sketch-object.js");
/* harmony import */ var _math_vec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/vec */ "./web/app/math/vec.js");
/* harmony import */ var _brep_geom_impl_nurbs_ext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../brep/geom/impl/nurbs-ext */ "./web/app/brep/geom/impl/nurbs-ext.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var __v = [0, 0, 0];
var NurbsObject =
/*#__PURE__*/
function (_SketchObject) {
  _inherits(NurbsObject, _SketchObject);

  function NurbsObject(curve, a, b) {
    var _this;

    _classCallCheck(this, NurbsObject);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(NurbsObject).call(this));
    _this.curve = curve;
    _this.a = a;
    _this.b = b;
    var cp = curve.data.controlPoints;
    _this.a.x = cp[0].x;
    _this.a.y = cp[0].y;
    _this.b.x = cp[cp.length - 1].x;
    _this.b.y = cp[cp.length - 1].y;
    _this.bezierPieces = _this.calcBezierPiecewise();
    return _this;
  }

  _createClass(NurbsObject, [{
    key: "visitParams",
    value: function visitParams(callback) {
      this.a.visitParams(callback);
      this.b.visitParams(callback);
    }
  }, {
    key: "normalDistance",
    value: function normalDistance(aim) {
      __v[0] = aim.x;
      __v[1] = aim.y;
      var point = this.curve.point(this.curve.param(__v));
      return _math_vec__WEBPACK_IMPORTED_MODULE_1__["distance"](__v, point);
    }
  }, {
    key: "drawImpl",
    value: function drawImpl(ctx, scale, viewer) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.bezierPieces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var bz = _step.value;
          ctx.beginPath();
          ctx.moveTo(bz.cp0[0], bz.cp0[1]); // ctx.lineTo(bz.cp3[0], bz.cp3[1]);

          ctx.bezierCurveTo(bz.cp1[0], bz.cp1[1], bz.cp2[0], bz.cp2[1], bz.cp3[0], bz.cp3[1]);
          ctx.stroke(); // DrawPoint(ctx, bz.cp0[0], bz.cp0[1], 3, scale)
          // DrawPoint(ctx, bz.cp1[0], bz.cp1[1], 3, scale)
          // DrawPoint(ctx, bz.cp2[0], bz.cp2[1], 3, scale)
          // DrawPoint(ctx, bz.cp3[0], bz.cp3[1], 3, scale)
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "calcBezierPiecewise",
    value: function calcBezierPiecewise() {
      var _this2 = this;

      var pieces = [];
      var knots = this.curve.knots();

      var _this$curve$domain = this.curve.domain(),
          _this$curve$domain2 = _slicedToArray(_this$curve$domain, 2),
          from = _this$curve$domain2[0],
          to = _this$curve$domain2[1];

      var tess = Object(_brep_geom_impl_nurbs_ext__WEBPACK_IMPORTED_MODULE_2__["curveTessellate"])(this.curve.data, from, to);

      var evalCurve = function evalCurve(t) {
        var _this2$curve$eval = _this2.curve.eval(t, 1),
            _this2$curve$eval2 = _slicedToArray(_this2$curve$eval, 2),
            P = _this2$curve$eval2[0],
            D = _this2$curve$eval2[1];

        return {
          P: P,
          D: D,
          M: _math_vec__WEBPACK_IMPORTED_MODULE_1__["normalize"](D)
        };
      };

      var t0 = tess[0];
      var eval0 = evalCurve(t0);

      for (var i = 1; i < tess.length; ++i) {
        var t1 = tess[i];
        var eval1 = evalCurve(t1);
        var _eval = eval0,
            P0 = _eval.P,
            M0 = _eval.M;
        var P3 = eval1.P,
            M1 = eval1.M;
        var k = _math_vec__WEBPACK_IMPORTED_MODULE_1__["length"](_math_vec__WEBPACK_IMPORTED_MODULE_1__["sub"](P0, P3)) / 3;

        var P1 = _math_vec__WEBPACK_IMPORTED_MODULE_1__["_add"](_math_vec__WEBPACK_IMPORTED_MODULE_1__["mul"](M0, k), P0);

        var P2 = _math_vec__WEBPACK_IMPORTED_MODULE_1__["_add"](_math_vec__WEBPACK_IMPORTED_MODULE_1__["mul"](M1, -k), P3);

        pieces.push({
          cp0: P0,
          cp1: P1,
          cp2: P2,
          cp3: P3
        });
        eval0 = eval1;
        t0 = t1;
      }

      return pieces;
    }
  }]);

  return NurbsObject;
}(_sketch_object__WEBPACK_IMPORTED_MODULE_0__["SketchObject"]);
NurbsObject.prototype._class = 'TCAD.TWO.NurbsObject';

/***/ }),

/***/ "./web/app/sketcher/shapes/point.js":
/*!******************************************!*\
  !*** ./web/app/sketcher/shapes/point.js ***!
  \******************************************/
/*! exports provided: EndPoint, Param */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EndPoint", function() { return EndPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Param", function() { return Param; });
/* harmony import */ var _sketch_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sketch-object */ "./web/app/sketcher/shapes/sketch-object.js");
/* harmony import */ var _draw_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./draw-utils */ "./web/app/sketcher/shapes/draw-utils.js");
/* harmony import */ var _id_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../id-generator */ "./web/app/sketcher/id-generator.js");
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var EndPoint =
/*#__PURE__*/
function (_SketchObject) {
  _inherits(EndPoint, _SketchObject);

  function EndPoint(x, y) {
    var _this;

    _classCallCheck(this, EndPoint);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EndPoint).call(this));
    _this.x = x;
    _this.y = y;
    _this.parent = null;
    _this._x = new Param(_assertThisInitialized(_this), 'x');
    _this._y = new Param(_assertThisInitialized(_this), 'y');
    return _this;
  }

  _createClass(EndPoint, [{
    key: "visitParams",
    value: function visitParams(callback) {
      callback(this._x);
      callback(this._y);
    }
  }, {
    key: "normalDistance",
    value: function normalDistance(aim) {
      return aim.minus(new math_vector__WEBPACK_IMPORTED_MODULE_3__["default"](this.x, this.y)).length();
    }
  }, {
    key: "getReferencePoint",
    value: function getReferencePoint() {
      return this;
    }
  }, {
    key: "translateImpl",
    value: function translateImpl(dx, dy) {
      this.x += dx;
      this.y += dy;
    }
  }, {
    key: "drawImpl",
    value: function drawImpl(ctx, scale) {
      Object(_draw_utils__WEBPACK_IMPORTED_MODULE_1__["DrawPoint"])(ctx, this.x, this.y, 3, scale);
    }
  }, {
    key: "setXY",
    value: function setXY(x, y) {
      this.x = x;
      this.y = y;
    }
  }, {
    key: "setFromPoint",
    value: function setFromPoint(p) {
      this.setXY(p.x, p.y);
    }
  }, {
    key: "setFromArray",
    value: function setFromArray(arr) {
      this.setXY(arr[0], arr[1]);
    }
  }, {
    key: "toVector",
    value: function toVector() {
      return new math_vector__WEBPACK_IMPORTED_MODULE_3__["default"](this.x, this.y);
    }
  }, {
    key: "copy",
    value: function copy() {
      return new EndPoint(this.x, this.y);
    }
  }, {
    key: "mirror",
    value: function mirror(dest, mirroringFunc) {
      var _mirroringFunc = mirroringFunc(this.x, this.y),
          x = _mirroringFunc.x,
          y = _mirroringFunc.y;

      dest.x = x;
      dest.y = y;
    }
  }]);

  return EndPoint;
}(_sketch_object__WEBPACK_IMPORTED_MODULE_0__["SketchObject"]);
EndPoint.prototype._class = 'TCAD.TWO.EndPoint';
var Param =
/*#__PURE__*/
function () {
  function Param(obj, prop) {
    _classCallCheck(this, Param);

    this.id = _id_generator__WEBPACK_IMPORTED_MODULE_2__["Generator"].genID();
    this.obj = obj;
    this.prop = prop;
  }

  _createClass(Param, [{
    key: "set",
    value: function set(value) {
      this.obj[this.prop] = value;
    }
  }, {
    key: "get",
    value: function get() {
      return this.obj[this.prop];
    }
  }]);

  return Param;
}();

/***/ }),

/***/ "./web/app/sketcher/shapes/primitives.js":
/*!***********************************************!*\
  !*** ./web/app/sketcher/shapes/primitives.js ***!
  \***********************************************/
/*! exports provided: Point */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return Point; });
/* harmony import */ var _draw_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw-utils */ "./web/app/sketcher/shapes/draw-utils.js");
/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shape */ "./web/app/sketcher/shapes/shape.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var Point =
/*#__PURE__*/
function (_Shape) {
  _inherits(Point, _Shape);

  function Point(x, y, rad) {
    var _this;

    _classCallCheck(this, Point);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Point).call(this));
    _this.x = x;
    _this.y = y;
    _this.rad = rad;
    _this.style = null;
    return _this;
  }

  _createClass(Point, [{
    key: "draw",
    value: function draw(ctx, scale) {
      _draw_utils__WEBPACK_IMPORTED_MODULE_0__["DrawPoint"](ctx, this.x, this.y, this.rad, scale);
    }
  }]);

  return Point;
}(_shape__WEBPACK_IMPORTED_MODULE_1__["Shape"]);

/***/ }),

/***/ "./web/app/sketcher/shapes/ref.js":
/*!****************************************!*\
  !*** ./web/app/sketcher/shapes/ref.js ***!
  \****************************************/
/*! exports provided: Ref */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ref", function() { return Ref; });
/* harmony import */ var _id_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../id-generator */ "./web/app/sketcher/id-generator.js");

function Ref(value) {
  this.id = _id_generator__WEBPACK_IMPORTED_MODULE_0__["Generator"].genID();
  this.value = value;
}

Ref.prototype.set = function (value) {
  this.value = value;
};

Ref.prototype.get = function () {
  return this.value;
};

/***/ }),

/***/ "./web/app/sketcher/shapes/reference-point.js":
/*!****************************************************!*\
  !*** ./web/app/sketcher/shapes/reference-point.js ***!
  \****************************************************/
/*! exports provided: ReferencePoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReferencePoint", function() { return ReferencePoint; });
/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shape */ "./web/app/sketcher/shapes/shape.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


var ReferencePoint =
/*#__PURE__*/
function (_Shape) {
  _inherits(ReferencePoint, _Shape);

  function ReferencePoint() {
    var _this;

    _classCallCheck(this, ReferencePoint);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReferencePoint).call(this));
    _this.x = 0;
    _this.y = 0;
    return _this;
  }

  _createClass(ReferencePoint, [{
    key: "draw",
    value: function draw(ctx, scale) {
      if (!this.visible) return;
      ctx.strokeStyle = 'salmon';
      ctx.fillStyle = 'salmon';
      ctx.lineWidth = 1 / scale;
      ctx.beginPath();
      ctx.arc(this.x, this.y, 1 / scale, 0, 2 * Math.PI, false);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(this.x, this.y, 7 / scale, 0, 2 * Math.PI, false);
      ctx.stroke();
    }
  }]);

  return ReferencePoint;
}(_shape__WEBPACK_IMPORTED_MODULE_0__["Shape"]);

/***/ }),

/***/ "./web/app/sketcher/shapes/segment.js":
/*!********************************************!*\
  !*** ./web/app/sketcher/shapes/segment.js ***!
  \********************************************/
/*! exports provided: Segment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Segment", function() { return Segment; });
/* harmony import */ var _sketch_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sketch-object */ "./web/app/sketcher/shapes/sketch-object.js");
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
/* harmony import */ var _parametric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parametric */ "./web/app/sketcher/parametric.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var Segment =
/*#__PURE__*/
function (_SketchObject) {
  _inherits(Segment, _SketchObject);

  function Segment(a, b) {
    var _this;

    _classCallCheck(this, Segment);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Segment).call(this));
    _this.a = a;
    _this.b = b;
    a.parent = _assertThisInitialized(_this);
    b.parent = _assertThisInitialized(_this);

    _this.children.push(a, b);

    return _this;
  }

  _createClass(Segment, [{
    key: "recoverIfNecessary",
    value: function recoverIfNecessary() {
      if (_math_math__WEBPACK_IMPORTED_MODULE_3__["distanceAB"](this.a, this.b) > _math_math__WEBPACK_IMPORTED_MODULE_3__["TOLERANCE"]) {
        return false;
      } else {
        var recoverLength = 100;
        this.a.translate(-recoverLength, -recoverLength);
        this.b.translate(recoverLength, recoverLength);
        return true;
      }
    }
  }, {
    key: "visitParams",
    value: function visitParams(callback) {
      this.a.visitParams(callback);
      this.b.visitParams(callback);
    }
  }, {
    key: "normalDistance",
    value: function normalDistance(aim) {
      return Segment.calcNormalDistance(aim, this.a, this.b);
    }
  }, {
    key: "getReferencePoint",
    value: function getReferencePoint() {
      return this.a;
    }
  }, {
    key: "translateImpl",
    value: function translateImpl(dx, dy) {
      this.a.translate(dx, dy);
      this.b.translate(dx, dy);
    }
  }, {
    key: "drawImpl",
    value: function drawImpl(ctx, scale) {
      ctx.beginPath();
      ctx.moveTo(this.a.x, this.a.y);
      ctx.lineTo(this.b.x, this.b.y); //  ctx.save();
      //  ctx.setTransform(1, 0, 0, 1, 0, 0);

      ctx.stroke(); //  ctx.restore();
    }
  }, {
    key: "opposite",
    value: function opposite(endPoint) {
      if (endPoint === this.a) {
        return this.b;
      } else if (endPoint === this.b) {
        return this.a;
      } else {
        return null;
      }
    }
  }, {
    key: "copy",
    value: function copy() {
      return new Segment(this.a.copy(), this.b.copy());
    }
  }], [{
    key: "calcNormalDistance",
    value: function calcNormalDistance(aim, segmentA, segmentB) {
      var ab = new math_vector__WEBPACK_IMPORTED_MODULE_1__["default"](segmentB.x - segmentA.x, segmentB.y - segmentA.y);
      var e = ab.normalize();
      var a = new math_vector__WEBPACK_IMPORTED_MODULE_1__["default"](aim.x - segmentA.x, aim.y - segmentA.y);
      var b = e.multiply(a.dot(e));
      var n = a.minus(b); //Check if vector b lays on the vector ab

      if (b.length() > ab.length()) {
        return -1;
      }

      if (b.dot(ab) < 0) {
        return -1;
      }

      return n.length();
    }
  }]);

  return Segment;
}(_sketch_object__WEBPACK_IMPORTED_MODULE_0__["SketchObject"]);
Segment.prototype._class = 'TCAD.TWO.Segment';

/***/ }),

/***/ "./web/app/sketcher/shapes/shape.js":
/*!******************************************!*\
  !*** ./web/app/sketcher/shapes/shape.js ***!
  \******************************************/
/*! exports provided: Shape */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Shape =
/*#__PURE__*/
function () {
  function Shape() {
    _classCallCheck(this, Shape);

    this.visible = true;
    this.style = null;
    this.role = null;
  }

  _createClass(Shape, [{
    key: "accept",
    value: function accept(visitor) {
      return visitor(this);
    }
  }, {
    key: "draw",
    value: function draw(ctx, scale) {}
  }]);

  return Shape;
}();

/***/ }),

/***/ "./web/app/sketcher/shapes/sketch-object.js":
/*!**************************************************!*\
  !*** ./web/app/sketcher/shapes/sketch-object.js ***!
  \**************************************************/
/*! exports provided: SketchObject, pointIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SketchObject", function() { return SketchObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointIterator", function() { return pointIterator; });
/* harmony import */ var _id_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../id-generator */ "./web/app/sketcher/id-generator.js");
/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shape */ "./web/app/sketcher/shapes/shape.js");
/* harmony import */ var _io__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../io */ "./web/app/sketcher/io.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var SketchObject =
/*#__PURE__*/
function (_Shape) {
  _inherits(SketchObject, _Shape);

  function SketchObject() {
    var _this;

    _classCallCheck(this, SketchObject);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SketchObject).call(this));
    _this.id = _id_generator__WEBPACK_IMPORTED_MODULE_0__["Generator"].genID();
    _this.aux = false;
    _this.marked = null;
    _this.children = [];
    _this.linked = [];
    _this.layer = null;
    return _this;
  }

  _createClass(SketchObject, [{
    key: "normalDistance",
    value: function normalDistance(aim, scale) {
      return -1;
    }
  }, {
    key: "addChild",
    value: function addChild(child) {
      this.children.push(child);
      child.parent = this;
    }
  }, {
    key: "accept",
    value: function accept(visitor) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var child = _step.value;

          if (!child.accept(visitor)) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return visitor(this);
    }
  }, {
    key: "stabilize",
    value: function stabilize(viewer) {}
  }, {
    key: "recoverIfNecessary",
    value: function recoverIfNecessary() {
      return false;
    }
  }, {
    key: "isAuxOrLinkedTo",
    value: function isAuxOrLinkedTo() {
      if (!!this.aux) {
        return true;
      }

      for (var i = 0; i < this.linked.length; ++i) {
        if (!!this.linked[i].aux) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_translate",
    value: function _translate(dx, dy, translated) {
      translated[this.id] = 'x';

      for (var i = 0; i < this.linked.length; ++i) {
        if (translated[this.linked[i].id] != 'x') {
          this.linked[i]._translate(dx, dy, translated);
        }
      }

      this.translateImpl(dx, dy);
    }
  }, {
    key: "translate",
    value: function translate(dx, dy) {
      //  this.translateImpl(dx, dy);
      if (this.isAuxOrLinkedTo()) {
        return;
      }

      this._translate(dx, dy, {});
    }
  }, {
    key: "translateImpl",
    value: function translateImpl(dx, dy) {
      this.accept(function (obj) {
        if (obj._class === 'TCAD.TWO.EndPoint') {
          obj.translate(dx, dy);
        }

        return true;
      });
    }
  }, {
    key: "draw",
    value: function draw(ctx, scale, viewer) {
      if (!this.visible) return;

      if (this.marked != null) {
        ctx.save();
        viewer.setStyle(this.marked, ctx);
      }

      this.drawImpl(ctx, scale, viewer);
      if (this.marked != null) ctx.restore();
    }
  }, {
    key: "copy",
    value: function copy() {
      throw 'method not implemented';
    }
  }, {
    key: "mirror",
    value: function mirror(dest, mirroringFunc) {
      var sourcePoints = [];
      pointIterator(this, function (o) {
        sourcePoints.push(o);
      });
      var i = 0;
      pointIterator(dest, function (o) {
        sourcePoints[i++].mirror(o, mirroringFunc);
      });
    }
  }, {
    key: "visitParams",
    value: function visitParams(callback) {
      throw 'method not implemented';
    }
  }, {
    key: "collectParams",
    value: function collectParams(params) {
      this.visitParams(function (p) {
        return params.push(p);
      });
    }
  }, {
    key: "simpleClassName",
    get: function get() {
      return this._class.replace('TCAD.TWO.', '');
    }
  }, {
    key: "effectiveLayer",
    get: function get() {
      var shape = this;

      while (shape) {
        if (shape.layer) {
          return shape.layer;
        }

        shape = shape.parent;
      }

      return null;
    }
  }]);

  return SketchObject;
}(_shape__WEBPACK_IMPORTED_MODULE_1__["Shape"]);
function pointIterator(shape, func) {
  shape.accept(function (o) {
    if (o._class === _io__WEBPACK_IMPORTED_MODULE_2__["Types"].END_POINT) {
      func(o);
    }

    return true;
  });
}

/***/ }),

/***/ "./web/app/sketcher/sketcher-app.js":
/*!******************************************!*\
  !*** ./web/app/sketcher/sketcher-app.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _viewer2d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewer2d.js */ "./web/app/sketcher/viewer2d.js");
/* harmony import */ var _ui_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/ui */ "./web/app/ui/ui.js");
/* harmony import */ var _ui_terminal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/terminal */ "./web/app/ui/terminal.js");
/* harmony import */ var _io__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./io */ "./web/app/sketcher/io.js");
/* harmony import */ var _tools_dim__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tools/dim */ "./web/app/sketcher/tools/dim.js");
/* harmony import */ var _tools_point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tools/point */ "./web/app/sketcher/tools/point.js");
/* harmony import */ var _tools_segment__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tools/segment */ "./web/app/sketcher/tools/segment.js");
/* harmony import */ var _tools_arc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tools/arc */ "./web/app/sketcher/tools/arc.js");
/* harmony import */ var _tools_circle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tools/circle */ "./web/app/sketcher/tools/circle.js");
/* harmony import */ var _tools_fillet__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tools/fillet */ "./web/app/sketcher/tools/fillet.js");
/* harmony import */ var _tools_ellipse__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tools/ellipse */ "./web/app/sketcher/tools/ellipse.js");
/* harmony import */ var _tools_bezier_curve__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tools/bezier-curve */ "./web/app/sketcher/tools/bezier-curve.js");
/* harmony import */ var _tools_rectangle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tools/rectangle */ "./web/app/sketcher/tools/rectangle.js");
/* harmony import */ var _tools_offset__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./tools/offset */ "./web/app/sketcher/tools/offset.js");
/* harmony import */ var _tools_origin__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./tools/origin */ "./web/app/sketcher/tools/origin.js");
/* harmony import */ var _input_manager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./input-manager */ "./web/app/sketcher/input-manager.js");
/* harmony import */ var _utils_genSerpinski__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/genSerpinski */ "./web/app/utils/genSerpinski.js");


















function App2D() {
  var _this = this;

  var app = this;
  this.viewer = new _viewer2d_js__WEBPACK_IMPORTED_MODULE_0__["Viewer"](document.getElementById('viewer'), _io__WEBPACK_IMPORTED_MODULE_3__["IO"]);
  this.winManager = new _ui_ui__WEBPACK_IMPORTED_MODULE_1__["WinManager"]();
  this.inputManager = new _input_manager__WEBPACK_IMPORTED_MODULE_15__["InputManager"](this);
  this.initSketchManager();
  this._exportWin = new _ui_ui__WEBPACK_IMPORTED_MODULE_1__["Window"]($('#exportManager'), app.winManager);
  $('#exportManager li').click(function () {
    _ui_ui__WEBPACK_IMPORTED_MODULE_1__["closeWin"](app._exportWin);
  });
  this.constraintFilter = {};
  this.actions = {};
  this.commands = {}; //For debug view

  this._actionsOrder = [];
  var dockEl = $('#dock');
  var buttonGroup = $('#status .button-group');
  this.dock = new _ui_ui__WEBPACK_IMPORTED_MODULE_1__["Dock"](dockEl, buttonGroup, App2D.views);
  this.dock.show('Constraints');
  var consoleBtn = _ui_ui__WEBPACK_IMPORTED_MODULE_1__["dockBtn"]('Commands', 'list');
  buttonGroup.append(consoleBtn);
  this.commandsWin = new _ui_ui__WEBPACK_IMPORTED_MODULE_1__["Window"]($('#commands'), this.winManager);
  this.commandsWin.tileUpRelative = $('#viewer');
  consoleBtn.click(function (e) {
    _this.actions['terminal'].action(e);
  });
  $(document).on('mousemove', '#viewer', function (e) {
    var coord = _this.viewer.screenToModel(e);

    $('.coordinates-info').text(_this.viewer.roundToPrecision(coord.x) + " : " + _this.viewer.roundToPrecision(coord.y));
  });
  this.terminalHandler = undefined;
  this.terminal = new _ui_terminal__WEBPACK_IMPORTED_MODULE_2__["Terminal"](this.commandsWin, function (command) {
    return _this.handleTerminalInput(command);
  }, function () {
    return _this.getAllCommandList();
  });
  this.bindToolsToTerminal();
  this.winManager.registerResize(dockEl, _ui_ui__WEBPACK_IMPORTED_MODULE_1__["DIRECTIONS"].EAST, function () {
    $('body').trigger('layout');
  });
  $('body').on('layout', this.viewer.onWindowResize);

  this.registerAction = function (id, desc, action, command) {
    app.actions[id] = {
      id: id,
      desc: desc,
      action: action
    };

    if (command) {
      app.commands[command] = id;
    }

    app._actionsOrder.push(id);
  };

  function checkForTerminalVisibility() {
    var terminalVisible = app.commandsWin.root.is(':visible');

    if (terminalVisible) {
      app.terminal.scrollToTheEnd();
    }

    app.viewer.referencePoint.visible = terminalVisible;
  }

  checkForTerminalVisibility();
  this.registerAction('new', "Create New Sketch", function () {
    app.newSketch();
  });
  this.registerAction('terminal', "Open/Close Terminal Window", function () {
    app.commandsWin.toggle();
    checkForTerminalVisibility();
    app.viewer.refresh();
  });
  this.registerAction('open', "Open Sketch", function (e) {
    app._sketchesList.refresh();

    _ui_ui__WEBPACK_IMPORTED_MODULE_1__["openWin"](app._sketchesWin, e);
  });
  this.registerAction('clone', "Clone Sketch", function () {
    app.cloneSketch();
  });
  this.registerAction('export', "Export", function (e) {
    _ui_ui__WEBPACK_IMPORTED_MODULE_1__["openWin"](app._exportWin, e);
  });
  this.registerAction('exportSVG', "Export To SVG", function () {
    _io__WEBPACK_IMPORTED_MODULE_3__["IO"].exportTextData(app.viewer.io.svgExport(), app.getSketchId() + ".svg");
  });
  this.registerAction('exportDXF', "Export To DXF", function () {
    _io__WEBPACK_IMPORTED_MODULE_3__["IO"].exportTextData(app.viewer.io.dxfExport(), app.getSketchId() + ".dxf");
  });
  this.registerAction('undo', "Undo", function () {
    app.viewer.historyManager.undo();
  });
  this.registerAction('redo', "Redo", function () {
    app.viewer.historyManager.redo();
  });
  this.registerAction('checkpoint', "Checkpoint", function () {
    app.viewer.historyManager.checkpoint();
  });
  this.registerAction('referencePoint', "Set Reference Point", function () {
    app.viewer.toolManager.takeControl(new _tools_origin__WEBPACK_IMPORTED_MODULE_14__["ReferencePointTool"](app.viewer));
  }, "origin");
  this.registerAction('addPoint', "Add Point", function () {
    app.viewer.toolManager.takeControl(new _tools_point__WEBPACK_IMPORTED_MODULE_5__["AddPointTool"](app.viewer));
  }, "point");
  this.registerAction('addSegment', "Add Segment", function () {
    app.viewer.toolManager.takeControl(new _tools_segment__WEBPACK_IMPORTED_MODULE_6__["AddSegmentTool"](app.viewer, false));
  }, 'line');
  this.registerAction('addMultiSegment', "Add Multi Segment", function () {
    app.viewer.toolManager.takeControl(new _tools_segment__WEBPACK_IMPORTED_MODULE_6__["AddSegmentTool"](app.viewer, true));
  }, 'mline');
  this.registerAction('addArc', "Add Arc", function () {
    app.viewer.toolManager.takeControl(new _tools_arc__WEBPACK_IMPORTED_MODULE_7__["AddArcTool"](app.viewer));
  }, 'arc');
  this.registerAction('addCircle', "Add Circle", function () {
    app.viewer.toolManager.takeControl(new _tools_circle__WEBPACK_IMPORTED_MODULE_8__["EditCircleTool"](app.viewer));
  }, 'circle');
  this.registerAction('addEllipse', "Add Ellipse", function () {
    app.viewer.toolManager.takeControl(new _tools_ellipse__WEBPACK_IMPORTED_MODULE_10__["EllipseTool"](app.viewer, false));
  });
  this.registerAction('addEllipticalArc', "Add Elliptical Arc", function () {
    app.viewer.toolManager.takeControl(new _tools_ellipse__WEBPACK_IMPORTED_MODULE_10__["EllipseTool"](app.viewer, true));
  });
  this.registerAction('addBezierCurve', "Add Bezier Curve", function () {
    app.viewer.toolManager.takeControl(new _tools_bezier_curve__WEBPACK_IMPORTED_MODULE_11__["BezierCurveTool"](app.viewer));
  });
  this.registerAction('addRectangle', "Add Rectangle", function () {
    app.viewer.toolManager.takeControl(new _tools_rectangle__WEBPACK_IMPORTED_MODULE_12__["RectangleTool"](app.viewer));
  }, 'rect');
  this.registerAction('offsetTool', "Polygon Offset", function () {
    app.viewer.toolManager.takeControl(new _tools_offset__WEBPACK_IMPORTED_MODULE_13__["OffsetTool"](app.viewer));
  });
  this.registerAction('pan', "Pan", function () {
    app.viewer.toolManager.releaseControl();
  });
  this.registerAction('addFillet', "Add Fillet", function () {
    app.viewer.toolManager.takeControl(new _tools_fillet__WEBPACK_IMPORTED_MODULE_9__["FilletTool"](app.viewer));
  });
  this.registerAction('addDim', "Add Dimension", function () {
    app.viewer.toolManager.takeControl(new _tools_dim__WEBPACK_IMPORTED_MODULE_4__["AddFreeDimTool"](app.viewer, app.viewer.dimLayer));
  });
  this.registerAction('addHDim', "Add Horizontal Dimension", function () {
    app.viewer.toolManager.takeControl(new _tools_dim__WEBPACK_IMPORTED_MODULE_4__["AddHorizontalDimTool"](app.viewer, app.viewer.dimLayer));
  });
  this.registerAction('addVDim', "Add Vertical Dimension", function () {
    app.viewer.toolManager.takeControl(new _tools_dim__WEBPACK_IMPORTED_MODULE_4__["AddVerticalDimTool"](app.viewer, app.viewer.dimLayer));
  });
  this.registerAction('addCircleDim', "Add Circle Dimension", function () {
    app.viewer.toolManager.takeControl(new _tools_dim__WEBPACK_IMPORTED_MODULE_4__["AddCircleDimTool"](app.viewer, app.viewer.dimLayer));
  });
  this.registerAction('save', "Save", function () {
    var sketchData = app.viewer.io.serializeSketch();
    var sketchId = app.getSketchId();
    localStorage.setItem(app.getSketchId(), sketchData);
    app.viewer.historyManager.checkpoint();
  });
  this.registerAction('coincident', "Coincident", function () {
    app.viewer.parametricManager.coincident(app.viewer.selected);
  });
  this.registerAction('verticalConstraint', "Vertical Constraint", function () {
    app.viewer.parametricManager.vertical(app.viewer.selected);
  });
  this.registerAction('horizontalConstraint', "Horizontal Constraint", function () {
    app.viewer.parametricManager.horizontal(app.viewer.selected);
  });
  this.registerAction('parallelConstraint', "Parallel Constraint", function () {
    app.viewer.parametricManager.parallel(app.viewer.selected);
  });
  this.registerAction('perpendicularConstraint', "Perpendicular Constraint", function () {
    app.viewer.parametricManager.perpendicular(app.viewer.selected);
  });
  this.registerAction('P2LDistanceConstraint', "Distance Between Point and Line", function () {
    app.viewer.parametricManager.p2lDistance(app.viewer.selected, prompt);
  });
  this.registerAction('mirrorConstraint', "Mirror Constraint", function () {
    app.viewer.parametricManager.mirror(app.viewer.selected);
  });
  this.registerAction('P2PDistanceConstraint', "Distance Between two Points", function () {
    app.viewer.parametricManager.p2pDistance(app.viewer.selected, prompt);
  });
  this.registerAction('RadiusConstraint', "Radius Constraint", function () {
    app.viewer.parametricManager.radius(app.viewer.selected, prompt);
  });
  this.registerAction('EntityEqualityConstraint', "Radius Equals Constraint", function () {
    app.viewer.parametricManager.entityEquality(app.viewer.selected);
  });
  this.registerAction('tangentConstraint', "Tangent Constraint", function () {
    app.viewer.parametricManager.tangent(app.viewer.selected);
  });
  this.registerAction('lockConstraint', "Lock Constraint", function () {
    app.viewer.parametricManager.lock(app.viewer.selected);
  });
  this.registerAction('pointOnLine', "Point On Line", function () {
    app.viewer.parametricManager.pointOnLine(app.viewer.selected);
  });
  this.registerAction('pointOnArc', "Point On Arc / Ellipse", function () {
    app.viewer.parametricManager.pointOnArc(app.viewer.selected);
  });
  this.registerAction('pointInMiddle', "Point In the Middle", function () {
    app.viewer.parametricManager.pointInMiddle(app.viewer.selected);
  });
  this.registerAction('llAngle', "Angle Between 2 Lines", function () {
    app.viewer.parametricManager.llAngle(app.viewer.selected, prompt);
  });
  this.registerAction('symmetry', "Symmetry", function () {
    app.viewer.parametricManager.symmetry(app.viewer.selected, prompt);
  });
  this.registerAction('lockConvex', "Lock Convexity", function () {
    app.viewer.parametricManager.lockConvex(app.viewer.selected, alert);
  });
  this.registerAction('analyzeConstraint', "Analyze Constraint", function () {
    app.viewer.parametricManager.analyze(alert);
  });
  this.registerAction('solve', "Solve System", function () {
    app.viewer.parametricManager.solve();
    app.viewer.refresh();
  });
  this.registerAction('CLEAN UP', "Clean All Draw", function () {
    app.cleanUpData();
    app.viewer.refresh();
  });
  this.registerAction('fit', "Fit Sketch On Screen", function () {
    app.fit();
    app.viewer.refresh();
  });
  this.registerAction('genSerpinski', "Generate Serpinki Triangle off of a segment", function () {
    Object(_utils_genSerpinski__WEBPACK_IMPORTED_MODULE_16__["default"])(app.viewer);
  });
}

App2D.views = [{
  name: 'Dimensions',
  icon: 'arrows-v'
}, {
  name: 'Properties',
  icon: 'sliders'
}, {
  name: 'Constraints',
  icon: 'cogs'
}, {
  name: 'Mirroring',
  icon: 'mirror'
}];

App2D.prototype.fit = function () {
  var bbox = new _io__WEBPACK_IMPORTED_MODULE_3__["BBox"]();

  for (var l = 0; l < this.viewer.layers.length; ++l) {
    var layer = this.viewer.layers[l];

    for (var i = 0; i < layer.objects.length; ++i) {
      var obj = layer.objects[i];
      bbox.check(obj);
    }
  }

  if (!bbox.isValid()) {
    return;
  }

  var bounds = bbox.bbox;
  this.viewer.showBounds(bounds[0], bounds[1], bounds[2], bounds[3]);
  bbox.inc(20 / this.viewer.scale);
  this.viewer.showBounds(bounds[0], bounds[1], bounds[2], bounds[3]);
};

App2D.prototype.cloneSketch = function () {
  var name = prompt("Name for sketch clone");

  if (name != null) {
    if (this.isSketchExists(name)) {
      alert("Sorry, a sketch with the name '" + name + "' already exists. Won't override it.");
      return;
    }

    localStorage.setItem(App2D.STORAGE_PREFIX + name, this.viewer.io.serializeSketch());
    this.openSketch(name);
  }
};

App2D.prototype.isSketchExists = function (name) {
  return localStorage.getItem(App2D.STORAGE_PREFIX + name) != null;
};

App2D.prototype.openSketch = function (name) {
  var uri = window.location.href.split("#")[0];

  if (name !== "untitled") {
    uri += "#" + name;
  }

  var win = window.open(uri, '_blank');
  win.focus();
};

App2D.prototype.newSketch = function () {
  var name = prompt("Name for sketch");

  if (name != null) {
    if (this.isSketchExists(name)) {
      alert("Sorry, a sketch with the name '" + name + "' already exists. Won't override it.");
      return;
    }

    this.openSketch(name);
  }
};

App2D.prototype.initSketchManager = function (data, ext) {
  this._sketchesWin = new _ui_ui__WEBPACK_IMPORTED_MODULE_1__["Window"]($('#sketchManager'), this.winManager);
  var app = this;
  var sketchesList = new _ui_ui__WEBPACK_IMPORTED_MODULE_1__["List"]('sketchList', {
    items: function items() {
      var theItems = [];

      for (var name in localStorage) {
        if (!localStorage.hasOwnProperty(name)) {
          continue;
        }

        if (name.indexOf(App2D.STORAGE_PREFIX) === 0) {
          name = name.substring(App2D.STORAGE_PREFIX.length);
        }

        theItems.push({
          name: name
        });
      }

      return theItems;
    },
    remove: function remove(item) {
      if (confirm("Selected sketch will be REMOVED! Are you sure?")) {
        localStorage.removeItem(App2D.STORAGE_PREFIX + item.name);
        sketchesList.refresh();
      }
    },
    mouseleave: function mouseleave(item) {},
    hover: function hover(item) {},
    click: function click(item) {
      app.openSketch(item.name);
    }
  });
  $('#sketchManager').find('.content').append(sketchesList.ul);
  sketchesList.refresh();
  this._sketchesList = sketchesList;
};

App2D.prototype.loadFromLocalStorage = function () {
  var sketchId = this.getSketchId();
  var sketchData = localStorage.getItem(sketchId);

  if (sketchData != null) {
    this.viewer.historyManager.init(sketchData);
    this.viewer.io.loadSketch(sketchData);
  }

  this.viewer.repaint();
};

App2D.prototype.getSketchId = function () {
  var id = window.location.hash.substring(1);

  if (!id) {
    id = "untitled";
  }

  return App2D.STORAGE_PREFIX + id;
};

App2D.prototype.bindToolsToTerminal = function () {
  var _this2 = this;

  var toolCommandProcessor = function toolCommandProcessor(command) {
    return _this2.viewer.toolManager.tool.processCommand(command);
  };

  this.viewer.bus.subscribe('tool-change', function () {
    var tool = _this2.viewer.toolManager.tool;
    _this2.terminalHandler = tool.processCommand ? toolCommandProcessor : undefined;
    $('.tool-info').text('tool: ' + tool.name);
    $('.tool-hint').text('');
  })();
  this.viewer.bus.subscribe('tool-message', function (message) {
    _this2.terminal.print(message);
  });
  this.viewer.bus.subscribe('tool-hint', function (message) {
    _this2.terminal.print(message);

    $('.tool-hint').text(message);
  });
};

App2D.STATIC_COMMANDS = {
  "time": function time() {
    return new Date();
  },
  "help": function help(app) {
    return app.getAllCommandList().join(", ");
  }
};

App2D.prototype.getAllCommandList = function () {
  var commands = Object.keys(this.commands);
  commands.push.apply(commands, Object.keys(App2D.STATIC_COMMANDS));
  commands.sort();
  return commands;
};

App2D.prototype.handleTerminalInput = function (commandStr) {
  commandStr = commandStr.trim();

  if (this.terminalHandler) {
    return this.terminalHandler(commandStr);
  } else {
    var cmd = App2D.STATIC_COMMANDS[commandStr];

    if (cmd) {
      return cmd(this);
    }

    var actionId = this.commands[commandStr];

    if (actionId) {
      this.actions[actionId].action();
    } else {
      try {
        return eval(commandStr);
      } catch (e) {}
    }
  }
};

App2D.STORAGE_PREFIX = "TCAD.projects.";
/* harmony default export */ __webpack_exports__["default"] = (App2D);

/***/ }),

/***/ "./web/app/sketcher/sketcherStreams.js":
/*!*********************************************!*\
  !*** ./web/app/sketcher/sketcherStreams.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lstream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lstream */ "./modules/lstream/index.js");

/* harmony default export */ __webpack_exports__["default"] = (function (viewer) {
  var streams = {};
  streams.objectsUpdate = Object(lstream__WEBPACK_IMPORTED_MODULE_0__["stream"])();
  streams.objects = streams.objectsUpdate.throttle().map(function () {
    var objects = [];
    viewer.layers.forEach(function (l) {
      return l.objects.forEach(function (o) {
        return objects.push(o);
      });
    });
    return objects;
  }).remember([]);
  streams.addingRoleMode = Object(lstream__WEBPACK_IMPORTED_MODULE_0__["state"])(null);
  streams.selection = Object(lstream__WEBPACK_IMPORTED_MODULE_0__["state"])([]);
  streams.objectUpdate = Object(lstream__WEBPACK_IMPORTED_MODULE_0__["stream"])();
  streams.constraintsUpdate = Object(lstream__WEBPACK_IMPORTED_MODULE_0__["stream"])();
  return streams;
});
;

/***/ }),

/***/ "./web/app/sketcher/styles.js":
/*!************************************!*\
  !*** ./web/app/sketcher/styles.js ***!
  \************************************/
/*! exports provided: Styles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Styles", function() { return Styles; });
var Styles = {
  DEFAULT: {
    lineWidth: 2,
    strokeStyle: "#ffffff",
    fillStyle: "#000000"
  },
  VIRTUAL: {
    lineWidth: 2,
    strokeStyle: "#ffffff88",
    fillStyle: "#00000088"
  },
  SERVICE: {
    lineWidth: 0.3,
    strokeStyle: "#ff0000",
    fillStyle: "#FF0000"
  },
  MARK: {
    lineWidth: 2,
    strokeStyle: "#ff0000",
    fillStyle: "#FF0000"
  },
  SNAP: {
    lineWidth: 2,
    strokeStyle: "#00FF00",
    fillStyle: "#00FF00"
  },
  DIM: {
    lineWidth: 1,
    strokeStyle: "#bcffc1",
    fillStyle: "#00FF00"
  },
  BOUNDS: {
    lineWidth: 2,
    strokeStyle: "#fff5c3",
    fillStyle: "#000000"
  },
  CONSTRUCTION: {
    lineWidth: 1,
    strokeStyle: "#aaaaaa",
    fillStyle: "#000000"
  },
  CONSTRUCTION_OF_OBJECT: {
    lineWidth: 1,
    strokeStyle: "#888888",
    fillStyle: "#000000"
  }
};

/***/ }),

/***/ "./web/app/sketcher/system.js":
/*!************************************!*\
  !*** ./web/app/sketcher/system.js ***!
  \************************************/
/*! exports provided: System */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "System", function() { return System; });
/* harmony import */ var _modules_gems_iterables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../modules/gems/iterables */ "./modules/gems/iterables.js");
/* harmony import */ var _parametric__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parametric */ "./web/app/sketcher/parametric.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var SUB_SYSTEM_ORDER = 0;

var SubSystem =
/*#__PURE__*/
function () {
  function SubSystem() {
    _classCallCheck(this, SubSystem);

    this.alg = 1;
    this.error = 0;
    this.reduce = false;
    this.constraints = [];
    this.dependencies = [];
    this.nativeParams = new Set();
    this._internaOrder = SUB_SYSTEM_ORDER++;
  }

  _createClass(SubSystem, [{
    key: "mergeWith",
    value: function mergeWith(other) {
      var _this = this;

      other.constraints.forEach(function (c) {
        return _this.constraints.push(c);
      });
      other.dependencies.forEach(function (d) {
        if (_this.dependencies.indexOf(d) === -1) {
          _this.dependencies.push(d);
        }
      });
      other.nativeParams.forEach(function (p) {
        return _this.nativeParams.add(p);
      });
    }
  }]);

  return SubSystem;
}();

var Index =
/*#__PURE__*/
function () {
  function Index() {
    _classCallCheck(this, Index);

    this.constraints = [];
    this.paramToConstraintsIndex = new Map();
    this.paramToConstraintsGraph = new Map();
    this.generatorConstraints = [];
    this.generatedParams = new Map();
  }

  _createClass(Index, [{
    key: "_reset",
    value: function _reset() {
      this.constraints = [];
      this.paramToConstraintsIndex.clear();
      this.paramToConstraintsGraph.clear();
      this.generatorConstraints = [];
      this.generatedParams.clear();
    }
  }, {
    key: "_pushConstraint",
    value: function _pushConstraint(constr) {
      var _this2 = this;

      this.constraints.push(constr);
      visitParams(constr, true, function (p) {
        return Object(_modules_gems_iterables__WEBPACK_IMPORTED_MODULE_0__["addToSetInMap"])(_this2.paramToConstraintsGraph, p, constr);
      });
      visitParams(constr, false, function (p) {
        return Object(_modules_gems_iterables__WEBPACK_IMPORTED_MODULE_0__["addToSetInMap"])(_this2.paramToConstraintsIndex, p, constr);
      });

      if (constr.GENERATOR) {
        this.generatorConstraints.push(constr);
        constr.visitGeneratedParams(function (p) {
          return _this2.generatedParams.set(p, constr);
        });
      }
    }
  }, {
    key: "_popConstraint",
    value: function _popConstraint(constr) {
      var _this3 = this;

      Object(_modules_gems_iterables__WEBPACK_IMPORTED_MODULE_0__["removeInPlace"])(this.constraints, constr);
      visitParams(constr, true, function (p) {
        return Object(_modules_gems_iterables__WEBPACK_IMPORTED_MODULE_0__["removeFromSetInMap"])(_this3.paramToConstraintsGraph, p, constr);
      });
      visitParams(constr, false, function (p) {
        return Object(_modules_gems_iterables__WEBPACK_IMPORTED_MODULE_0__["removeFromSetInMap"])(_this3.paramToConstraintsIndex, p, constr);
      });

      if (constr.GENERATOR) {
        Object(_modules_gems_iterables__WEBPACK_IMPORTED_MODULE_0__["removeInPlace"])(this.generatorConstraints, constr);
        constr.visitGeneratedParams(function (p) {
          return _this3.generatedParams["delete"](p);
        });
      }
    }
  }]);

  return Index;
}();

var System =
/*#__PURE__*/
function (_Index) {
  _inherits(System, _Index);

  function System() {
    var _this4;

    _classCallCheck(this, System);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(System).call(this));
    _this4.subSystems = [];
    _this4.constraintToSubSystem = new Map();
    _this4.paramToSubSystem = new Map();
    return _this4;
  }

  _createClass(System, [{
    key: "_reset",
    value: function _reset() {
      _get(_getPrototypeOf(System.prototype), "_reset", this).call(this);

      this.subSystems = [];
      this.constraintToSubSystem.clear();
      this.paramToSubSystem.clear();
      COUNTER = 0;
    }
  }, {
    key: "_collectDependenciesForSubSystemFromConstraint",
    value: function _collectDependenciesForSubSystemFromConstraint(subSystem, constr) {
      var _this5 = this;

      visitParams(constr, false, function (p) {
        var generator = _this5.generatedParams.get(p);

        if (generator) {
          var generatorSS = _this5.constraintToSubSystem.get(generator);

          if (generatorSS) {
            if (subSystem.dependencies.indexOf(generatorSS) === -1) {
              subSystem.dependencies.push(generatorSS);
            }
          }
        }
      });
    }
  }, {
    key: "_rebuildDependencies",
    value: function _rebuildDependencies() {
      var _this6 = this;

      this.subSystems.forEach(function (ss) {
        if (ss.dependencies.length !== 0) {
          ss.dependencies = [];
        }
      });
      this.subSystems.forEach(function (subSystem) {
        subSystem.constraints.forEach(function (constr) {
          _this6._collectDependenciesForSubSystemFromConstraint(subSystem, constr);
        });
      });
    }
  }, {
    key: "_groupBySubsystems",
    value: function _groupBySubsystems() {
      var _this7 = this;

      if (this.subSystems.length !== 0) {
        this.subSystems = [];
      }

      this.constraintToSubSystem.clear();
      var visited = new Set();
      this.constraints.forEach(function (constr) {
        if (visited.has(constr)) {
          return;
        }

        var subSystem = _this7.createSubSystem();

        var stack = [constr];

        var _loop = function _loop() {
          var workingConstr = stack.pop();

          if (visited.has(workingConstr)) {
            return "continue";
          }

          _this7._assignConstraint(workingConstr, subSystem);

          visited.add(workingConstr);
          visitParams(workingConstr, true, function (p) {
            var constrs = _this7.paramToConstraintsGraph.get(p);

            if (constrs) {
              constrs.forEach(function (constrToAdvance) {
                if (constrToAdvance !== workingConstr) {
                  stack.push(constrToAdvance);
                }
              });
            }
          });
        };

        while (stack.length) {
          var _ret = _loop();

          if (_ret === "continue") continue;
        }
      });
    }
  }, {
    key: "_rebuild",
    value: function _rebuild() {
      this._groupBySubsystems();

      this._rebuildDependencies();
    }
  }, {
    key: "_assignConstraint",
    value: function _assignConstraint(constr, subSystem) {
      subSystem.constraints.push(constr);
      this.constraintToSubSystem.set(constr, subSystem);
    }
  }, {
    key: "add",
    value: function add(constr) {
      var _this8 = this;

      constr.id = "C_" + COUNTER++; //fixme

      var affectedSubsystems = new Set();
      var freeParams = [];
      visitParams(constr, false, function (p) {
        var subSystem = _this8.paramToSubSystem.get(p);

        if (subSystem) {
          affectedSubsystems.add(subSystem);
        } else {
          if (!isAuxParam(p) && !_this8.generatedParams.has(p)) {
            freeParams.push(p);
          }
        }
      });
      affectedSubsystems.forEach(function (ss) {
        ss.dependencies.forEach(function (d) {
          return affectedSubsystems["delete"](d);
        });
      });
      var toMerge = Array.from(affectedSubsystems).sort(function (a, b) {
        return a._internaOrder - b._internaOrder;
      });
      var master;

      if (toMerge.length === 0) {
        // console.error("system has circular dependencies");
        master = this.createSubSystem();
      } else {
        var _toMerge = toMerge;

        var _toMerge2 = _toArray(_toMerge);

        master = _toMerge2[0];
        toMerge = _toMerge2.slice(1);
      }

      toMerge.forEach(function (s) {
        master.mergeWith(s);
        s.nativeParams.forEach(function (p) {
          return _this8.paramToSubSystem.set(p, master);
        });
        Object(_modules_gems_iterables__WEBPACK_IMPORTED_MODULE_0__["removeInPlace"])(_this8.subSystems, s);
      });
      freeParams.forEach(function (p) {
        master.nativeParams.add(p);

        _this8.paramToSubSystem.set(p, master);
      });
      master.constraints.push(constr);
      this.constraintToSubSystem.set(constr, master);

      if (constr.GENERATOR) {
        var dependant = this.createSubSystem();
        dependant.dependencies.push(master);
        constr.visitGeneratedParams(function (p) {
          _this8.generatedParams.set(p, constr);

          _this8.paramToSubSystem.set(p, dependant);
        });
      }

      this._pushConstraint(constr);
    }
  }, {
    key: "remove",
    value: function remove(constr) {
      Object(_modules_gems_iterables__WEBPACK_IMPORTED_MODULE_0__["removeInPlace"])(this.constraints, constr);
      this.setConstraints(this.constraints);
    }
  }, {
    key: "setConstraints",
    value: function setConstraints(constraints) {
      var _this9 = this;

      this._reset();

      constraints.forEach(function (c) {
        return _this9.add(c);
      });
    }
  }, {
    key: "subSystemsByParam",
    value: function subSystemsByParam(param, callback) {
      var _this10 = this;

      var constraints = this.paramToConstraintsIndex.get(param);

      if (constraints) {
        constraints.forEach(function (c) {
          return callback(_this10.constraintToSubSystem.get(c));
        });
      }
    }
  }, {
    key: "traverse",
    value: function traverse(callback, onCircular) {
      var visited = new Set();
      var loop = new Set();

      function doVisit(subSystem) {
        if (loop.has(subSystem)) {
          onCircular(subSystem);
          return;
        }

        loop.add(subSystem);
        subSystem.dependencies.forEach(function (dep) {
          if (!visited.has(dep)) {
            doVisit(dep);
          }
        });
        callback(subSystem);
        visited.add(subSystem);
        loop["delete"](subSystem);
      }

      this.subSystems.forEach(doVisit);
    }
  }, {
    key: "createSubSystem",
    value: function createSubSystem() {
      var subSystem = new SubSystem();
      this.subSystems.push(subSystem);
      return subSystem;
    }
  }]);

  return System;
}(Index);

function visitParams(constraint, skipAux, callback) {
  if (skipAux) {
    var delegate = callback;

    callback = function callback(p) {
      if (!isAuxParam(p)) {
        delegate(p);
      }
    };
  }

  if (constraint.visitParams) {
    constraint.visitParams(callback);
  } else {
    constraint.getSolveData(FAKE_RESOLVER).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          sParams = _ref2[1];

      return sParams.forEach(callback);
    });
  }
}

function isAuxParam(param) {
  return _parametric__WEBPACK_IMPORTED_MODULE_1__["ParametricManager"].isAux(param.obj, GOT_NOTHING);
}

var GOT_NOTHING = {
  has: function has() {
    return false;
  }
};

var FAKE_RESOLVER = function FAKE_RESOLVER() {
  return 0;
};

var COUNTER = 0;

/***/ }),

/***/ "./web/app/sketcher/tools/arc.js":
/*!***************************************!*\
  !*** ./web/app/sketcher/tools/arc.js ***!
  \***************************************/
/*! exports provided: AddArcTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddArcTool", function() { return AddArcTool; });
/* harmony import */ var _shapes_arc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shapes/arc */ "./web/app/sketcher/shapes/arc.js");
/* harmony import */ var _shapes_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shapes/point */ "./web/app/sketcher/shapes/point.js");
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tool */ "./web/app/sketcher/tools/tool.js");
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var AddArcTool =
/*#__PURE__*/
function (_Tool) {
  _inherits(AddArcTool, _Tool);

  function AddArcTool(viewer) {
    var _this;

    _classCallCheck(this, AddArcTool);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AddArcTool).call(this, 'arc', viewer));
    _this.arc = null;
    _this.point = null;
    _this._v = new math_vector__WEBPACK_IMPORTED_MODULE_3__["default"](0, 0, 0);
    return _this;
  }

  _createClass(AddArcTool, [{
    key: "restart",
    value: function restart() {
      this.sendHint('specify center');
    }
  }, {
    key: "mousemove",
    value: function mousemove(e) {
      var p = this.viewer.screenToModel(e);

      if (this.point != null) {
        this.point.x = p.x;
        this.point.y = p.y;

        if (this.point.id === this.arc.b.id) {
          //force placement second point on the arc
          var r = this.radiusOfFirstPoint();
          var v = this._v;
          v.set(this.arc.b.x - this.arc.c.x, this.arc.b.y - this.arc.c.y, 0);

          v._normalize()._multiply(r);

          this.arc.b.x = v.x + this.arc.c.x;
          this.arc.b.y = v.y + this.arc.c.y;
        } else {
          this.demoSecondPoint();
        }

        this.viewer.snap(p.x, p.y, [this.arc.a, this.arc.b, this.arc.c]);
        this.viewer.refresh();
      } else {
        this.viewer.snap(p.x, p.y, []);
        this.viewer.refresh();
      }
    }
  }, {
    key: "mouseup",
    value: function mouseup(e) {
      if (this.arc == null) {
        var center = this.viewer.screenToModel(e);
        this.createArcStep(center);
      } else if (this.point.id === this.arc.a.id) {
        this.snapIfNeed(this.arc.a);
        this.startingPointSetStep();
      } else {
        this.snapIfNeed(this.arc.b);
        this.finishStep();
      }
    }
  }, {
    key: "createArcStep",
    value: function createArcStep(p) {
      this.viewer.historyManager.checkpoint();
      this.arc = new _shapes_arc__WEBPACK_IMPORTED_MODULE_0__["Arc"](new _shapes_point__WEBPACK_IMPORTED_MODULE_1__["EndPoint"](p.x, p.y), new _shapes_point__WEBPACK_IMPORTED_MODULE_1__["EndPoint"](p.x, p.y), new _shapes_point__WEBPACK_IMPORTED_MODULE_1__["EndPoint"](p.x, p.y));
      this.point = this.arc.a;
      this.viewer.activeLayer.add(this.arc);
      this.snapIfNeed(this.arc.c);
      this.pointPicked(p.x, p.y);
      this.sendHint('specify arc starting point');
      this.viewer.refresh();
    }
  }, {
    key: "startingPointSetStep",
    value: function startingPointSetStep() {
      this.point = this.arc.b;
      this.pointPicked(this.arc.a.x, this.arc.a.y);
      this.sendHint('specify angle');
    }
  }, {
    key: "finishStep",
    value: function finishStep() {
      this.arc.stabilize(this.viewer);
      this.pointPicked(this.arc.b.x, this.arc.b.y);
      this.viewer.refresh();
      this.viewer.toolManager.releaseControl();
    }
  }, {
    key: "demoSecondPoint",
    value: function demoSecondPoint() {
      var r = this.radiusOfFirstPoint();
      var ang = Math.atan2(this.arc.a.y - this.arc.c.y, this.arc.a.x - this.arc.c.x) + (2 * Math.PI - 0.3);
      ang %= 2 * Math.PI;
      this.arc.b.x = this.arc.c.x + r * Math.cos(ang);
      this.arc.b.y = this.arc.c.y + r * Math.sin(ang);
    }
  }, {
    key: "radiusOfFirstPoint",
    value: function radiusOfFirstPoint() {
      return _math_math__WEBPACK_IMPORTED_MODULE_4__["distance"](this.arc.a.x, this.arc.a.y, this.arc.c.x, this.arc.c.y);
    }
  }, {
    key: "processCommand",
    value: function processCommand(command) {
      if (this.arc == null) {
        var result = _tool__WEBPACK_IMPORTED_MODULE_2__["Tool"].ParseVector(this.viewer.referencePoint, command);
        if (typeof result === 'string') return result;
        this.viewer.cleanSnap();
        this.createArcStep(result);
      } else if (this.point.id === this.arc.a.id) {
        var _result = _tool__WEBPACK_IMPORTED_MODULE_2__["Tool"].ParseVector(this.viewer.referencePoint, command);

        if (typeof _result === 'string') return _result;
        this.arc.a.x = _result.x;
        this.arc.a.y = _result.y;
        this.startingPointSetStep();
        this.demoSecondPoint();
        this.viewer.refresh();
      } else {
        var startingAngle = Math.atan2(this.point.y - this.arc.c.y, this.point.x - this.arc.c.x);

        var _result2 = _tool__WEBPACK_IMPORTED_MODULE_2__["Tool"].ParseNumberWithRef(command, startingAngle); // treated as radius and angle


        var r = this.radiusOfFirstPoint();
        if (typeof _result2 === 'string') return _result2;
        var angle = _result2 / 180 * Math.PI;
        angle %= 2 * Math.PI;
        this.arc.b.x = this.arc.c.x + r * Math.cos(angle);
        this.arc.b.y = this.arc.c.y + r * Math.sin(angle);
        this.finishStep();
      }
    }
  }]);

  return AddArcTool;
}(_tool__WEBPACK_IMPORTED_MODULE_2__["Tool"]);

/***/ }),

/***/ "./web/app/sketcher/tools/bezier-curve.js":
/*!************************************************!*\
  !*** ./web/app/sketcher/tools/bezier-curve.js ***!
  \************************************************/
/*! exports provided: BezierCurveTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BezierCurveTool", function() { return BezierCurveTool; });
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tool */ "./web/app/sketcher/tools/tool.js");
/* harmony import */ var _shapes_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shapes/point */ "./web/app/sketcher/shapes/point.js");
/* harmony import */ var _shapes_bezier_curve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shapes/bezier-curve */ "./web/app/sketcher/shapes/bezier-curve.js");
/* harmony import */ var _parametric__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parametric */ "./web/app/sketcher/parametric.js");
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }







var BezierCurveTool =
/*#__PURE__*/
function (_Tool) {
  _inherits(BezierCurveTool, _Tool);

  function BezierCurveTool(viewer) {
    var _this;

    _classCallCheck(this, BezierCurveTool);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BezierCurveTool).call(this, 'bezier curve', viewer));

    _this.init();

    _this._v = new math_vector__WEBPACK_IMPORTED_MODULE_4__["default"]();
    return _this;
  }

  _createClass(BezierCurveTool, [{
    key: "init",
    value: function init() {
      this.curve = null;
      this.otherCurveEndPoint = null;
    }
  }, {
    key: "restart",
    value: function restart() {
      this.init();
      this.sendHint('specify first point');
    }
  }, {
    key: "cleanup",
    value: function cleanup(e) {
      this.viewer.cleanSnap();
    }
  }, {
    key: "mouseup",
    value: function mouseup(e) {
      if (this.curve == null) {
        this.checkIfConnectedToOtherCurve();
        var p = this.endpoint(e);
        this.curve = new _shapes_bezier_curve__WEBPACK_IMPORTED_MODULE_2__["BezierCurve"](p, p.copy(), p.copy(), p.copy());
        this.viewer.activeLayer.add(this.curve);
        this.viewer.refresh();
      } else {
        this.snapIfNeed(this.curve.b);

        if (this.otherCurveEndPoint != null) {
          this.viewer.parametricManager.add(new _parametric__WEBPACK_IMPORTED_MODULE_3__["Constraints"].Parallel(this.otherCurveEndPoint.parent, this.curve.a.parent));
        }

        this.viewer.toolManager.releaseControl();
        this.viewer.refresh();
      }
    }
  }, {
    key: "mousemove",
    value: function mousemove(e) {
      var p = this.viewer.screenToModel(e);

      if (this.curve != null) {
        this.curve.b.setFromPoint(p);

        var axis = this._v.set(this.curve.b.x - this.curve.a.x, this.curve.b.y - this.curve.a.y)._multiply(0.7); //controlSegment = {x: -controlSegment.y, y: controlSegment.x};


        var controlSegment = _math_math__WEBPACK_IMPORTED_MODULE_5__["rotate"](-axis.y, axis.x, -Math.PI * 0.25);

        if (this.otherCurveEndPoint != null) {
          var ctrlLength = axis.length();
          this.curve.cp1.x = this.curve.a.x + this.snappedControl.x * ctrlLength;
          this.curve.cp1.y = this.curve.a.y + this.snappedControl.y * ctrlLength;

          if (this.snappedControl.x * controlSegment.x + this.snappedControl.y * controlSegment.y < 0) {
            controlSegment.x *= -1;
            controlSegment.y *= -1;
          }
        } else {
          this.curve.cp1.x = this.curve.a.x + controlSegment.x;
          this.curve.cp1.y = this.curve.a.y + controlSegment.y;
        }

        this.curve.cp2.x = this.curve.b.x - controlSegment.x;
        this.curve.cp2.y = this.curve.b.y - controlSegment.y;
        this.viewer.snap(p.x, p.y, [this.curve.a, this.curve.b, this.curve.cp1, this.curve.cp2]);
      } else {
        this.viewer.snap(p.x, p.y, []);
      }

      this.viewer.refresh();
    }
  }, {
    key: "checkIfConnectedToOtherCurve",
    value: function checkIfConnectedToOtherCurve() {
      var snapped = this.viewer.snapped;

      if (snapped != null && snapped.parent && snapped.parent.parent && snapped.parent.parent instanceof _shapes_bezier_curve__WEBPACK_IMPORTED_MODULE_2__["BezierCurve"] && snapped.parent.a === snapped) {
        //only a of Segment is a curve endpoint(other end is a control point) 
        var seg = snapped.parent;
        this.otherCurveEndPoint = snapped;
        this.snappedControl = new math_vector__WEBPACK_IMPORTED_MODULE_4__["default"](seg.b.x - seg.a.x, seg.b.y - seg.a.y)._normalize()._multiply(-1);
      }
    }
  }]);

  return BezierCurveTool;
}(_tool__WEBPACK_IMPORTED_MODULE_0__["Tool"]);

/***/ }),

/***/ "./web/app/sketcher/tools/circle.js":
/*!******************************************!*\
  !*** ./web/app/sketcher/tools/circle.js ***!
  \******************************************/
/*! exports provided: EditCircleTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditCircleTool", function() { return EditCircleTool; });
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tool */ "./web/app/sketcher/tools/tool.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
/* harmony import */ var _shapes_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shapes/point */ "./web/app/sketcher/shapes/point.js");
/* harmony import */ var _shapes_circle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shapes/circle */ "./web/app/sketcher/shapes/circle.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var EditCircleTool =
/*#__PURE__*/
function (_Tool) {
  _inherits(EditCircleTool, _Tool);

  function EditCircleTool(viewer) {
    var _this;

    _classCallCheck(this, EditCircleTool);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EditCircleTool).call(this, 'circle', viewer));
    _this.circle = null;
    return _this;
  }

  _createClass(EditCircleTool, [{
    key: "restart",
    value: function restart() {
      this.sendMessage('specify center');
    }
  }, {
    key: "cleanup",
    value: function cleanup(e) {
      this.viewer.cleanSnap();
    }
  }, {
    key: "mousemove",
    value: function mousemove(e) {
      var p = this.viewer.screenToModel(e);

      if (this.circle != null) {
        var r = _math_math__WEBPACK_IMPORTED_MODULE_1__["distance"](p.x, p.y, this.circle.c.x, this.circle.c.y);
        this.circle.r.set(r);

        if (!_tool__WEBPACK_IMPORTED_MODULE_0__["Tool"].dumbMode(e)) {
          this.solveRequest(true);
        }
      } else {
        this.viewer.snap(p.x, p.y, []);
      }

      this.viewer.refresh();
    }
  }, {
    key: "solveRequest",
    value: function solveRequest(rough) {
      this.solver = this.viewer.parametricManager.prepare([this.circle.r]);
      this.solver.solve(rough, 1);
    }
  }, {
    key: "mouseup",
    value: function mouseup(e) {
      if (this.circle == null) {
        this.stepCreateCircle(this.viewer.screenToModel(e), true);
      } else {
        this.stepFinish();
      }
    }
  }, {
    key: "stepCreateCircle",
    value: function stepCreateCircle(center, tryToSnap) {
      this.viewer.historyManager.checkpoint();
      var needSnap = tryToSnap && this.viewer.snapped != null;
      var p = needSnap ? this.viewer.snapped : center;
      this.circle = new _shapes_circle__WEBPACK_IMPORTED_MODULE_3__["Circle"](new _shapes_point__WEBPACK_IMPORTED_MODULE_2__["EndPoint"](p.x, p.y));
      if (needSnap) this.viewer.parametricManager.linkObjects([this.circle.c, p]);
      this.pointPicked(this.circle.c.x, this.circle.c.y);
      this.sendHint('specify radius');
      this.viewer.activeLayer.add(this.circle);
      this.viewer.refresh();
    }
  }, {
    key: "stepFinish",
    value: function stepFinish() {
      this.solveRequest(false);
      this.sendMessage("radius: " + this.viewer.roundToPrecision(this.circle.r.get()));
      this.viewer.refresh();
      this.viewer.toolManager.releaseControl();
    }
  }, {
    key: "processCommand",
    value: function processCommand(command) {
      if (this.circle == null) {
        var result = _tool__WEBPACK_IMPORTED_MODULE_0__["Tool"].ParseVector(this.viewer.referencePoint, command);
        if (typeof result === 'string') return result;
        this.stepCreateCircle(result, false);
      } else {
        var _result = _tool__WEBPACK_IMPORTED_MODULE_0__["Tool"].ParseNumber(command);

        if (typeof _result === 'string') return _result;
        this.circle.r.set(_result);
        this.stepFinish();
      }
    }
  }]);

  return EditCircleTool;
}(_tool__WEBPACK_IMPORTED_MODULE_0__["Tool"]);

/***/ }),

/***/ "./web/app/sketcher/tools/dim.js":
/*!***************************************!*\
  !*** ./web/app/sketcher/tools/dim.js ***!
  \***************************************/
/*! exports provided: AddDimTool, AddFreeDimTool, AddHorizontalDimTool, AddVerticalDimTool, AddCircleDimTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddDimTool", function() { return AddDimTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddFreeDimTool", function() { return AddFreeDimTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddHorizontalDimTool", function() { return AddHorizontalDimTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddVerticalDimTool", function() { return AddVerticalDimTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddCircleDimTool", function() { return AddCircleDimTool; });
/* harmony import */ var _shapes_dim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shapes/dim */ "./web/app/sketcher/shapes/dim.js");
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
/* harmony import */ var _shapes_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shapes/point */ "./web/app/sketcher/shapes/point.js");
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tool */ "./web/app/sketcher/tools/tool.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





var AddDimTool =
/*#__PURE__*/
function (_Tool) {
  _inherits(AddDimTool, _Tool);

  function AddDimTool(name, viewer, layer, dimCreation) {
    var _this;

    _classCallCheck(this, AddDimTool);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AddDimTool).call(this, name, viewer));
    _this.layer = layer;
    _this.dim = null;
    _this._v = new math_vector__WEBPACK_IMPORTED_MODULE_1__["default"](0, 0, 0);
    _this.dimCreation = dimCreation;
    return _this;
  }

  _createClass(AddDimTool, [{
    key: "mousemove",
    value: function mousemove(e) {
      var p = this.viewer.screenToModel(e);
      this.viewer.snap(p.x, p.y, []);

      if (this.dim != null) {
        this.dim.b.x = p.x;
        this.dim.b.y = p.y;
      }

      this.viewer.refresh();
    }
  }, {
    key: "mouseup",
    value: function mouseup(e) {
      if (e.button > 0 && this.dim != null) {
        this.dim.flip = !this.dim.flip;
        this.viewer.refresh();
        return;
      }

      if (this.viewer.snapped == null) {
        return;
      }

      var p = this.viewer.snapped;
      this.viewer.cleanSnap();

      if (this.dim == null) {
        this.viewer.historyManager.checkpoint();
        this.dim = this.dimCreation(p, new _shapes_point__WEBPACK_IMPORTED_MODULE_2__["EndPoint"](p.x, p.y));
        this.layer.add(this.dim);
        this.viewer.refresh();
      } else {
        this.dim.b = p;
        this.viewer.toolManager.releaseControl();
        this.viewer.refresh();
      }
    }
  }]);

  return AddDimTool;
}(_tool__WEBPACK_IMPORTED_MODULE_3__["Tool"]);
var AddFreeDimTool =
/*#__PURE__*/
function (_AddDimTool) {
  _inherits(AddFreeDimTool, _AddDimTool);

  function AddFreeDimTool(viewer, layer) {
    _classCallCheck(this, AddFreeDimTool);

    return _possibleConstructorReturn(this, _getPrototypeOf(AddFreeDimTool).call(this, 'free dimension', viewer, layer, function (a, b) {
      return new _shapes_dim__WEBPACK_IMPORTED_MODULE_0__["Dimension"](a, b);
    }));
  }

  return AddFreeDimTool;
}(AddDimTool);
var AddHorizontalDimTool =
/*#__PURE__*/
function (_AddDimTool2) {
  _inherits(AddHorizontalDimTool, _AddDimTool2);

  function AddHorizontalDimTool(viewer, layer) {
    _classCallCheck(this, AddHorizontalDimTool);

    return _possibleConstructorReturn(this, _getPrototypeOf(AddHorizontalDimTool).call(this, 'horizontal dimension', viewer, layer, function (a, b) {
      return new _shapes_dim__WEBPACK_IMPORTED_MODULE_0__["HDimension"](a, b);
    }));
  }

  return AddHorizontalDimTool;
}(AddDimTool);
var AddVerticalDimTool =
/*#__PURE__*/
function (_AddDimTool3) {
  _inherits(AddVerticalDimTool, _AddDimTool3);

  function AddVerticalDimTool(viewer, layer) {
    _classCallCheck(this, AddVerticalDimTool);

    return _possibleConstructorReturn(this, _getPrototypeOf(AddVerticalDimTool).call(this, 'vertical dimension', viewer, layer, function (a, b) {
      return new _shapes_dim__WEBPACK_IMPORTED_MODULE_0__["VDimension"](a, b);
    }));
  }

  return AddVerticalDimTool;
}(AddDimTool);
var AddCircleDimTool =
/*#__PURE__*/
function (_Tool2) {
  _inherits(AddCircleDimTool, _Tool2);

  function AddCircleDimTool(viewer, layer) {
    var _this2;

    _classCallCheck(this, AddCircleDimTool);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AddCircleDimTool).call(this, 'arc/circle dimension', viewer));
    _this2.layer = layer;
    _this2.dim = new _shapes_dim__WEBPACK_IMPORTED_MODULE_0__["DiameterDimension"](null);

    _this2.viewer.add(_this2.dim, _this2.layer);

    return _this2;
  }

  _createClass(AddCircleDimTool, [{
    key: "mousemove",
    value: function mousemove(e) {
      var p = this.viewer.screenToModel(e);
      var objects = this.viewer.search(p.x, p.y, 20 / this.viewer.scale, true, false, []).filter(function (o) {
        return o._class === 'TCAD.TWO.Circle' || o._class === 'TCAD.TWO.Arc';
      });

      if (objects.length != 0) {
        this.dim.obj = objects[0];
      } else {
        this.dim.obj = null;
      }

      if (this.dim.obj != null) {
        this.dim.angle = Math.atan2(p.y - this.dim.obj.c.y, p.x - this.dim.obj.c.x);
      }

      this.viewer.refresh();
    }
  }, {
    key: "mouseup",
    value: function mouseup(e) {
      if (this.dim.obj !== null) {
        this.viewer.historyManager.checkpoint();
      } else {
        this.viewer.remove(this.dim);
      }

      this.viewer.toolManager.releaseControl();
    }
  }]);

  return AddCircleDimTool;
}(_tool__WEBPACK_IMPORTED_MODULE_3__["Tool"]);

/***/ }),

/***/ "./web/app/sketcher/tools/drag.js":
/*!****************************************!*\
  !*** ./web/app/sketcher/tools/drag.js ***!
  \****************************************/
/*! exports provided: DragTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DragTool", function() { return DragTool; });
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tool */ "./web/app/sketcher/tools/tool.js");
/* harmony import */ var _math_optim__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/optim */ "./web/app/math/optim.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var DragTool =
/*#__PURE__*/
function (_Tool) {
  _inherits(DragTool, _Tool);

  function DragTool(obj, viewer) {
    var _this;

    _classCallCheck(this, DragTool);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DragTool).call(this, 'drag', viewer));
    _this.obj = obj;
    _this._point = {
      x: 0,
      y: 0
    };
    _this.origin = {
      x: 0,
      y: 0
    };
    _this.solver = null;
    return _this;
  }

  _createClass(DragTool, [{
    key: "mousemove",
    value: function mousemove(e) {
      var x = this._point.x;
      var y = this._point.y;
      this.viewer.screenToModel2(e.offsetX, e.offsetY, this._point);
      var dx = this._point.x - x;
      var dy = this._point.y - y;

      for (var i = 0; i < this.lockedShifts.length; i += 2) {
        this.lockedValues[i] = this._point.x - this.lockedShifts[i];
        this.lockedValues[i + 1] = this._point.y - this.lockedShifts[i + 1];
      }

      this.solver.updateLock(this.lockedValues);

      if (!_tool__WEBPACK_IMPORTED_MODULE_0__["Tool"].dumbMode(e)) {
        this.solveRequest(true);
      } else {
        this.obj.translate(dx, dy);
      }

      this.viewer.refresh();
    }
  }, {
    key: "mousedown",
    value: function mousedown(e) {
      this.origin.x = e.offsetX;
      this.origin.y = e.offsetY;
      this.viewer.screenToModel2(e.offsetX, e.offsetY, this._point);
      this.prepareSolver([]);
    }
  }, {
    key: "mouseup",
    value: function mouseup(e) {
      this.solveRequest(false);
      this.viewer.refresh();
      this.viewer.toolManager.releaseControl();
      var traveled = _math_math__WEBPACK_IMPORTED_MODULE_2__["distance"](this.origin.x, this.origin.y, e.offsetX, e.offsetY);

      if (traveled >= 10) {
        this.viewer.historyManager.lightCheckpoint(10);
      } //this.animateSolution();

    }
  }, {
    key: "mousewheel",
    value: function mousewheel(e) {}
  }, {
    key: "solveRequest",
    value: function solveRequest(rough) {
      this.solver.solve(rough, 1);
      var paramsToUpdate = [];
      this.viewer.accept(function (obj) {
        if (obj.aux !== true) {
          if (obj.recoverIfNecessary()) {
            obj.collectParams(paramsToUpdate);
          }
        }

        return true;
      });

      if (paramsToUpdate.length != 0) {
        for (var i = 0; i < paramsToUpdate.length; i++) {
          this.solver.updateParameter(paramsToUpdate[i]);
        }

        this.solver.solve(rough, 1);
      }
    }
  }, {
    key: "getParamsToLock",
    value: function getParamsToLock() {
      var params = [];
      this.obj.accept(function (obj) {
        if (obj._class === 'TCAD.TWO.EndPoint' && !obj.isAuxOrLinkedTo()) {
          params.push(obj._x);
          params.push(obj._y);
        }

        return true;
      });
      return params;
    }
  }, {
    key: "prepareSolver",
    value: function prepareSolver(extraConstraints) {
      var locked = this.getParamsToLock();
      this.lockedShifts = [];
      this.lockedValues = [];

      for (var i = 0; i < locked.length; i += 2) {
        this.lockedShifts[i] = this._point.x - locked[i].get();
        this.lockedShifts[i + 1] = this._point.y - locked[i + 1].get();
      }

      this.solver = this.viewer.parametricManager.prepare(locked, extraConstraints); //this.enableRecording();
    }
  }, {
    key: "enableRecording",
    value: function enableRecording() {
      var solver = this.solver;
      DragTool.snapshots = [];

      _math_optim__WEBPACK_IMPORTED_MODULE_1__["optim"].DEBUG_HANDLER = function () {
        DragTool.snapshots.push([]);

        for (var i = 0; i < solver.solvers.length; i++) {
          var sys = solver.solvers[i].system;
          DragTool.snapshots[i].push(sys.params.map(function (p) {
            return p.get();
          }));
        }
      };
    }
  }, {
    key: "animateSolution",
    value: function animateSolution() {
      if (DragTool.snapshots.length === 0) return;
      var stepNum = 0;
      var scope = this;
      var then = Date.now();
      var speed = 500;

      function step() {
        var now = Date.now();
        var elapsed = now - then;

        if (elapsed > speed) {
          for (var i = 0; i < scope.solver.solvers.length; i++) {
            var sys = scope.solver.solvers[i].system;
            if (stepNum >= DragTool.snapshots[i].length) continue;
            var values = DragTool.snapshots[i][stepNum];

            for (var k = 0; k < values.length; k++) {
              sys.params[k]._backingParam.set(values[k]);
            }
          }

          stepNum++;
          then = now;
          scope.viewer.repaint();
        }

        if (DragTool.snapshots.length != 0 && stepNum < DragTool.snapshots[0].length) {
          window.requestAnimationFrame(step);
        }
      }

      window.requestAnimationFrame(step);
    }
  }]);

  return DragTool;
}(_tool__WEBPACK_IMPORTED_MODULE_0__["Tool"]);
DragTool.snapshots = [];

/***/ }),

/***/ "./web/app/sketcher/tools/edit-tools-map.js":
/*!**************************************************!*\
  !*** ./web/app/sketcher/tools/edit-tools-map.js ***!
  \**************************************************/
/*! exports provided: GetShapeEditTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetShapeEditTool", function() { return GetShapeEditTool; });
/* harmony import */ var _shapes_ellipse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shapes/ellipse */ "./web/app/sketcher/shapes/ellipse.js");
/* harmony import */ var _shapes_elliptical_arc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shapes/elliptical-arc */ "./web/app/sketcher/shapes/elliptical-arc.js");
/* harmony import */ var _shapes_circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shapes/circle */ "./web/app/sketcher/shapes/circle.js");
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./circle */ "./web/app/sketcher/tools/circle.js");
/* harmony import */ var _drag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drag */ "./web/app/sketcher/tools/drag.js");
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ellipse */ "./web/app/sketcher/tools/ellipse.js");






function GetShapeEditTool(viewer, obj, alternative) {
  if (obj instanceof _shapes_circle__WEBPACK_IMPORTED_MODULE_2__["Circle"] && !alternative) {
    var tool = new _circle__WEBPACK_IMPORTED_MODULE_3__["EditCircleTool"](viewer);
    tool.circle = obj;
    return tool;
  } else if (obj instanceof _shapes_ellipse__WEBPACK_IMPORTED_MODULE_0__["Ellipse"] && !alternative) {
    // even for an ell-arc we should act as it would be an ellipse to 
    // avoid stabilize constraints added and demoing B point on move
    // so second arg must be FALSE!
    var _tool = new _ellipse__WEBPACK_IMPORTED_MODULE_5__["EllipseTool"](viewer, false);

    _tool.ellipse = obj;
    _tool.state = _ellipse__WEBPACK_IMPORTED_MODULE_5__["STATE_RADIUS"];
    return _tool;
  } else {
    return new _drag__WEBPACK_IMPORTED_MODULE_4__["DragTool"](obj, viewer);
  }
}

/***/ }),

/***/ "./web/app/sketcher/tools/ellipse.js":
/*!*******************************************!*\
  !*** ./web/app/sketcher/tools/ellipse.js ***!
  \*******************************************/
/*! exports provided: STATE_POINT1, STATE_POINT2, STATE_RADIUS, EllipseTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATE_POINT1", function() { return STATE_POINT1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATE_POINT2", function() { return STATE_POINT2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATE_RADIUS", function() { return STATE_RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseTool", function() { return EllipseTool; });
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tool */ "./web/app/sketcher/tools/tool.js");
/* harmony import */ var _shapes_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shapes/point */ "./web/app/sketcher/shapes/point.js");
/* harmony import */ var _shapes_ellipse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shapes/ellipse */ "./web/app/sketcher/shapes/ellipse.js");
/* harmony import */ var _shapes_elliptical_arc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shapes/elliptical-arc */ "./web/app/sketcher/shapes/elliptical-arc.js");
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var STATE_POINT1 = 0;
var STATE_POINT2 = 1;
var STATE_RADIUS = 2;
var EllipseTool =
/*#__PURE__*/
function (_Tool) {
  _inherits(EllipseTool, _Tool);

  function EllipseTool(viewer, arc) {
    var _this;

    _classCallCheck(this, EllipseTool);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EllipseTool).call(this, arc ? 'ellipse' : 'elliptical arc', viewer));
    _this.arc = arc;
    _this.ellipse = null;
    _this.state = STATE_POINT1;
    return _this;
  }

  _createClass(EllipseTool, [{
    key: "restart",
    value: function restart() {
      this.ellipse = null;
      this.state = STATE_POINT1;
      this.sendHint('specify first major axis point');
    }
  }, {
    key: "cleanup",
    value: function cleanup(e) {
      this.viewer.cleanSnap();
    }
  }, {
    key: "point",
    value: function point(e) {
      return this.viewer.snapped ? this.viewer.snapped : this.viewer.screenToModel(e);
    }
  }, {
    key: "newEllipse",
    value: function newEllipse(p) {
      var ep = function ep() {
        return new _shapes_point__WEBPACK_IMPORTED_MODULE_1__["EndPoint"](p.x, p.y);
      };

      return this.arc ? new _shapes_elliptical_arc__WEBPACK_IMPORTED_MODULE_3__["EllipticalArc"](ep(), ep(), ep(), ep()) : new _shapes_ellipse__WEBPACK_IMPORTED_MODULE_2__["Ellipse"](ep(), ep());
    }
  }, {
    key: "demoBPoint",
    value: function demoBPoint() {
      var arc = this.ellipse;
      var ang = Math.atan2(arc.a.y - arc.centerY, arc.a.x - arc.centerX) + (2 * Math.PI - 0.3);
      ang %= 2 * Math.PI;
      var r = arc.radiusAtAngle(ang - arc.rotation);
      arc.b.x = arc.centerX + r * Math.cos(ang);
      arc.b.y = arc.centerY + r * Math.sin(ang);
    }
  }, {
    key: "mouseup",
    value: function mouseup(e) {
      switch (this.state) {
        case STATE_POINT1:
          {
            var p = this.point(e);
            this.ellipse = this.newEllipse(p);
            this.snapIfNeed(this.ellipse.ep1);
            this.viewer.activeLayer.add(this.ellipse);
            this.viewer.refresh();
            this.state = STATE_POINT2;
            this.sendHint('specify second major axis point');
            break;
          }

        case STATE_POINT2:
          {
            var _p = this.point(e);

            this.ellipse.ep2.setFromPoint(_p);
            this.snapIfNeed(this.ellipse.ep2);
            this.viewer.refresh();
            this.state = STATE_RADIUS;
            this.sendHint('specify minor axis radius');
            break;
          }

        case STATE_RADIUS:
          if (this.arc) {
            this.ellipse.stabilize(this.viewer);
          }

          this.viewer.toolManager.releaseControl();
      }
    }
  }, {
    key: "mousemove",
    value: function mousemove(e) {
      var p = this.viewer.screenToModel(e);

      switch (this.state) {
        case STATE_POINT1:
          this.viewer.snap(p.x, p.y, []);
          break;

        case STATE_POINT2:
          this.ellipse.ep2.setFromPoint(this.viewer.screenToModel(e));
          this.ellipse.r.value = this.ellipse.radiusX * 0.5;
          this.viewer.snap(p.x, p.y, this.ellipse.children);

          if (this.arc) {
            this.ellipse.a.setFromPoint(this.ellipse.ep2);
            this.demoBPoint();
          }

          break;

        case STATE_RADIUS:
          var polarPoint = this.ellipse.toEllipseCoordinateSystem(p);
          var minorRadius = _shapes_ellipse__WEBPACK_IMPORTED_MODULE_2__["Ellipse"].findMinorRadius(this.ellipse.radiusX, polarPoint.radius, polarPoint.angle);

          if (isNaN(minorRadius)) {
            var projAxis = new math_vector__WEBPACK_IMPORTED_MODULE_4__["default"](-(this.ellipse.ep2.y - this.ellipse.ep1.y), this.ellipse.ep2.x - this.ellipse.ep1.x);

            projAxis._normalize();

            var v = new math_vector__WEBPACK_IMPORTED_MODULE_4__["default"](this.ellipse.ep2.x - p.x, this.ellipse.ep2.y - p.y);
            minorRadius = Math.abs(projAxis.dot(v));
          }

          this.ellipse.r.set(minorRadius);

          if (!_tool__WEBPACK_IMPORTED_MODULE_0__["Tool"].dumbMode(e)) {
            this.solveRequest(true);
          }

          if (this.arc) {
            this.demoBPoint();
          }

          break;
      }

      this.viewer.refresh();
    }
  }, {
    key: "solveRequest",
    value: function solveRequest(rough) {
      this.solver = this.viewer.parametricManager.prepare([this.ellipse.r]);
      this.solver.solve(rough, 1);
    }
  }]);

  return EllipseTool;
}(_tool__WEBPACK_IMPORTED_MODULE_0__["Tool"]);

/***/ }),

/***/ "./web/app/sketcher/tools/fillet.js":
/*!******************************************!*\
  !*** ./web/app/sketcher/tools/fillet.js ***!
  \******************************************/
/*! exports provided: FilletTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FilletTool", function() { return FilletTool; });
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles */ "./web/app/sketcher/styles.js");
/* harmony import */ var _fetchers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../fetchers */ "./web/app/sketcher/fetchers.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
/* harmony import */ var _shapes_point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shapes/point */ "./web/app/sketcher/shapes/point.js");
/* harmony import */ var _shapes_arc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shapes/arc */ "./web/app/sketcher/shapes/arc.js");
/* harmony import */ var _parametric__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../parametric */ "./web/app/sketcher/parametric.js");
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tool */ "./web/app/sketcher/tools/tool.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }









var FilletTool =
/*#__PURE__*/
function (_Tool) {
  _inherits(FilletTool, _Tool);

  function FilletTool(viewer) {
    var _this;

    _classCallCheck(this, FilletTool);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(FilletTool).call(this, 'fillet', viewer));
    _this.viewer = viewer;
    return _this;
  }

  _createClass(FilletTool, [{
    key: "restart",
    value: function restart() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.viewer.selected[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var master = _step.value;

          if (master instanceof _shapes_point__WEBPACK_IMPORTED_MODULE_4__["EndPoint"]) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = master.linked[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var slave = _step2.value;

                if (slave instanceof _shapes_point__WEBPACK_IMPORTED_MODULE_4__["EndPoint"]) {
                  if (this.breakLinkAndMakeFillet(master, slave)) {
                    this.viewer.toolManager.releaseControl();
                  }
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "makeFillet",
    value: function makeFillet(point1, point2) {
      function shrink(point1) {
        var a, b;

        if (point1.id === point1.parent.a.id) {
          a = point1.parent.b;
          b = point1.parent.a;
        } else {
          a = point1.parent.a;
          b = point1.parent.b;
        }

        var d = _math_math__WEBPACK_IMPORTED_MODULE_3__["distanceAB"](a, b);
        var k = 4 / 5;
        b.x = a.x + (b.x - a.x) * k;
        b.y = a.y + (b.y - a.y) * k;
        return new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](a.x - b.x, a.y - b.y, 0);
      }

      var v1 = shrink(point1);
      var v2 = shrink(point2);

      if (v1.cross(v2).z > 0) {
        var _ = point1;
        point1 = point2;
        point2 = _;
      }

      var vec = new math_vector__WEBPACK_IMPORTED_MODULE_0__["default"]();
      vec.setV(point2);

      vec._minus(point1);

      vec._multiply(0.5);

      vec._plus(point1);

      var arc = new _shapes_arc__WEBPACK_IMPORTED_MODULE_5__["Arc"](new _shapes_point__WEBPACK_IMPORTED_MODULE_4__["EndPoint"](point1.x, point1.y), new _shapes_point__WEBPACK_IMPORTED_MODULE_4__["EndPoint"](point2.x, point2.y), new _shapes_point__WEBPACK_IMPORTED_MODULE_4__["EndPoint"](vec.x, vec.y));
      point1.parent.layer.add(arc);
      var pm = this.viewer.parametricManager;
      arc.stabilize(this.viewer);

      pm._add(new _parametric__WEBPACK_IMPORTED_MODULE_6__["Constraints"].Fillet(point1, point2, arc));

      this.viewer.validators.push(function () {
        function validOn(p, left) {
          var op = p.parent.opposite(p);
          var opV = op.toVector();

          var dir = p.toVector()._minus(opV)._normalize();

          var centerDir = arc.c.toVector()._minus(opV)._normalize();

          var z = centerDir.cross(dir).z;
          return left ? z < 0.1 : z > -0.1;
        }

        return validOn(point1, true) && validOn(point2, false);
      }); //function otherEnd(point) {
      //  if (point.parent.a.id === point.id) {
      //    return point.parent.b;
      //  } else {
      //    return point.parent.a;
      //  }
      //}
      //
      //pm._add(new Constraints.LockConvex(arc.c, arc.a, otherEnd(point1)));
      //pm._add(new Constraints.LockConvex(otherEnd(point2), arc.b, arc.c));

      var solver = pm.solve(); //  var solver = pm.solve([point1._x, point1._y, point2._x, point2._y]);

      pm.notify();
      this.viewer.refresh();
    }
  }, {
    key: "mouseup",
    value: function mouseup(e) {
      var candi = this.getCandidate(e);
      if (candi == null) return;
      var point1 = candi[0];
      var point2 = candi[1];
      this.breakLinkAndMakeFillet(point1, point2);
    }
  }, {
    key: "breakLinkAndMakeFillet",
    value: function breakLinkAndMakeFillet(point1, point2) {
      var pm = this.viewer.parametricManager;
      var coi = pm.findCoincidentConstraint(point1, point2);

      if (coi != null) {
        pm.remove(coi);
        this.makeFillet(point1, point2);
        this.viewer.deselectAll();
        return true;
      }

      return false;
    }
  }, {
    key: "getCandidate",
    value: function getCandidate(e) {
      var preferSketchLayer = function preferSketchLayer(a, b) {
        return a.effectiveLayer === b.effectiveLayer ? 0 : a.effectiveLayer.name === 'sketch' ? -1 : 1;
      };

      var picked = this.viewer.pick(e);

      if (picked.length > 0) {
        var res = _fetchers__WEBPACK_IMPORTED_MODULE_2__["sketchObjects"](picked, true, ['TCAD.TWO.EndPoint']);
        if (res == null) return null;
        var point1 = res.sort(preferSketchLayer)[0];
        if (!FilletTool.isLine(point1.parent)) return;

        var linked = _toConsumableArray(point1.linked).sort(preferSketchLayer);

        for (var i = 0; i < linked.length; i++) {
          var point2 = linked[i];

          if (FilletTool.isLine(point2.parent)) {
            return [point1, point2];
          }
        }
      }

      return null;
    }
  }, {
    key: "mousemove",
    value: function mousemove(e) {
      var needRefresh = false;

      if (this.viewer.selected.length != 0) {
        this.viewer.deselectAll();
        needRefresh = true;
      }

      var candi = this.getCandidate(e);

      if (candi != null) {
        this.viewer.mark(candi[0], _styles__WEBPACK_IMPORTED_MODULE_1__["Styles"].SNAP);
        needRefresh = true;
      }

      if (needRefresh) {
        this.viewer.refresh();
      }
    }
  }], [{
    key: "isLine",
    value: function isLine(line) {
      return line != null && line._class === 'TCAD.TWO.Segment';
    }
  }]);

  return FilletTool;
}(_tool__WEBPACK_IMPORTED_MODULE_7__["Tool"]);

/***/ }),

/***/ "./web/app/sketcher/tools/loop-pick.js":
/*!*********************************************!*\
  !*** ./web/app/sketcher/tools/loop-pick.js ***!
  \*********************************************/
/*! exports provided: LoopPickTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopPickTool", function() { return LoopPickTool; });
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tool */ "./web/app/sketcher/tools/tool.js");
/* harmony import */ var _math_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/graph */ "./web/app/math/graph.js");
/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles */ "./web/app/sketcher/styles.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var LoopPickTool =
/*#__PURE__*/
function (_Tool) {
  _inherits(LoopPickTool, _Tool);

  function LoopPickTool(name, viewer) {
    var _this;

    _classCallCheck(this, LoopPickTool);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(LoopPickTool).call(this, name, viewer));
    _this.loops = new Map();
    _this.marked = new Set();
    _this.pickedLoop = null;
    _this.pointToObject = new Map();
    return _this;
  }

  _createClass(LoopPickTool, [{
    key: "restart",
    value: function restart() {
      this.sendHint('pick a polygon');
      this.reindexLoops();
      this.marked.clear();
      this.pointToObject.clear();
      this.pickedLoop = null;
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      this.clearMarked();
    }
  }, {
    key: "clearMarked",
    value: function clearMarked() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.marked[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var obj = _step.value;
          obj.marked = null;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.marked.clear();
    }
  }, {
    key: "mark",
    value: function mark(obj) {
      if (!this.marked.has(obj)) {
        obj.marked = _styles__WEBPACK_IMPORTED_MODULE_2__["Styles"].SNAP;
        this.marked.add(obj);
      }
    }
  }, {
    key: "otherEnd",
    value: function otherEnd(point) {
      if (point.parent.a.id == point.id) {
        return point.parent.b;
      } else {
        return point.parent.a;
      }
    }
  }, {
    key: "reindexLoops",
    value: function reindexLoops() {
      var _this2 = this;

      this.loops.clear();
      var points = [];
      this.viewer.accept(function (obj) {
        if (obj._class == 'TCAD.TWO.EndPoint' && obj.parent && obj.parent.a && obj.parent.b && (obj.parent.a == obj || obj.parent.b == obj)) {
          points.push(obj);
        }

        return true;
      });
      var graph = {
        connections: function connections(p) {
          var conns = p.linked.slice();
          conns.push(_this2.otherEnd(p));
          return conns;
        },
        at: function at(index) {
          return points[index];
        },
        size: function size() {
          return points.length;
        }
      };
      var loopPoints = _math_graph__WEBPACK_IMPORTED_MODULE_1__["Graph"].findAllLoops(graph, function (p) {
        return p.id;
      }, function (a, b) {
        return a.id == b.id;
      });
      var loops = loopPoints.map(function (l) {
        return _this2.cleanLoop(l);
      });
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = loops[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var loop = _step2.value;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = loop.points[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var point = _step3.value;
              this.loops.set(point, loop);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "cleanLoop",
    value: function cleanLoop(loop) {
      var points = [];
      var edges = [];

      for (var i = 0; i < loop.length; i++) {
        var a = loop[i];
        var b = loop[(i + 1) % loop.length];

        if (a.parent == b.parent) {
          points.push(a);
          edges.push(b.parent);
        }
      }

      return {
        points: points,
        edges: edges
      };
    }
  }, {
    key: "mousemove",
    value: function mousemove(e) {
      this.clearMarked();
      this.pickedLoop = null;
      var p = this.viewer.screenToModel(e);
      this.pickedLoop = this.pickLoop(p);

      if (this.pickedLoop != null) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = this.pickedLoop.edges[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var obj = _step4.value;
            this.mark(obj);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }

      this.viewer.refresh();
    }
  }, {
    key: "pickLoop",
    value: function pickLoop(p) {
      var pickResult = this.viewer.search(p.x, p.y, 20 / this.viewer.scale, true, false, []);
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = pickResult[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var obj = _step5.value;

          for (var _i = 0, _arr = [obj.a, obj.b]; _i < _arr.length; _i++) {
            var point = _arr[_i];
            var loop = this.loops.get(point);

            if (loop) {
              return loop;
            }
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return null;
    }
  }, {
    key: "mousedown",
    value: function mousedown(e) {
      if (this.pickedLoop == null) {
        this.viewer.toolManager.releaseControl();
        this.viewer.toolManager.tool.mousedown(e);
      } else {
        this.onMousedown(e);
      }
    }
  }, {
    key: "onMousedown",
    value: function onMousedown(e) {}
  }]);

  return LoopPickTool;
}(_tool__WEBPACK_IMPORTED_MODULE_0__["Tool"]);

function getEdgeFor(a, b) {
  if (isEdgeFor(a.parent, a, b)) {
    return a.parent;
  } else if (isEdgeFor(b.parent, a, b)) {
    return b.parent;
  } else {
    return null;
  }
}

function isEdgeFor(obj, a, b) {
  return obj.a.id == a.id && obj.b.id == b.id || obj.a.id == b.id && obj.b.id == b.id;
}

/***/ }),

/***/ "./web/app/sketcher/tools/manager.js":
/*!*******************************************!*\
  !*** ./web/app/sketcher/tools/manager.js ***!
  \*******************************************/
/*! exports provided: ToolManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolManager", function() { return ToolManager; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ToolManager =
/*#__PURE__*/
function () {
  function ToolManager(viewer, defaultTool) {
    var _this = this;

    _classCallCheck(this, ToolManager);

    this.defaultTool = defaultTool;
    this.tool = defaultTool;
    this.viewer = viewer;
    this.disposers = [];
    var canvas = viewer.canvas;
    canvas.addEventListener('mousemove', function (e) {
      e.preventDefault(); //e.stopPropagation(); // allow propagation for move in sake of dynamic layout 

      _this.tool.mousemove(e);
    }, false);
    canvas.addEventListener('mousedown', function (e) {
      e.preventDefault();
      e.stopPropagation();

      _this.tool.mousedown(e);
    }, false);
    canvas.addEventListener('mouseup', function (e) {
      e.preventDefault();
      e.stopPropagation();

      _this.tool.mouseup(e);
    }, false);
    window.addEventListener('touchstart', function (e) {
      e.preventDefault();
      e.stopPropagation();
      console.log(111);
    }, false);
    canvas.addEventListener('wheel', function (e) {
      e.preventDefault();
      e.stopPropagation();
      var tool = _this.tool;

      if (tool.mousewheel === undefined) {
        tool = _this.defaultTool;
      }

      if (tool.mousewheel !== undefined) {
        tool.mousewheel(e);
      }
    }, false);
    canvas.addEventListener('dblclick', function (e) {
      e.preventDefault();
      e.stopPropagation();

      _this.tool.dblclick(e);
    }, false);
    this.addEventListener(window, "keydown", function (e) {
      _this.tool.keydown(e);

      if (e.keyCode === 27) {
        _this.releaseControl();
      } else if (e.keyCode === 46 || e.keyCode === 8) {
        var selection = viewer.selected.slice();
        viewer.deselectAll();
        viewer.removeAll(selection);
        viewer.refresh();
      }
    }, false);
    this.addEventListener(window, "keypress", function (e) {
      _this.tool.keydown(e);
    }, false);
    this.addEventListener(window, "keyup", function (e) {
      _this.tool.keydown(e);
    }, false);
  }

  _createClass(ToolManager, [{
    key: "setDefaultTool",
    value: function setDefaultTool(defaultTool) {
      this.defaultTool = defaultTool;
      this.tool = defaultTool;
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(subject, event, fn, useCapture) {
      subject.addEventListener(event, fn, useCapture);
      this.disposers.push(function () {
        return subject.removeEventListener(event, fn, useCapture);
      });
    }
  }, {
    key: "takeControl",
    value: function takeControl(tool) {
      this.tool.cleanup();
      this.switchTool(tool);
      this.tool.restart();
    }
  }, {
    key: "switchTool",
    value: function switchTool(tool) {
      this.tool = tool;
      this.viewer.bus.dispatch("tool-change");
    }
  }, {
    key: "releaseControl",
    value: function releaseControl() {
      this.takeControl(this.defaultTool);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.disposers.forEach(function (d) {
        return d();
      });
    }
  }]);

  return ToolManager;
}();

/***/ }),

/***/ "./web/app/sketcher/tools/offset.js":
/*!******************************************!*\
  !*** ./web/app/sketcher/tools/offset.js ***!
  \******************************************/
/*! exports provided: OffsetTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OffsetTool", function() { return OffsetTool; });
/* harmony import */ var _loop_pick__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loop-pick */ "./web/app/sketcher/tools/loop-pick.js");
/* harmony import */ var _parametric__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parametric */ "./web/app/sketcher/parametric.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/utils */ "./web/app/utils/utils.js");
/* harmony import */ var _shapes_point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shapes/point */ "./web/app/sketcher/shapes/point.js");
/* harmony import */ var _shapes_arc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shapes/arc */ "./web/app/sketcher/shapes/arc.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }








var OffsetTool =
/*#__PURE__*/
function (_LoopPickTool) {
  _inherits(OffsetTool, _LoopPickTool);

  function OffsetTool(viewer) {
    _classCallCheck(this, OffsetTool);

    return _possibleConstructorReturn(this, _getPrototypeOf(OffsetTool).call(this, 'offset', viewer));
  }

  _createClass(OffsetTool, [{
    key: "onMousedown",
    value: function onMousedown(e) {
      var loopPoints = this.pickedLoop.points;
      var loopEdges = this.pickedLoop.edges;
      var length = loopEdges.length;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = loopEdges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var obj = _step.value;

          if (!SUPPORTED_OBJECTS.has(obj._class)) {
            alert(obj._class + " isn't supported for offsets");
            return;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var delta = parseInt(prompt('offset distance?', 100));

      if (isNaN(delta)) {
        return;
      }

      var edges = loopEdges.map(function (e) {
        return e.copy();
      });
      var lowestPoint = findLowestPoint(loopPoints);
      var low = loopPoints.indexOf(lowestPoint);

      function pos(i) {
        return (i + low) % length;
      }

      var mainInverse = !this.twoConnectedArcs() && _math_math__WEBPACK_IMPORTED_MODULE_2__["isCCW"]([loopPoints[pos(0)], loopPoints[pos(1)], loopPoints[pos(length - 1)]]);
      var pm = this.viewer.parametricManager;
      var offsetConstant = createOffsetConstant(pm, delta);

      for (var i = 0; i < length; ++i) {
        var edge = edges[i];
        var origEdge = loopEdges[i];
        var edgeInverse = loopPoints[i] != origEdge.a;
        var inverse = mainInverse != edgeInverse;
        this.viewer.activeLayer.add(edge);

        if (edge._class == 'TCAD.TWO.Segment') {
          pm._add(new _parametric__WEBPACK_IMPORTED_MODULE_1__["Constraints"].Parallel(origEdge, edge));

          pm._add(new _parametric__WEBPACK_IMPORTED_MODULE_1__["Constraints"].P2LDistanceSigned(origEdge.a, inverse ? edge.b : edge.a, inverse ? edge.a : edge.b, offsetConstant));
        } else if (edge._class == 'TCAD.TWO.Arc') {
          edge.stabilize(this.viewer);

          pm._linkObjects([edge.c, origEdge.c]);

          pm._add(new _parametric__WEBPACK_IMPORTED_MODULE_1__["Constraints"].RadiusOffset(inverse ? origEdge : edge, inverse ? edge : origEdge, offsetConstant));
        }
      }

      for (var _i = 0; _i < edges.length; _i++) {
        var next = (_i + 1) % edges.length;

        if (loopEdges[_i].a.linked.indexOf(loopEdges[next].a) != -1) {
          pm._linkObjects([edges[_i].a, edges[next].a]);
        } else if (loopEdges[_i].a.linked.indexOf(loopEdges[next].b) != -1) {
          pm._linkObjects([edges[_i].a, edges[next].b]);
        } else if (loopEdges[_i].b.linked.indexOf(loopEdges[next].a) != -1) {
          pm._linkObjects([edges[_i].b, edges[next].a]);
        } else if (loopEdges[_i].b.linked.indexOf(loopEdges[next].b) != -1) {
          pm._linkObjects([edges[_i].b, edges[next].b]);
        }
      }

      pm.solve(undefined, undefined, loopEdges);
      pm.refresh();
      this.viewer.toolManager.releaseControl();
    }
  }, {
    key: "twoConnectedArcs",
    value: function twoConnectedArcs() {
      function isArc(edge) {
        return edge._class == 'TCAD.TWO.Arc';
      }

      var edges = this.pickedLoop.edges;
      return edges.length == 2 && isArc(edges[0]) && isArc(edges[1]);
    }
  }]);

  return OffsetTool;
}(_loop_pick__WEBPACK_IMPORTED_MODULE_0__["LoopPickTool"]);

function segmentToVector(segment) {
  return new math_vector__WEBPACK_IMPORTED_MODULE_3__["default"](segment.b.x - segment.a.x, segment.b.y - segment.a.y);
}

var SUPPORTED_OBJECTS = new Set();
SUPPORTED_OBJECTS.add('TCAD.TWO.Segment');
SUPPORTED_OBJECTS.add('TCAD.TWO.Arc');

function SimpleEdge(a, b) {
  this.a = a;
  this.b = b;

  this.reverse = function () {
    return new SimpleEdge(b, a);
  };
}

function findLowestPoint(poly) {
  var hero = {
    x: Number.MAX_VALUE,
    y: Number.MAX_VALUE
  };
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = poly[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var point = _step2.value;

      if (point.y < hero.y) {
        hero = point;
      } else if (hero.y == hero.y) {
        // TODO: revisit and fix bug
        if (point.x < hero.x) {
          hero = point;
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return hero;
}

function createOffsetConstant(pm, value) {
  var constant;
  var i = 0;

  do {
    constant = 'OFFSET' + i++;
  } while (pm.constantTable[constant]);

  pm.defineNewConstant(constant, value);
  return constant;
}

/***/ }),

/***/ "./web/app/sketcher/tools/origin.js":
/*!******************************************!*\
  !*** ./web/app/sketcher/tools/origin.js ***!
  \******************************************/
/*! exports provided: ReferencePointTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReferencePointTool", function() { return ReferencePointTool; });
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tool */ "./web/app/sketcher/tools/tool.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


var ReferencePointTool =
/*#__PURE__*/
function (_Tool) {
  _inherits(ReferencePointTool, _Tool);

  function ReferencePointTool(viewer) {
    _classCallCheck(this, ReferencePointTool);

    return _possibleConstructorReturn(this, _getPrototypeOf(ReferencePointTool).call(this, 'origin', viewer));
  }

  _createClass(ReferencePointTool, [{
    key: "restart",
    value: function restart() {
      this.sendSpecifyPointHint();
    }
  }, {
    key: "cleanup",
    value: function cleanup(e) {
      this.viewer.cleanSnap();
    }
  }, {
    key: "mousemove",
    value: function mousemove(e) {
      var p = this.viewer.screenToModel(e);
      this.viewer.snap(p.x, p.y, []);
      this.viewer.refresh();
    }
  }, {
    key: "mousedown",
    value: function mousedown(e) {
      var needSnap = this.viewer.snapped != null;
      var p = needSnap ? this.viewer.snapped : this.viewer.screenToModel(e);
      this.viewer.referencePoint.x = p.x;
      this.viewer.referencePoint.y = p.y;
      this.pointPicked(p.x, p.y);
      this.viewer.refresh();
      this.viewer.toolManager.releaseControl();
    }
  }, {
    key: "processCommand",
    value: function processCommand(command) {
      var referencePoint = this.viewer.referencePoint;
      var result = _tool__WEBPACK_IMPORTED_MODULE_0__["Tool"].ParseVector(referencePoint, command);

      if (typeof result === 'string') {
        return result;
      }

      referencePoint.x += result.x;
      referencePoint.y += result.y;
      this.viewer.refresh();
      this.viewer.toolManager.releaseControl();
    }
  }]);

  return ReferencePointTool;
}(_tool__WEBPACK_IMPORTED_MODULE_0__["Tool"]);

/***/ }),

/***/ "./web/app/sketcher/tools/pan.js":
/*!***************************************!*\
  !*** ./web/app/sketcher/tools/pan.js ***!
  \***************************************/
/*! exports provided: BasePanTool, PanTool, DelegatingPanTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasePanTool", function() { return BasePanTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PanTool", function() { return PanTool; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DelegatingPanTool", function() { return DelegatingPanTool; });
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tool */ "./web/app/sketcher/tools/tool.js");
/* harmony import */ var _edit_tools_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./edit-tools-map */ "./web/app/sketcher/tools/edit-tools-map.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var BasePanTool =
/*#__PURE__*/
function (_Tool) {
  _inherits(BasePanTool, _Tool);

  function BasePanTool(viewer) {
    _classCallCheck(this, BasePanTool);

    return _possibleConstructorReturn(this, _getPrototypeOf(BasePanTool).call(this, 'pan', viewer));
  }

  _createClass(BasePanTool, [{
    key: "mousedown",
    value: function mousedown(e) {
      if (e.button === 0) {
        var picked = this.viewer.pick(e);
        var i;

        if (picked.length > 0) {
          var toSelect;

          if (e.shiftKey) {
            toSelect = picked[0];
            var ids = this.viewer.selected.map(function (s) {
              return s.id;
            });

            for (i = 0; i < picked.length; i++) {
              if (ids.indexOf(picked[i].id) !== -1) {
                this.viewer.deselect(picked[i]);
              } else {
                toSelect = picked[i];
              }
            }

            this.viewer.select([toSelect], false);
            this.deselectOnUp = false;
          } else {
            toSelect = picked[0];

            if (this.viewer.selected.length === 1) {
              for (i = 0; i < picked.length - 1; i++) {
                if (picked[i].id === this.viewer.selected[0].id) {
                  toSelect = picked[i + 1];
                  break;
                }
              }
            }

            this.viewer.select([toSelect], true);

            if (!toSelect.isAuxOrLinkedTo()) {
              var tool = Object(_edit_tools_map__WEBPACK_IMPORTED_MODULE_1__["GetShapeEditTool"])(this.viewer, toSelect, e.altKey);
              tool.mousedown(e);
              this.viewer.toolManager.switchTool(tool);
            }
          }

          this.viewer.refresh();
          return;
        }
      }

      this.startDragging(e);
    }
  }, {
    key: "startDragging",
    value: function startDragging(e) {}
  }]);

  return BasePanTool;
}(_tool__WEBPACK_IMPORTED_MODULE_0__["Tool"]);
var PanTool =
/*#__PURE__*/
function (_BasePanTool) {
  _inherits(PanTool, _BasePanTool);

  function PanTool(viewer) {
    var _this;

    _classCallCheck(this, PanTool);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PanTool).call(this, viewer));
    _this.dragging = false;
    _this.x = 0.0;
    _this.y = 0.0;
    return _this;
  }

  _createClass(PanTool, [{
    key: "mousemove",
    value: function mousemove(e) {
      if (!this.dragging) {
        return;
      }

      var dx = e.pageX - this.x;
      var dy = e.pageY - this.y;
      dy *= -1;
      this.viewer.translate.x += dx * this.viewer.retinaPxielRatio;
      this.viewer.translate.y += dy * this.viewer.retinaPxielRatio;
      this.x = e.pageX;
      this.y = e.pageY;
      this.deselectOnUp = false;
      this.viewer.refresh();
    }
  }, {
    key: "startDragging",
    value: function startDragging(e) {
      _get(_getPrototypeOf(PanTool.prototype), "startDragging", this).call(this, e);

      this.dragging = true;
      this.deselectOnUp = true;
      this.x = e.pageX;
      this.y = e.pageY;
    }
  }, {
    key: "mouseup",
    value: function mouseup(e) {
      this.dragging = false;

      if (this.deselectOnUp) {
        this.viewer.deselectAll();
        this.viewer.refresh();
      }

      this.deselectOnUp = false;
    }
  }, {
    key: "mousewheel",
    value: function mousewheel(e) {
      var delta = 0;

      if (e.wheelDelta) {
        // WebKit / Opera / Explorer 9
        delta = e.wheelDelta;
      } else if (e.deltaY) {
        // Firefox
        delta = -e.deltaY;
      }

      var before = this.viewer.screenToModel(e);
      var step = 0.05;
      delta = delta < 0 ? 1 - step : 1 + step;
      this.viewer.scale *= delta;
      var after = this.viewer.screenToModel(e);
      var dx = after.x - before.x;
      var dy = after.y - before.y;
      this.viewer.translate.x += dx * this.viewer.scale;
      this.viewer.translate.y += dy * this.viewer.scale;
      this.viewer.refresh();
    }
  }]);

  return PanTool;
}(BasePanTool);
var DelegatingPanTool =
/*#__PURE__*/
function (_BasePanTool2) {
  _inherits(DelegatingPanTool, _BasePanTool2);

  function DelegatingPanTool(viewer, delegate) {
    var _this2;

    _classCallCheck(this, DelegatingPanTool);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(DelegatingPanTool).call(this, viewer));
    _this2.delegate = delegate;
    return _this2;
  } // mousemove(e) {
  //   this.delegate.dispatchEvent(cloneEvent(e));
  // };


  _createClass(DelegatingPanTool, [{
    key: "startDragging",
    value: function startDragging(e) {
      this.delegate.dispatchEvent(cloneEvent(e));
    }
  }, {
    key: "mouseup",
    value: function mouseup(e) {
      this.delegate.dispatchEvent(cloneEvent(e));
    }
  }, {
    key: "mousewheel",
    value: function mousewheel(e) {
      this.delegate.dispatchEvent(cloneEvent(e));
    }
  }]);

  return DelegatingPanTool;
}(BasePanTool);

function cloneEvent(event) {
  return new event.constructor(event.type, event);
}

/***/ }),

/***/ "./web/app/sketcher/tools/point.js":
/*!*****************************************!*\
  !*** ./web/app/sketcher/tools/point.js ***!
  \*****************************************/
/*! exports provided: AddPointTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddPointTool", function() { return AddPointTool; });
/* harmony import */ var _shapes_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shapes/point */ "./web/app/sketcher/shapes/point.js");
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tool */ "./web/app/sketcher/tools/tool.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var AddPointTool =
/*#__PURE__*/
function (_Tool) {
  _inherits(AddPointTool, _Tool);

  function AddPointTool(viewer) {
    _classCallCheck(this, AddPointTool);

    return _possibleConstructorReturn(this, _getPrototypeOf(AddPointTool).call(this, 'point', viewer));
  }

  _createClass(AddPointTool, [{
    key: "restart",
    value: function restart() {
      this.sendSpecifyPointHint();
    }
  }, {
    key: "mouseup",
    value: function mouseup(e) {
      var input = this.viewer.screenToModel(e);
      this.processPointInput(input);
    }
  }, {
    key: "processCommand",
    value: function processCommand(command) {
      var result = _tool__WEBPACK_IMPORTED_MODULE_1__["Tool"].ParseVector(this.viewer.referencePoint, command);

      if (typeof result === 'string') {
        return result;
      }

      this.processPointInput(result);
    }
  }, {
    key: "processPointInput",
    value: function processPointInput(input) {
      this.viewer.historyManager.checkpoint();
      var p = new _shapes_point__WEBPACK_IMPORTED_MODULE_0__["EndPoint"](input.x, input.y);
      var layer = this.viewer.activeLayer;
      layer.add(p);
      this.pointPicked(input.x, input.y);
      this.viewer.refresh();
      this.restart();
    }
  }]);

  return AddPointTool;
}(_tool__WEBPACK_IMPORTED_MODULE_1__["Tool"]);

/***/ }),

/***/ "./web/app/sketcher/tools/rectangle.js":
/*!*********************************************!*\
  !*** ./web/app/sketcher/tools/rectangle.js ***!
  \*********************************************/
/*! exports provided: RectangleTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectangleTool", function() { return RectangleTool; });
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tool */ "./web/app/sketcher/tools/tool.js");
/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/math */ "./web/app/math/math.js");
/* harmony import */ var _shapes_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shapes/point */ "./web/app/sketcher/shapes/point.js");
/* harmony import */ var _shapes_segment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shapes/segment */ "./web/app/sketcher/shapes/segment.js");
/* harmony import */ var _parametric__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parametric */ "./web/app/sketcher/parametric.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var RectangleTool =
/*#__PURE__*/
function (_Tool) {
  _inherits(RectangleTool, _Tool);

  function RectangleTool(viewer) {
    var _this;

    _classCallCheck(this, RectangleTool);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RectangleTool).call(this, 'rectangle', viewer));
    _this.rectangle = null;
    _this.firstPointSnap = null;
    _this.snapExclude = [];
    return _this;
  }

  _createClass(RectangleTool, [{
    key: "restart",
    value: function restart() {
      this.sendMessage('specify first point');
    }
  }, {
    key: "cleanup",
    value: function cleanup(e) {
      this.viewer.cleanSnap();
    }
  }, {
    key: "mousemove",
    value: function mousemove(e) {
      var p = this.viewer.screenToModel(e);

      if (this.rectangle != null) {
        this.alignSegments(p);
        this.viewer.snap(p.x, p.y, this.snapExclude);
      } else {
        this.viewer.snap(p.x, p.y, []);
      }

      this.viewer.refresh();
    }
  }, {
    key: "mouseup",
    value: function mouseup(e) {
      if (this.rectangle == null) {
        var p;

        if (this.viewer.snapped != null) {
          this.firstPointSnap = this.viewer.snapped;
          p = this.firstPointSnap;
          this.viewer.cleanSnap();
        } else {
          p = this.viewer.screenToModel(e);
        }

        this.createRectangle(p);
      } else {
        var _p = this.viewer.snapped;

        if (this.viewer.snapped != null) {
          _p = this.viewer.snapped;
        } else {
          _p = this.viewer.screenToModel(e);
        }

        this.alignSegments(_p);

        if (this.viewer.snapped != null) {
          this.viewer.parametricManager.linkObjects([this.rectangle[2].a, this.viewer.snapped]);
        }

        if (this.firstPointSnap != null) {
          this.viewer.parametricManager.linkObjects([this.rectangle[0].a, this.firstPointSnap]);
        }

        this.viewer.cleanSnap();
        this.stepFinish(_p);
      }
    }
  }, {
    key: "createRectangle",
    value: function createRectangle(v) {
      var p = new _shapes_point__WEBPACK_IMPORTED_MODULE_2__["EndPoint"](v.x, v.y); //from top, clockwise

      this.rectangle = [new _shapes_segment__WEBPACK_IMPORTED_MODULE_3__["Segment"](p, p.copy()), new _shapes_segment__WEBPACK_IMPORTED_MODULE_3__["Segment"](p.copy(), p.copy()), new _shapes_segment__WEBPACK_IMPORTED_MODULE_3__["Segment"](p.copy(), p.copy()), new _shapes_segment__WEBPACK_IMPORTED_MODULE_3__["Segment"](p.copy(), p.copy())];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.rectangle[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var s = _step.value;
          this.viewer.activeLayer.add(s);
          this.snapExclude.push(s.a, s.b);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.pointPicked(p.x, p.y);
      this.viewer.refresh();
    }
  }, {
    key: "alignSegments",
    value: function alignSegments(p) {
      this.rectangle[0].b.x = p.x;
      this.rectangle[1].a.x = p.x;
      this.rectangle[1].b.setFromPoint(p);
      this.rectangle[2].a.setFromPoint(p);
      this.rectangle[2].b.y = p.y;
      this.rectangle[3].a.y = p.y;
    }
  }, {
    key: "stepFinish",
    value: function stepFinish(p) {
      this.pointPicked(p.x, p.y);
      var pm = this.viewer.parametricManager;
      pm.linkObjects([this.rectangle[3].b, this.rectangle[0].a]);
      pm.linkObjects([this.rectangle[0].b, this.rectangle[1].a]);
      pm.linkObjects([this.rectangle[1].b, this.rectangle[2].a]);
      pm.linkObjects([this.rectangle[2].b, this.rectangle[3].a]);
      var constraints = [new _parametric__WEBPACK_IMPORTED_MODULE_4__["Constraints"].Horizontal(this.rectangle[0]), new _parametric__WEBPACK_IMPORTED_MODULE_4__["Constraints"].Horizontal(this.rectangle[2]), new _parametric__WEBPACK_IMPORTED_MODULE_4__["Constraints"].Vertical(this.rectangle[3]), new _parametric__WEBPACK_IMPORTED_MODULE_4__["Constraints"].Vertical(this.rectangle[1])];
      pm.addAll(constraints);
      this.viewer.refresh();
      this.viewer.toolManager.releaseControl();
    }
  }, {
    key: "processCommand",
    value: function processCommand(command) {
      var result = _tool__WEBPACK_IMPORTED_MODULE_0__["Tool"].ParseVector(this.viewer.referencePoint, command);
      if (typeof result === 'string') return result;

      if (this.rectangle == null) {
        this.createRectangle(result);
      } else {
        this.alignSegments(result);
        this.stepFinish(result);
      }
    }
  }]);

  return RectangleTool;
}(_tool__WEBPACK_IMPORTED_MODULE_0__["Tool"]);

/***/ }),

/***/ "./web/app/sketcher/tools/segment.js":
/*!*******************************************!*\
  !*** ./web/app/sketcher/tools/segment.js ***!
  \*******************************************/
/*! exports provided: AddSegmentTool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddSegmentTool", function() { return AddSegmentTool; });
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tool */ "./web/app/sketcher/tools/tool.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


var AddSegmentTool =
/*#__PURE__*/
function (_Tool) {
  _inherits(AddSegmentTool, _Tool);

  function AddSegmentTool(viewer, multi) {
    var _this;

    _classCallCheck(this, AddSegmentTool);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AddSegmentTool).call(this, multi ? "multi line" : "line", viewer));
    _this.line = null;
    _this.multi = multi;
    return _this;
  }

  _createClass(AddSegmentTool, [{
    key: "restart",
    value: function restart() {
      this.line = null;
      this.sendHint('specify the first point');
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      this.viewer.cleanSnap();
      this.line = null;
    }
  }, {
    key: "mousemove",
    value: function mousemove(e) {
      var p = this.viewer.screenToModel(e);

      if (this.line != null) {
        this.viewer.snap(p.x, p.y, [this.line.a, this.line.b]);
        this.line.b.x = p.x;
        this.line.b.y = p.y;
        this.viewer.refresh();
      } else {
        this.viewer.snap(p.x, p.y, []);
        this.viewer.refresh();
      }
    }
  }, {
    key: "mouseup",
    value: function mouseup(e) {
      if (this.line == null) {
        var b = this.viewer.screenToModel(e);
        var a = b;
        var needSnap = false;

        if (this.viewer.snapped != null) {
          a = this.viewer.snapped;
          this.viewer.cleanSnap();
          needSnap = true;
        }

        this.line = this.viewer.addSegment(a.x, a.y, b.x, b.y, this.viewer.activeLayer);

        if (needSnap) {
          this.viewer.parametricManager.linkObjects([this.line.a, a]);
        }

        this.firstPointPicked();
        this.viewer.refresh();
      } else {
        if (this.viewer.snapped != null) {
          var p = this.viewer.snapped;
          this.viewer.cleanSnap();
          this.line.b.x = p.x;
          this.line.b.y = p.y;
          this.viewer.parametricManager.linkObjects([this.line.b, p]);
        }

        this.nextPointPicked();
      }
    }
  }, {
    key: "nextPointPicked",
    value: function nextPointPicked() {
      this.pointPicked(this.line.b.x, this.line.b.y);

      if (this.multi) {
        var b = this.line.b;
        this.line = this.viewer.addSegment(b.x, b.y, b.x, b.y, this.viewer.activeLayer);
        this.viewer.parametricManager.linkObjects([this.line.a, b]);
      } else {
        this.restart();
      }

      if (this.multi) {
        this.sendHint('specify next point');
      }

      this.viewer.refresh();
    }
  }, {
    key: "firstPointPicked",
    value: function firstPointPicked() {
      this.pointPicked(this.line.a.x, this.line.a.y);
      this.sendHint('specify ' + (this.multi ? 'next' : 'end') + ' point');
    }
  }, {
    key: "dblclick",
    value: function dblclick(e) {
      this.cancelSegment();
    }
  }, {
    key: "keydown",
    value: function keydown(e) {
      if (e.keyCode == 27) {
        this.cancelSegment();
      }
    }
  }, {
    key: "cancelSegment",
    value: function cancelSegment() {
      if (this.multi && this.line != null) {
        this.viewer.remove(this.line);
        this.viewer.refresh();
        this.cleanup(null);
      }
    }
  }, {
    key: "processCommand",
    value: function processCommand(command) {
      var result = _tool__WEBPACK_IMPORTED_MODULE_0__["Tool"].ParseVector(this.viewer.referencePoint, command);

      if (typeof result === 'string') {
        return result;
      }

      var p = result;

      if (this.line == null) {
        this.line = this.viewer.addSegment(p.x, p.y, p.x, p.y, this.viewer.activeLayer);
        this.firstPointPicked();
      } else {
        this.line.b.x = p.x;
        this.line.b.y = p.y;
        this.nextPointPicked();
      }

      this.viewer.refresh();
    }
  }]);

  return AddSegmentTool;
}(_tool__WEBPACK_IMPORTED_MODULE_0__["Tool"]);

/***/ }),

/***/ "./web/app/sketcher/tools/tool.js":
/*!****************************************!*\
  !*** ./web/app/sketcher/tools/tool.js ***!
  \****************************************/
/*! exports provided: Tool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tool", function() { return Tool; });
/* harmony import */ var _shapes_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shapes/point */ "./web/app/sketcher/shapes/point.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var Tool =
/*#__PURE__*/
function () {
  function Tool(name, viewer) {
    _classCallCheck(this, Tool);

    this.name = name;
    this.viewer = viewer;
  }

  _createClass(Tool, [{
    key: "restart",
    value: function restart() {}
  }, {
    key: "cleanup",
    value: function cleanup() {}
  }, {
    key: "mousemove",
    value: function mousemove(e) {}
  }, {
    key: "mousedown",
    value: function mousedown(e) {}
  }, {
    key: "mouseup",
    value: function mouseup(e) {}
  }, {
    key: "dblclick",
    value: function dblclick(e) {}
  }, {
    key: "keydown",
    value: function keydown(e) {}
  }, {
    key: "keypress",
    value: function keypress(e) {}
  }, {
    key: "keyup",
    value: function keyup(e) {}
  }, {
    key: "sendMessage",
    value: function sendMessage(text) {
      this.viewer.bus.dispatch('tool-message', text);
    }
  }, {
    key: "sendHint",
    value: function sendHint(hint) {
      this.viewer.bus.dispatch('tool-hint', hint);
    }
  }, {
    key: "sendSpecifyPointHint",
    value: function sendSpecifyPointHint() {
      this.sendHint('specify point');
    }
  }, {
    key: "pointPicked",
    value: function pointPicked(x, y) {
      this.sendMessage('picked: ' + this.viewer.roundToPrecision(x) + " : " + this.viewer.roundToPrecision(y));
      this.viewer.referencePoint.x = x;
      this.viewer.referencePoint.y = y;
    }
  }, {
    key: "snapIfNeed",
    value: function snapIfNeed(p) {
      if (this.viewer.snapped != null) {
        var snapWith = this.viewer.snapped;
        this.viewer.cleanSnap();
        p.setFromPoint(snapWith);
        this.viewer.parametricManager.linkObjects([p, snapWith]);
        this.viewer.parametricManager.refresh();
      }
    }
  }, {
    key: "endpoint",
    value: function endpoint(e) {
      var ep = new _shapes_point__WEBPACK_IMPORTED_MODULE_0__["EndPoint"](0, 0);

      if (this.viewer.snapped != null) {
        this.snapIfNeed(ep);
      } else {
        ep.setFromPoint(this.viewer.screenToModel(e));
      }

      return ep;
    }
  }], [{
    key: "dumbMode",
    value: function dumbMode(e) {
      return e.ctrlKey || e.metaKey;
    }
  }]);

  return Tool;
}();

Tool.ParseNumber = function (str) {
  var val;

  try {
    val = eval(str);
  } catch (e) {
    return e.toString();
  }

  var valNumber = parseFloat(val);
  if (isNaN(valNumber)) return "wrong input for number: " + str;
  return valNumber;
};

Tool.ParseNumberWithRef = function (str, ref) {
  var rel = str.startsWith('@');

  if (rel) {
    str = str.substring(1);
  }

  var val = Tool.ParseNumber(str);
  if (typeof val === 'string') return val;

  if (rel) {
    val += ref;
  }

  return val;
};

var VECTOR_PATTERN = /^(@)?(.+)(,|<)(.+)$/;

Tool.ParseVector = function (referencePoint, command) {
  command = command.replace(/\s+/g, '');
  var match = command.match(VECTOR_PATTERN);

  if (match) {
    var ref = match[1] !== undefined;
    var x = Tool.ParseNumber(match[2]);
    if (typeof x === 'string') return x;
    var polar = match[3] == '<';
    var y = Tool.ParseNumber(match[4]);
    if (typeof y === 'string') return y;

    if (polar) {
      var angle = y / 180 * Math.PI;
      var radius = x;
      x = radius * Math.cos(angle);
      y = radius * Math.sin(angle);
    }

    if (ref) {
      x += referencePoint.x;
      y += referencePoint.y;
    }

    return {
      x: x,
      y: y
    };
  }

  return "wrong input, point is expected: x,y | @x,y | r<polar | @r<polar ";
};

Tool.ParseNumberSequence = function (command, refs, length) {
  command = command.replace(/\s+/g, '');
  var parts = command.split(',');
  var result = [];

  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    var val = refs && refs[i] ? Tool.ParseNumberWithRef(part, refs[i]) : Tool.ParseNumberWithRef(part);
    result.push(val);
  }

  if (length !== undefined && result.length != length) {
    return "wrong input, sequence of length " + length + " is expected: x1,x2...";
  }

  return result;
};

/***/ }),

/***/ "./web/app/sketcher/viewer2d.js":
/*!**************************************!*\
  !*** ./web/app/sketcher/viewer2d.js ***!
  \**************************************/
/*! exports provided: Viewer, Styles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Viewer", function() { return Viewer; });
/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles */ "./web/app/sketcher/styles.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Styles", function() { return _styles__WEBPACK_IMPORTED_MODULE_0__["Styles"]; });

/* harmony import */ var _ui_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/toolkit */ "./web/app/ui/toolkit.js");
/* harmony import */ var _parametric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parametric */ "./web/app/sketcher/parametric.js");
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./history */ "./web/app/sketcher/history.js");
/* harmony import */ var _tools_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tools/manager */ "./web/app/sketcher/tools/manager.js");
/* harmony import */ var _tools_pan__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tools/pan */ "./web/app/sketcher/tools/pan.js");
/* harmony import */ var _shapes_segment__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shapes/segment */ "./web/app/sketcher/shapes/segment.js");
/* harmony import */ var _shapes_point__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shapes/point */ "./web/app/sketcher/shapes/point.js");
/* harmony import */ var _shapes_primitives__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shapes/primitives */ "./web/app/sketcher/shapes/primitives.js");
/* harmony import */ var _shapes_reference_point__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./shapes/reference-point */ "./web/app/sketcher/shapes/reference-point.js");
/* harmony import */ var _shapes_basis_origin__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./shapes/basis-origin */ "./web/app/sketcher/shapes/basis-origin.js");
/* harmony import */ var math_vector__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! math/vector */ "./modules/math/vector.js");
/* harmony import */ var _shapes_draw_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./shapes/draw-utils */ "./web/app/sketcher/shapes/draw-utils.js");
/* harmony import */ var _math_l3space__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../math/l3space */ "./web/app/math/l3space.js");
/* harmony import */ var _sketcherStreams__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./sketcherStreams */ "./web/app/sketcher/sketcherStreams.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

















var Viewer =
/*#__PURE__*/
function () {
  function Viewer(canvas, IO) {
    var _this = this;

    _classCallCheck(this, Viewer);

    _defineProperty(this, "objectsUpdate", function () {
      return _this.streams.objectsUpdate.next();
    });

    // 1/1000'' aka 1 mil is a standard precision for the imperial system(for engeneering) 
    // this precision also covers the metric system which is supposed to be ~0.01
    // this field is used only for displaying purposes now, although in future it could be
    // used to keep all internal data with such precision transforming the input from user
    this.presicion = 3;
    this.canvas = canvas;
    this.params = new _ui_toolkit__WEBPACK_IMPORTED_MODULE_1__["Parameters"]();
    this.io = new IO(this);
    this.streams = Object(_sketcherStreams__WEBPACK_IMPORTED_MODULE_14__["default"])(this);
    var viewer = this;
    this.retinaPxielRatio = window.devicePixelRatio > 1 ? window.devicePixelRatio : 1;

    function updateCanvasSize() {
      var canvasWidth = canvas.parentNode.offsetWidth;
      var canvasHeight = canvas.parentNode.offsetHeight;
      canvas.width = canvasWidth * viewer.retinaPxielRatio;
      canvas.height = canvasHeight * viewer.retinaPxielRatio;
      canvas.style.width = canvasWidth + "px";
      canvas.style.height = canvasHeight + "px";
    }

    this.onWindowResize = function () {
      updateCanvasSize();
      viewer.refresh();
    };

    updateCanvasSize();
    window.addEventListener('resize', this.onWindowResize, false);
    Object.defineProperty(this, "activeLayer", {
      get: viewer.getActiveLayer,
      set: viewer.setActiveLayer
    });
    this.bus = new _ui_toolkit__WEBPACK_IMPORTED_MODULE_1__["Bus"]();
    this.ctx = this.canvas.getContext("2d");
    this._activeLayer = null;
    this.layers = [this.createLayer("sketch", _styles__WEBPACK_IMPORTED_MODULE_0__["Styles"].DEFAULT) // this.createLayer("_construction_", Styles.CONSTRUCTION) 
    ];
    this.dimLayer = this.createLayer("_dim", _styles__WEBPACK_IMPORTED_MODULE_0__["Styles"].DIM);
    this.dimLayers = [this.dimLayer];
    this.bus.defineObservable(this, 'dimScale', 1);
    this.bus.subscribe('dimScale', function () {
      viewer.refresh();
    });
    this._workspace = [this.layers, this.dimLayers];
    this.referencePoint = new _shapes_reference_point__WEBPACK_IMPORTED_MODULE_9__["ReferencePoint"]();
    this._serviceWorkspace = [this._createServiceLayers()];
    this.toolManager = new _tools_manager__WEBPACK_IMPORTED_MODULE_4__["ToolManager"](this, new _tools_pan__WEBPACK_IMPORTED_MODULE_5__["PanTool"](this));
    this.parametricManager = new _parametric__WEBPACK_IMPORTED_MODULE_2__["ParametricManager"](this);
    this.translate = {
      x: 0.0,
      y: 0.0
    };
    this.scale = 1.0;
    this.selected = [];
    this.snapped = null;
    this.historyManager = new _history__WEBPACK_IMPORTED_MODULE_3__["HistoryManager"](this);
    this.transformation = null;
    this.screenToModelMatrix = null;
    this.validators = [];
    this.refresh();
  }

  _createClass(Viewer, [{
    key: "dispose",
    value: function dispose() {
      window.removeEventListener('resize', this.onWindowResize, false);
      this.canvas = null;
      this.toolManager.dispose();
    }
  }, {
    key: "isDisposed",
    value: function isDisposed() {
      return this.canvas === null;
    }
  }, {
    key: "setTransformation",
    value: function setTransformation(a, b, c, d, e, f, zoom) {
      this.transformation = [a, b, c, d, e, f];
      this.scale = zoom;

      if (this.screenToModelMatrix === null) {
        this.screenToModelMatrix = new _math_l3space__WEBPACK_IMPORTED_MODULE_13__["Matrix3"]();
      }

      this.screenToModelMatrix.set34(a, c, 0, e, b, d, 0, f, 0, 0, 1, 0)._invert();
    }
  }, {
    key: "roundToPrecision",
    value: function roundToPrecision(value) {
      return value.toFixed(this.presicion);
    }
  }, {
    key: "addSegment",
    value: function addSegment(x1, y1, x2, y2, layer) {
      var a = new _shapes_point__WEBPACK_IMPORTED_MODULE_7__["EndPoint"](x1, y1);
      var b = new _shapes_point__WEBPACK_IMPORTED_MODULE_7__["EndPoint"](x2, y2);
      var line = new _shapes_segment__WEBPACK_IMPORTED_MODULE_6__["Segment"](a, b);
      layer.add(line);
      return line;
    }
  }, {
    key: "remove",
    value: function remove(obj) {
      this.removeAll([obj]);
    }
  }, {
    key: "removeAll",
    value: function removeAll(objects) {
      this.parametricManager.removeObjects(objects);
    }
  }, {
    key: "add",
    value: function add(obj, layer) {
      layer.add(obj);
    }
  }, {
    key: "search",
    value: function search(x, y, buffer, deep, onlyPoints, filter) {
      var _this2 = this;

      buffer *= 0.5;
      var pickResult = [];
      var aim = new math_vector__WEBPACK_IMPORTED_MODULE_11__["default"](x, y);
      var heroIdx = 0;
      var unreachable = buffer * 2;
      var heroLength = unreachable; // unreachable

      function isFiltered(o) {
        for (var i = 0; i < filter.length; ++i) {
          if (filter[i] === o) return true;
        }

        return false;
      }

      for (var i = 0; i < this.layers.length; i++) {
        var objs = this.layers[i].objects;

        for (var j = 0; j < objs.length; j++) {
          var l = unreachable + 1;
          var before = pickResult.length;
          objs[j].accept(function (o) {
            if (!o.visible) return true;

            if (onlyPoints && !isEndPoint(o)) {
              return true;
            }

            l = o.normalDistance(aim, _this2.scale);

            if (l >= 0 && l <= buffer && !isFiltered(o)) {
              pickResult.push(o);
              return false;
            }

            return true;
          });
          var hit = before - pickResult.length != 0;

          if (hit) {
            if (!deep && pickResult.length != 0) return pickResult;

            if (l >= 0 && l < heroLength) {
              heroLength = l;
              heroIdx = pickResult.length - 1;
            }
          }
        }
      }

      if (pickResult.length > 0) {
        var _f = pickResult[0];
        pickResult[0] = pickResult[heroIdx];
        pickResult[heroIdx] = _f;
      }

      return pickResult;
    }
  }, {
    key: "_createServiceLayers",
    value: function _createServiceLayers() {
      var layer = this.createLayer("_service", _styles__WEBPACK_IMPORTED_MODULE_0__["Styles"].SERVICE); //  layer.objects.push(new CrossHair(0, 0, 20));

      layer.objects.push(new _shapes_primitives__WEBPACK_IMPORTED_MODULE_8__["Point"](0, 0, 2));
      layer.objects.push(this.referencePoint);
      layer.objects.push(new _shapes_basis_origin__WEBPACK_IMPORTED_MODULE_10__["BasisOrigin"](null, this));
      return [layer];
    }
  }, {
    key: "refresh",
    value: function refresh() {
      var viewer = this;
      window.requestAnimationFrame(function () {
        if (!viewer.isDisposed()) {
          viewer.repaint();
        }
      });
    }
  }, {
    key: "repaint",
    value: function repaint() {
      var ctx = this.ctx;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      ctx.transform(1, 0, 0, -1, 0, this.canvas.height);

      if (this.transformation) {
        var _this$transformation = _slicedToArray(this.transformation, 6),
            a = _this$transformation[0],
            b = _this$transformation[1],
            c = _this$transformation[2],
            d = _this$transformation[3],
            e = _this$transformation[4],
            f = _this$transformation[5];

        ctx.transform(a, b, c, d, e, f);
      } else {
        ctx.transform(1, 0, 0, 1, this.translate.x, this.translate.y);
        ctx.transform(this.scale, 0, 0, this.scale, 0, 0);
      }

      this.__prevStyle = null;

      this.__drawWorkspace(ctx, this._workspace, Viewer.__SKETCH_DRAW_PIPELINE);

      this.__drawWorkspace(ctx, this._serviceWorkspace, Viewer.__SIMPLE_DRAW_PIPELINE);
    }
  }, {
    key: "__drawWorkspace",
    value: function __drawWorkspace(ctx, workspace, pipeline) {
      var _this3 = this;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function _loop() {
          var drawPredicate = _step.value;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = workspace[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var layers = _step2.value;
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                var _loop2 = function _loop2() {
                  var layer = _step3.value;
                  var _iteratorNormalCompletion4 = true;
                  var _didIteratorError4 = false;
                  var _iteratorError4 = undefined;

                  try {
                    for (var _iterator4 = layer.objects[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                      var obj = _step4.value;
                      obj.accept(function (obj) {
                        if (!obj.visible) return true;

                        if (drawPredicate(obj)) {
                          _this3.__draw(ctx, layer, obj);
                        }

                        return true;
                      });
                    }
                  } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                        _iterator4["return"]();
                      }
                    } finally {
                      if (_didIteratorError4) {
                        throw _iteratorError4;
                      }
                    }
                  }
                };

                for (var _iterator3 = layers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  _loop2();
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                    _iterator3["return"]();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        };

        for (var _iterator = pipeline[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "__draw",
    value: function __draw(ctx, layer, obj) {
      var style = this.getStyleForObject(layer, obj);

      if (style !== this.__prevStyle) {
        this.setStyle(style, ctx);
      }

      this.__prevStyle = style;
      obj.draw(ctx, this.scale / this.retinaPxielRatio, this);
    }
  }, {
    key: "getStyleForObject",
    value: function getStyleForObject(layer, obj) {
      if (obj.style != null) {
        return obj.style;
      } else if (obj.role != null) {
        var style = layer.stylesByRoles[obj.role];

        if (style) {
          return style;
        }
      }

      return layer.style;
    }
  }, {
    key: "setStyle",
    value: function setStyle(style, ctx) {
      _shapes_draw_utils__WEBPACK_IMPORTED_MODULE_12__["SetStyle"](style, ctx, this.scale / this.retinaPxielRatio);
    }
  }, {
    key: "snap",
    value: function snap(x, y, excl) {
      this.cleanSnap();
      var snapTo = this.search(x, y, 20 / this.scale, true, true, excl);

      if (snapTo.length > 0) {
        this.snapped = snapTo[0];
        this.mark(this.snapped, _styles__WEBPACK_IMPORTED_MODULE_0__["Styles"].SNAP);
      }

      return this.snapped;
    }
  }, {
    key: "cleanSnap",
    value: function cleanSnap() {
      if (this.snapped != null) {
        this.deselect(this.snapped);
        this.snapped = null;
      }
    }
  }, {
    key: "showBounds",
    value: function showBounds(x1, y1, x2, y2, offset) {
      var dx = Math.max(x2 - x1, 1);
      var dy = Math.max(y2 - y1, 1);

      if (this.canvas.width > this.canvas.height) {
        this.scale = this.canvas.height / dy;
      } else {
        this.scale = this.canvas.width / dx;
      }

      this.translate.x = -x1 * this.scale;
      this.translate.y = -y1 * this.scale;
    }
  }, {
    key: "screenToModel2",
    value: function screenToModel2(x, y, out) {
      out.x = x * this.retinaPxielRatio;
      out.y = this.canvas.height - y * this.retinaPxielRatio;

      if (this.transformation) {
        out.z = 0;

        this.screenToModelMatrix._apply(out);
      } else {
        out.x -= this.translate.x;
        out.y -= this.translate.y;
        out.x /= this.scale;
        out.y /= this.scale;
      }
    }
  }, {
    key: "screenToModel",
    value: function screenToModel(e) {
      return this._screenToModel(e.offsetX, e.offsetY);
    }
  }, {
    key: "_screenToModel",
    value: function _screenToModel(x, y) {
      var out = {
        x: 0,
        y: 0
      };
      this.screenToModel2(x, y, out);
      return out;
    }
  }, {
    key: "accept",
    value: function accept(visitor) {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = this.layers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var layer = _step5.value;
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = layer.objects[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var object = _step6.value;

              if (!object.accept(visitor)) {
                return false;
              }
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                _iterator6["return"]();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
  }, {
    key: "findLayerByName",
    value: function findLayerByName(name) {
      for (var i = 0; i < this.layers.length; i++) {
        if (this.layers[i].name == name) {
          return this.layers[i];
        }
      }

      return null;
    }
  }, {
    key: "findById",
    value: function findById(id) {
      var result = null;
      this.accept(function (o) {
        if (o.id === id) {
          result = o;
          return false;
        }

        return true;
      });
      return result;
    }
  }, {
    key: "select",
    value: function select(objs, exclusive) {
      if (exclusive) this.deselectAll();

      for (var i = 0; i < objs.length; i++) {
        this.mark(objs[i]);
      }
    }
  }, {
    key: "pick",
    value: function pick(e) {
      var m = this.screenToModel(e);
      return this.search(m.x, m.y, 20 / this.scale, true, false, []);
    }
  }, {
    key: "mark",
    value: function mark(obj, style) {
      if (style === undefined) {
        style = _styles__WEBPACK_IMPORTED_MODULE_0__["Styles"].MARK;
      }

      obj.marked = style;

      if (this.selected.indexOf(obj) == -1) {
        this.selected.push(obj);
        this.streams.selection.next(this.selected);
      }
    }
  }, {
    key: "getActiveLayer",
    value: function getActiveLayer() {
      var layer = this._activeLayer;

      if (layer == null || layer.readOnly) {
        layer = null;

        for (var i = 0; i < this.layers.length; i++) {
          var l = this.layers[i];

          if (!l.readOnly) {
            layer = l;
            break;
          }
        }
      }

      if (layer == null) {
        layer = this.createLayer("sketch", _styles__WEBPACK_IMPORTED_MODULE_0__["Styles"].DEFAULT);
        this.layers.push(layer);
      }

      return layer;
    }
  }, {
    key: "setActiveLayerName",
    value: function setActiveLayerName(layerName) {
      var layer = this.findLayerByName(layerName);

      if (layer) {
        this.activeLayer = layer;
      } else {
        console.warn("layer doesn't exist: " + layerName);
      }
    }
  }, {
    key: "setActiveLayer",
    value: function setActiveLayer(layer) {
      if (!layer.readOnly) {
        this._activeLayer = layer;
        this.bus.dispatch("activeLayer");
      }
    }
  }, {
    key: "deselect",
    value: function deselect(obj) {
      for (var i = 0; i < this.selected.length; i++) {
        if (obj === this.selected[i]) {
          this.selected.splice(i, 1)[0].marked = null;
          break;
        }
      }

      this.streams.selection.next(this.selected);
    }
  }, {
    key: "deselectAll",
    value: function deselectAll() {
      for (var i = 0; i < this.selected.length; i++) {
        this.selected[i].marked = null;
      }

      while (this.selected.length > 0) {
        this.selected.pop();
      }

      this.streams.selection.next(this.selected);
    }
  }, {
    key: "equalizeLinkedEndpoints",
    value: function equalizeLinkedEndpoints() {
      var visited = new Set();

      function equalize(obj) {
        if (visited.has(obj.id)) return;
        visited.add(obj.id);
        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
          for (var _iterator7 = obj.linked[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var link = _step7.value;

            if (isEndPoint(link)) {
              equalize(obj, link);
              link.setFromPoint(obj);
              equalize(link);
            }
          }
        } catch (err) {
          _didIteratorError7 = true;
          _iteratorError7 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
              _iterator7["return"]();
            }
          } finally {
            if (_didIteratorError7) {
              throw _iteratorError7;
            }
          }
        }
      }

      this.accept(function (obj) {
        if (isEndPoint(obj)) {
          equalize(obj);
        }

        return true;
      });
    }
  }, {
    key: "fullHeavyUIRefresh",
    value: function fullHeavyUIRefresh() {
      this.refresh();
      this.parametricManager.notify();
    }
  }, {
    key: "createLayer",
    value: function createLayer(name, style, onUpdate) {
      return new Layer(name, style, this);
    }
  }, {
    key: "addingRoleMode",
    get: function get() {
      return this.streams.addingRoleMode.value;
    },
    set: function set(value) {
      this.streams.addingRoleMode.next(value);
    }
  }]);

  return Viewer;
}();

_defineProperty(Viewer, "__SKETCH_DRAW_PIPELINE", [function (obj) {
  return !isEndPoint(obj) && obj.marked === null && isConstruction(obj);
}, function (obj) {
  return !isEndPoint(obj) && obj.marked === null && !isConstruction(obj);
}, function (obj) {
  return !isEndPoint(obj) && obj.marked !== null;
}, function (obj) {
  return isEndPoint(obj) && obj.marked === null;
}, function (obj) {
  return isEndPoint(obj) && obj.marked !== null;
}]);

_defineProperty(Viewer, "__SIMPLE_DRAW_PIPELINE", [function (obj) {
  return true;
}]);

var isEndPoint = function isEndPoint(o) {
  return o._class === 'TCAD.TWO.EndPoint';
};

var isConstruction = function isConstruction(o) {
  return o.role === 'construction';
};

var Layer =
/*#__PURE__*/
function () {
  function Layer(name, style, viewer) {
    _classCallCheck(this, Layer);

    this.name = name;
    this.style = style;
    this.stylesByRoles = {
      'objectConstruction': _styles__WEBPACK_IMPORTED_MODULE_0__["Styles"].CONSTRUCTION_OF_OBJECT,
      'construction': _styles__WEBPACK_IMPORTED_MODULE_0__["Styles"].CONSTRUCTION,
      'virtual': _styles__WEBPACK_IMPORTED_MODULE_0__["Styles"].VIRTUAL
    };
    this.objects = [];
    this.readOnly = false; // This is actually a mark for boundary layers coming from 3D

    this.viewer = viewer;
  }

  _createClass(Layer, [{
    key: "remove",
    value: function remove(object) {
      var idx = this.objects.indexOf(object);

      if (idx !== -1) {
        this.objects.splice(idx, 1);
        this.viewer.objectsUpdate();
        return true;
      }

      return false;
    }
  }, {
    key: "add",
    value: function add(object) {
      if (object.layer !== undefined) {
        if (object.layer != null) {
          object.layer.remove(object);
        }

        if (object.layer !== this) {
          object.layer = this;

          this._addAndNotify(object);
        }
      } else {
        this._addAndNotify(object);
      }
    }
  }, {
    key: "_addAndNotify",
    value: function _addAndNotify(object) {
      if (this.viewer.addingRoleMode) {
        object.role = this.viewer.addingRoleMode;
      }

      this.objects.push(object);
      this.viewer.objectsUpdate();
    }
  }]);

  return Layer;
}();



/***/ }),

/***/ "./web/app/ui/terminal.js":
/*!********************************!*\
  !*** ./web/app/ui/terminal.js ***!
  \********************************/
/*! exports provided: Terminal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Terminal", function() { return Terminal; });
function Terminal(win, commandProcessor, variantsSupplier) {
  var _this = this;

  this.win = win;
  this.out = win.root.find('.terminal-output');
  var input = win.root.find('.terminal-input input');
  this.input = input;

  win.onShowCallback = function () {
    input.focus();
  };

  this.makeAlwaysFocusable();
  this.history = [];
  this.historyPointer = 0;

  var setHistory = function setHistory() {
    if (_this.history.length == 0) return;
    input.val(_this.history[_this.historyPointer]);
  };

  input.keydown(function (e) {
    function consumeEvent() {
      e.preventDefault();
      e.stopPropagation();
    }

    if (e.keyCode == 9) {
      var text = input.val();
      var variants = variantsSupplier().filter(function (v) {
        return v.startsWith(text);
      });
      variants.sort();

      if (variants.length == 0) {} else {
        var shared = sharedStartOfSortedArray(variants);

        if (shared.length != text.length) {
          input.val(shared);
        } else {
          var autocompleteArea = _this.out.find('.autocomplete-area');

          if (autocompleteArea.length == 0) {
            autocompleteArea = $('<div>', {
              'class': 'terminal-commandText autocomplete-area'
            });

            _this.out.append(autocompleteArea);
          }

          var more = '';
          var limit = 20;

          if (variants.length > limit) {
            more = '... and ' + (variants.length - limit) + ' more';
            variants = variants.slice(0, limit);
          }

          autocompleteArea.text(variants.join(' ') + more);

          _this.scrollToTheEnd();
        }
      }

      consumeEvent();
    } else if (e.keyCode == 38) {
      _this.historyPointer = Math.max(_this.historyPointer - 1, 0);
      setHistory();
      consumeEvent();
    } else if (e.keyCode == 40) {
      if (_this.historyPointer != _this.history.length) {
        _this.historyPointer = Math.min(_this.historyPointer + 1, _this.history.length - 1);
        setHistory();
      }

      consumeEvent();
    }
  });
  input.keyup(function (e) {
    if (e.keyCode == 13) {
      var command = input.val();

      _this.out.find('.autocomplete-area').remove();

      input.val('');

      _this.out.append($('<div>', {
        text: '> ' + command,
        'class': 'terminal-commandText'
      }));

      if (command != null && command.trim().length != 0) {
        var result = commandProcessor(command);

        _this.print(result);

        if (_this.history.length == 0 || command != _this.history[_this.history.length - 1]) {
          _this.history.push(command);
        }

        _this.historyPointer = _this.history.length;
      }

      _this.scrollToTheEnd();
    }
  });
}

Terminal.prototype.makeAlwaysFocusable = function () {
  var _this2 = this;

  var wasMove = false;
  this.win.root.mousedown(function () {
    wasMove = false;
    return true;
  });
  this.win.root.mousemove(function () {
    wasMove = true;
    return true;
  });
  this.win.root.mouseup(function () {
    if (!wasMove) _this2.input.focus();
    return true;
  });
};

Terminal.prototype.scrollToTheEnd = function () {
  this.out.parent().scrollTop(this.out.height());
};

Terminal.prototype.print = function (text) {
  this.out.append($('<div>', {
    text: text,
    'class': 'terminal-commandResult'
  }));
  this.scrollToTheEnd();
};

function sharedStartOfSortedArray(array) {
  var a1 = array[0],
      a2 = array[array.length - 1],
      L = a1.length,
      i = 0;

  while (i < L && a1.charAt(i) === a2.charAt(i)) {
    i++;
  }

  return a1.substring(0, i);
}

/***/ }),

/***/ "./web/app/ui/toolkit.js":
/*!*******************************!*\
  !*** ./web/app/ui/toolkit.js ***!
  \*******************************/
/*! exports provided: add, methodRef, Box, Panel, Folder, Button, CheckBox, InlineRadio, propLayout, Text, Combo, ButtonRow, List, Tree, Parameters, Bus, config, Number */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "methodRef", function() { return methodRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box", function() { return Box; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Panel", function() { return Panel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Folder", function() { return Folder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Button", function() { return Button; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CheckBox", function() { return CheckBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InlineRadio", function() { return InlineRadio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "propLayout", function() { return propLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Text", function() { return Text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Combo", function() { return Combo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ButtonRow", function() { return ButtonRow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "List", function() { return List; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tree", function() { return Tree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parameters", function() { return Parameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bus", function() { return Bus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "config", function() { return config; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Number", function() { return NumberWidget; });
function add(parent, child) {
  parent.content.append(child.root);
}
function methodRef(_this, methodName, args) {
  return function () {
    _this[methodName].apply(_this, args);
  };
}
function Box(parent) {
  this.root = this.content = $('<div class="tc-box" />');
  this.root.addClass('tc-box tc-scroll');
  this.root.appendTo(parent ? parent : 'body');
}

Box.prototype.close = function () {
  this.root.remove();
};

function Panel() {
  this.root = this.content = $('<div />');
  this.root.addClass('tc-panel tc-scroll');
}

Panel.prototype.close = function () {
  this.root.remove();
};

function Folder(title) {
  this.root = $('<div/>', {
    'class': 'tc-folder'
  });
  this.content = $('<div/>');
  this.root.append($('<div/>', {
    text: title,
    'class': 'tc-row tc-title'
  }));
  this.root.append(this.content);
}
function Button(title) {
  this.root = $('<div/>', {
    'class': 'tc-row tc-ctrl tc-ctrl-btn',
    text: title
  });
}
function CheckBox(title, checked) {
  this.root = $('<div/>', {
    'class': 'tc-row tc-ctrl'
  });
  this.root.append('<label><input type="checkbox">' + title + '</label>');
  this.input = this.root.find("input");
  this.input.prop('checked', !!checked);
}
function InlineRadio(choiceLabels, choiceValues, checkedIndex) {
  var name = 'TCAD.toolkit.InlineRadio_' + InlineRadio.COUNTER++;
  this.root = $('<div/>', {
    'class': 'tc-row tc-ctrl tc-inline-radio'
  });
  this.inputs = [];

  for (var i = 0; i < choiceLabels.length; i++) {
    var checked = checkedIndex === i ? "checked" : '';
    var label = $('<label><input type="radio" name="' + name + '" value="' + choiceValues[i] + '"><span>' + choiceLabels[i] + '</span></label>');
    this.inputs.push(label.find("input"));
    this.root.append(label);
  }

  this.inputs[checkedIndex].prop('checked', true);
}

InlineRadio.prototype.getValue = function () {
  for (var i = 0; i < this.inputs.length; i++) {
    if (this.inputs[i].prop('checked')) {
      return this.inputs[i].attr('value');
    }
  }

  return null;
};

InlineRadio.prototype.setValue = function (v) {
  this.root.find('input[value=' + v + ']').prop('checked', true);
};

InlineRadio.COUNTER = 0;
function propLayout(root, name, valueEl) {
  root.append($('<span/>', {
    'class': 'tc-prop-name',
    text: name
  })).append($('<div/>', {
    'class': 'tc-prop-value'
  }).append(valueEl));
}

function NumberWidget(name, initValue, baseStep, round) {
  this.root = $('<div/>', {
    'class': 'tc-row tc-ctrl tc-ctrl-number'
  });
  this.input = $("<input type='text' value='" + initValue + "' />");
  this.slide = false;
  baseStep = baseStep || 1;
  round = round || 0;
  this.min = null;
  this.max = null;
  this.accelerator = 100;
  var scope = this;
  var lastValue = null;

  function trigger() {
    if ($(this).val() !== lastValue) {
      $(this).trigger('t-change');
      lastValue = $(this).val();
    }
  }

  this.input.on('input', function (e) {
    var val = $(this).val(); //var floatRegex = /[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/;
    //if (!floatRegex.test(val)) {
    //  $(this).val(val.replace(/[^0-9\.-]/g, ''));
    //}

    trigger.call(this);
  });
  this.input.get(0).addEventListener('mousewheel', function (e) {
    var delta = 0;

    if (e.wheelDelta) {
      // WebKit / Opera / Explorer 9
      delta = e.wheelDelta;
    } else if (e.detail) {
      // Firefox
      delta = -e.detail;
    }

    var val = $(this).val();
    if (!val) val = 0;
    var step = baseStep * (e.shiftKey ? scope.accelerator : 1);
    val = parseFloat(val) + (delta < 0 ? -step : step);

    if (scope.min != null && val < scope.min) {
      val = scope.min;
    }

    if (scope.max != null && val > scope.max) {
      val = scope.max;
    }

    if (round !== 0) {
      val = val.toFixed(round);
    }

    $(this).val(val);
    e.preventDefault();
    e.stopPropagation();
    trigger.call(this);
  }, false);
  propLayout(this.root, name, this.input);
}

NumberWidget.prototype.val = function () {
  return Number(this.input.val());
};

function Text(name, initValue) {
  this.root = $('<div/>', {
    'class': 'tc-row tc-ctrl'
  });
  this.input = $("<input type='text' value='" + initValue + "' />");
  propLayout(this.root, name, this.input);
}
function Combo(id, labelText) {
  this.root = $('<div/>', {
    'class': 'tc-row tc-ctrl tc-ctrl-combo'
  });
  var label = $('<span/>', {
    'class': 'tc-prop-name',
    text: labelText
  });
  this.select = $('<select>', {
    id: id
  });
  this.root.append(label).append($('<div/>', {
    'class': 'tc-prop-value'
  }).append(this.select));
}
function ButtonRow(captions, actions) {
  this.root = $('<div/>', {
    'class': 'tc-row tc-ctrl tc-buttons-block'
  });

  function withAction(btn, action) {
    return btn.click(function () {
      action.call();
    });
  }

  for (var i = 0; i < captions.length; i++) {
    var caption = captions[i];
    var btn = $('<span/>', {
      text: caption,
      'class': 'tc-block-btn active-btn'
    });
    withAction(btn, actions[i]);
    this.root.append(btn);
  }
}
function List() {
  this.root = $('<div/>', {
    'class': 'tc-list'
  });
}

List.prototype.addRow = function (name) {
  var row = $('<div/>', {
    text: name,
    'class': 'tc-row tc-pseudo-btn'
  });
  this.root.append(row);
  return row;
};

List.setIconForRow = function (row, icon) {
  row.css({
    'background-image': 'url(' + icon + ')'
  });
};

function Tree() {
  this.root = $('<div/>', {
    'class': 'tc-tree'
  });
}

Tree.prototype.set = function (data) {
  this.root.empty();

  this._fill(data, 0);
};

Tree.prototype._fill = function (data, level) {
  var notLeaf = data.children !== undefined && data.children.length !== 0;

  if (data.name !== undefined) {
    this.root.append($('<div/>', {
      text: data.name,
      'class': 'tc-row' + (notLeaf ? ' tc-chevron-open' : ''),
      css: {
        'margin-left': level * (notLeaf ? 10 : 16) + 'px'
      }
    }));
  }

  if (notLeaf) {
    for (var i = 0; i < data.children.length; i++) {
      var child = data.children[i];

      this._fill(child, level + 1);
    }
  }
};

function Parameters() {
  this.listeners = {};
}

Parameters.prototype.define = function (name, initValue) {
  function fn(name) {
    return '___' + name;
  }

  this[fn(name)] = initValue;
  return Object.defineProperty(this, name, {
    get: function get() {
      return this[fn(name)];
    },
    set: function set(value) {
      var oldValue = this[fn(name)];
      this[fn(name)] = value;
      this.notify(name, value, oldValue);
    }
  });
};

Parameters.prototype.subscribe = function (name, listenerId, callback, scope) {
  var listenerList = this.listeners[name];

  if (listenerList === undefined) {
    listenerList = [];
    this.listeners[name] = listenerList;
  }

  var callbackFunc = scope === undefined ? callback : function () {
    callback.apply(scope, arguments);
  };
  listenerList.push([listenerId, callbackFunc]);
  var params = this;
  return function () {
    callbackFunc(params[name], undefined, null);
  }; // return init function
};

Parameters.prototype.notify = function (name, newValue, oldValue) {
  var listenerList = this.listeners[name];

  if (listenerList !== undefined) {
    for (var i = 0; i < listenerList.length; i++) {
      var listenerId = listenerList[i][0];
      var callback = listenerList[i][1];

      if (listenerId == null || this.__currentSender == null || listenerId != this.__currentSender) {
        callback(newValue, oldValue, this.__currentSender);
      }
    }
  }

  this.__currentSender = null;
};

Parameters.prototype.set = function (name, value, sender) {
  this.__currentSender = sender;
  this[name] = value;
};

function Bus() {
  this.listeners = {};
}

Bus.prototype.subscribe = function (event, callback, listenerId) {
  var listenerList = this.listeners[event];

  if (listenerList === undefined) {
    listenerList = [];
    this.listeners[event] = listenerList;
  }

  if (listenerId == undefined) listenerId = null;
  listenerList.push([callback, listenerId]);
  return callback;
};

Bus.prototype.unsubscribe = function (event, callback) {
  var listenerList = this.listeners[event];

  for (var i = 0; i < listenerList.length; i++) {
    if (listenerList[i][0] === callback) {
      listenerList.splice(i, 1);
      return;
    }
  }
};

Bus.prototype.dispatch = function (event, data, sender) {
  var listenerList = this.listeners[event];

  if (listenerList !== undefined) {
    for (var i = 0; i < listenerList.length; i++) {
      var callback = listenerList[i][0];
      var listenerId = listenerList[i][1];

      if (sender == undefined || listenerId == null || listenerId != sender) {
        try {
          callback(data);
        } catch (e) {
          console.error(e);
        }
      }
    }
  }
};

Bus.Observable = function (initValue) {
  this.value = initValue;
};

Bus.prototype.defineObservable = function (scope, name, initValue, eventName) {
  if (eventName == undefined) eventName = name;
  var observable = new Bus.Observable(initValue);
  var bus = this;
  return Object.defineProperty(scope, name, {
    get: function get() {
      return observable.value;
    },
    set: function set(value) {
      observable.value = value;
      bus.dispatch(eventName, value);
    }
  });
};

function config(obj, props) {
  for (var key in props) {
    obj[key] = props[key];
  }

  return obj;
}


/***/ }),

/***/ "./web/app/ui/ui.js":
/*!**************************!*\
  !*** ./web/app/ui/ui.js ***!
  \**************************/
/*! exports provided: WinManager, Window, List, Dock, dockBtn, faBtn, openWin, closeWin, bindOpening, createActionsWinBuilder, DIRECTIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WinManager", function() { return WinManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Window", function() { return Window; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "List", function() { return List; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Dock", function() { return Dock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dockBtn", function() { return dockBtn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "faBtn", function() { return faBtn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "openWin", function() { return openWin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closeWin", function() { return closeWin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindOpening", function() { return bindOpening; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createActionsWinBuilder", function() { return createActionsWinBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIRECTIONS", function() { return DIRECTIONS; });
/** @constructor */
function Window(el, winManager) {
  this.root = el;
  this.neverOpened = !this.root.is(':visible');
  this.tileUpRelative = $('body');
  this.onShowCallback = null;
  var root = this.root;
  var caption = this.root.find('.tool-caption');
  caption.each(function () {
    var closeBtn = '<span class="btn rm" style="float: right;"><i class="fa fa-remove"></i></span>';
    $(this).append(closeBtn);
  });
  this.root.find('.tool-caption .rm').click(function () {
    root.hide();
  });
  var DIRS = DIRECTIONS;
  winManager.registerResize(this.root, DIRS.NORTH | DIRS.SOUTH | DIRS.WEST | DIRS.EAST);
  winManager.registerDrag(this.root, caption);
}

Window.prototype.show = function () {
  this.root.show();
};

Window.prototype.toggle = function () {
  var aboutToShow = !this.root.is(':visible');

  if (aboutToShow) {
    this.tileUpPolicy(this.neverOpened, this.tileUpRelative);
  }

  this.neverOpened = false;
  this.root.toggle();

  if (aboutToShow && this.onShowCallback != null) {
    this.onShowCallback(this);
  }
};

Window.prototype.tileUpPolicy = function (firstTime, relativeEl) {
  var span = 20;
  var relOff = relativeEl.offset();
  var off = this.root.offset();
  off = {
    left: parseInt(this.root.css('left')),
    top: parseInt(this.root.css('top'))
  };

  if (firstTime) {
    off = {
      left: relOff.left + relativeEl.width() - this.root.width() - span,
      top: relOff.top + relativeEl.height() - this.root.height() - span
    };
    this.root.css({
      left: off.left + 'px',
      top: off.top + 'px'
    });
  }

  var needToSet = false;

  if (off.left < relOff.left || off.left >= relOff.left + relativeEl.width() - span) {
    off.left = relOff.left + span;
    needToSet = true;
  }

  if (off.top < relOff.top || off.top >= relOff.top + relativeEl.height() - span) {
    off.top = relOff.top + span;
    needToSet = true;
  }

  if (needToSet) {
    this.root.css({
      left: off.left + 'px',
      top: off.top + 'px'
    });
  } //var fixedWidth = null;
  //var fixedHeight = null;
  //
  //if (off.left + this.root.width() > relOff.left + relativeEl.width()) {
  //  fixedWidth = this.root.width() - span * 2; 
  //}
  //if (off.top + this.root.height() > relOff.top + relativeEl.height()) {
  //  fixedHeight = this.root.width() - span * 2;
  //}
  //if (fixedWidth != null) {
  //  console.log(fixedWidth)
  //  this.root.css({ width : fixedWidth + 'px'});
  //}
  //if (fixedHeight != null) {
  //  this.root.css({ height : fixedHeight + 'px'});
  //}

};

function WinManager() {
  this.moveHandler = null;
  var wm = this;
  $('body').mousemove(function (e) {
    if (wm.moveHandler != null) {
      wm.moveHandler(e);
      e.preventDefault();
    }
  });
  $('body').mouseup(function (e) {
    wm.moveHandler = null;
  });
}

WinManager.prototype.captureDrag = function (el, e) {
  var origin = {
    x: e.pageX,
    y: e.pageY
  };
  var originLocation = el.offset();

  this.moveHandler = function (e) {
    var dx = e.pageX - origin.x;
    var dy = e.pageY - origin.y;
    el.offset({
      left: originLocation.left + dx,
      top: originLocation.top + dy
    });
  };
};

WinManager.prototype.captureResize = function (el, dirMask, e, onResize) {
  var origin = {
    x: e.pageX,
    y: e.pageY
  };
  var originSize = {
    x: el.width(),
    y: el.height()
  };
  var originLocation = el.offset();

  var north = _maskTest(dirMask, DIRECTIONS.NORTH);

  var south = _maskTest(dirMask, DIRECTIONS.SOUTH);

  var west = _maskTest(dirMask, DIRECTIONS.WEST);

  var east = _maskTest(dirMask, DIRECTIONS.EAST);

  this.moveHandler = function (e) {
    var dx = e.pageX - origin.x;
    var dy = e.pageY - origin.y;

    if (east) {
      el.css('width', originSize.x + dx + 'px');
    }

    var top = originLocation.top;
    var left = originLocation.left;
    var setLoc = false;

    if (west) {
      el.css('width', originSize.x - dx + 'px');
      left += dx;
      setLoc = true;
    }

    if (south) {
      el.css('height', originSize.y + dy + 'px');
    }

    if (north) {
      el.css('height', originSize.y - dy + 'px');
      top += dy;
      setLoc = true;
    }

    if (setLoc) {
      el.offset({
        left: left,
        top: top
      });
    }

    if (onResize !== undefined) {
      onResize();
    }
  };
};

var DIRECTIONS = {
  NORTH: 0x0001,
  SOUTH: 0x0010,
  WEST: 0x0100,
  EAST: 0x1000
};

WinManager.prototype.registerResize = function (el, dirMask, onResize) {
  var wm = this;

  var north = _maskTest(dirMask, DIRECTIONS.NORTH);

  var south = _maskTest(dirMask, DIRECTIONS.SOUTH);

  var west = _maskTest(dirMask, DIRECTIONS.WEST);

  var east = _maskTest(dirMask, DIRECTIONS.EAST);

  var borderTop = parseInt(el.css('borderTopWidth'), 10);
  var borderLeft = parseInt(el.css('borderLeftWidth'), 10);

  function onNorthEdge(e, el) {
    var offset = el.offset();
    return e.pageY < offset.top + borderTop;
  }

  function onSouthEdge(e, el) {
    var offset = el.offset();
    var height = el.height();
    return e.pageY > offset.top + height + borderTop;
  }

  function onWestEdge(e, el) {
    var offset = el.offset();
    return e.pageX < offset.left + borderLeft;
  }

  function onEastEdge(e, el) {
    var offset = el.offset();
    var width = el.width();
    return e.pageX > offset.left + width + borderLeft;
  }

  el.mousedown(function (e) {
    var $this = $(this);

    if (north && east && onNorthEdge(e, $this) && onEastEdge(e, $this)) {
      wm.captureResize(el, DIRECTIONS.NORTH | DIRECTIONS.EAST, e, onResize);
    } else if (north && west && onNorthEdge(e, $this) && onWestEdge(e, $this)) {
      wm.captureResize(el, DIRECTIONS.NORTH | DIRECTIONS.WEST, e, onResize);
    } else if (south && east && onSouthEdge(e, $this) && onEastEdge(e, $this)) {
      wm.captureResize(el, DIRECTIONS.SOUTH | DIRECTIONS.EAST, e, onResize);
    } else if (south && west && onSouthEdge(e, $this) && onWestEdge(e, $this)) {
      wm.captureResize(el, DIRECTIONS.SOUTH | DIRECTIONS.WEST, e, onResize);
    } else if (north && onNorthEdge(e, $this)) {
      wm.captureResize(el, DIRECTIONS.NORTH, e, onResize);
    } else if (south && onSouthEdge(e, $this)) {
      wm.captureResize(el, DIRECTIONS.SOUTH, e, onResize);
    } else if (west && onWestEdge(e, $this)) {
      wm.captureResize(el, DIRECTIONS.WEST, e, onResize);
    } else if (east && onEastEdge(e, $this)) {
      wm.captureResize(el, DIRECTIONS.EAST, e, onResize);
    }
  });
  el.mousemove(function (e) {
    var $this = $(this);

    if (north && east && onNorthEdge(e, $this) && onEastEdge(e, $this)) {
      el.css('cursor', 'nesw-resize');
    } else if (north && west && onNorthEdge(e, $this) && onWestEdge(e, $this)) {
      el.css('cursor', 'nwse-resize');
    } else if (south && east && onSouthEdge(e, $this) && onEastEdge(e, $this)) {
      el.css('cursor', 'nwse-resize');
    } else if (south && west && onSouthEdge(e, $this) && onWestEdge(e, $this)) {
      el.css('cursor', 'nesw-resize');
    } else if (south && onSouthEdge(e, $this)) {
      el.css('cursor', 'ns-resize');
    } else if (north && onNorthEdge(e, $this)) {
      el.css('cursor', 'ns-resize');
    } else if (east && onEastEdge(e, $this)) {
      el.css('cursor', 'ew-resize');
    } else if (west && onWestEdge(e, $this)) {
      el.css('cursor', 'ew-resize');
    } else {
      el.css('cursor', 'inherited');
    }
  });
};

WinManager.prototype.registerDrag = function (el, dragger) {
  var wm = this;
  dragger.mousedown(function (e) {
    wm.captureDrag(el, e);
  });
};

function bindOpening(btn, win) {
  btn.click(function (e) {
    openWin(win, e);
  });
}

function createActionsWinBuilder(win) {
  var content = win.root.find('.content');
  var template = content.html();
  content.empty();
  return function (name, action) {
    content.append(template.replace("$value$", name));
    content.find('div:last input').click(action);
  };
}

function closeWin(win) {
  win.root.hide();
}

function openWin(win, mouseEvent) {
  var x = mouseEvent.pageX;
  var y = mouseEvent.pageY;
  var pageW = $(window).width();
  var pageH = $(window).height();
  var winW = win.root.width();
  var winH = win.root.height();
  var left = x < pageW / 2 ? x : x - winW;
  var top = y < pageH / 2 ? y : y - winH;
  win.root.show();
  win.root.offset({
    top: top,
    left: left
  });
}
/** @constructor */


function List(id, model) {
  this.ul = $('<ul>', {
    'class': 'tlist',
    id: id
  });
  this.model = model;
  this.template = '<li>$name$<span class="btn rm" style="float: right;"><i class="fa fa-remove"></i></span></li>';
}

List.prototype.refresh = function () {
  this.ul.empty();
  var items = this.model.items();
  var model = this.model;

  function makeCallbacks(li, item, index) {
    li.find('.rm').click(function (e) {
      model.remove(item, index);
      e.stopPropagation();
      e.preventDefault();
    });
    li.hover(function () {
      model.hover(item, index);
    });
    li.mouseleave(function () {
      model.mouseleave(item, index);
    });
    li.click(function () {
      model.click(item, index);
    });
  }

  for (var i = 0; i < items.length; ++i) {
    var item = items[i];
    var li = $(this.template.replace('$name$', item.name));
    this.ul.append(li);
    makeCallbacks(li, item, i);
  }
};

function dockBtn(name, icon) {
  var btn = $('<span>', {
    'class': 'dock-btn'
  });
  btn.append(faBtn(icon));
  btn.append($('<span>', {
    'class': 'txt'
  }).text(name));
  return btn;
}

function faBtn(iconName) {
  return $('<i>', {
    'class': 'fa fa-' + iconName
  });
}

function Dock(dockEl, switcherEl, viewDefinitions) {
  this.views = {};
  this.dockEl = dockEl;

  function bindClick(dock, switchEl, viewName) {
    switchEl.click(function (e) {
      if (dock.isVisible(viewName)) {
        dock.hide(viewName);
      } else {
        dock.show(viewName);
      }
    });
  }

  for (var i = 0; i < viewDefinitions.length; i++) {
    var viewDef = viewDefinitions[i];
    var view = {};
    this.views[viewDef.name] = view;
    view.node = $('<div>', {
      'class': 'dock-node'
    });
    var caption = $('<div>', {
      'class': 'tool-caption'
    });
    caption.append($('<span>', {
      'class': 'txt'
    }).text(viewDef.name.toUpperCase()));
    caption.append(faBtn(viewDef.icon));
    view.node.append(caption);
    view.node.hide();
    this.dockEl.append(view.node);
    view.switchBtn = dockBtn(viewDef.name, viewDef.icon);
    bindClick(this, view.switchBtn, viewDef.name);
    switcherEl.append(view.switchBtn);
  }
}

Dock.prototype.show = function (viewName) {
  var view = this.views[viewName];

  if (view.switchBtn.hasClass('selected')) {
    return;
  }

  if (!this.dockEl.is(":visible")) {
    this.dockEl.show();
    $('body').trigger('layout');
  }

  view.node.show();
  view.switchBtn.addClass('selected');
};

Dock.prototype.hide = function (viewName) {
  var view = this.views[viewName];

  if (!view.switchBtn.hasClass('selected')) {
    return;
  }

  view.node.hide();
  view.switchBtn.removeClass('selected');

  if (this.dockEl.find('.dock-node:visible').length == 0) {
    this.dockEl.hide();
    $('body').trigger('layout');
  }
};

Dock.prototype.isVisible = function (viewName) {
  return this.views[viewName].switchBtn.hasClass('selected');
};

function _maskTest(mask, value) {
  return (mask & value) === value;
}



/***/ }),

/***/ "./web/app/utils/genSerpinski.js":
/*!***************************************!*\
  !*** ./web/app/utils/genSerpinski.js ***!
  \***************************************/
/*! exports provided: default, genSerpinskiImpl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return genSerpinski; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "genSerpinskiImpl", function() { return genSerpinskiImpl; });
/* harmony import */ var _modules_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../modules/math/vector */ "./modules/math/vector.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


function genSerpinski(viewer) {
  var depthLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 7;

  var _viewer$selected = _slicedToArray(viewer.selected, 1),
      line = _viewer$selected[0];

  genSerpinskiImpl(viewer, line.a, line.b, depthLimit);
  viewer.remove(line);
  viewer.refresh();
}
function genSerpinskiImpl(viewer, aInit, bInit, depthLimit) {
  function serpinskiStep(a, b) {
    a = new _modules_math_vector__WEBPACK_IMPORTED_MODULE_0__["default"]().setV(a);
    b = new _modules_math_vector__WEBPACK_IMPORTED_MODULE_0__["default"]().setV(b);
    var ab = b.minus(a);
    var S = ab.length() * 0.5;
    var v = ab.normalize();
    var SH = S * 0.5;
    var dp = v.multiply(SH);
    var p = a.plus(dp);
    var D = new _modules_math_vector__WEBPACK_IMPORTED_MODULE_0__["default"](-v.y, v.x, 0);
    var DL = Math.sqrt(S * S - SH * SH);
    var A = p.plus(D.multiply(DL));
    var B = A.plus(v.multiply(S));
    return [[A, a], [A, B], [b, B]];
  }

  function addLineOnScene(line) {
    var _line = _slicedToArray(line, 2),
        a = _line[0],
        b = _line[1];

    viewer.addSegment(a.x, a.y, b.x, b.y, viewer.activeLayer);
  }

  function generate(a, b, depth) {
    var lines = serpinskiStep(a, b);

    if (depth === depthLimit) {
      return lines;
    }

    var subLines = [];

    var _lines = _slicedToArray(lines, 3),
        l1 = _lines[0],
        l2 = _lines[1],
        l3 = _lines[2];

    generate(l1[0], l1[1], depth + 1).forEach(function (sl) {
      return subLines.push(sl);
    });
    generate(l2[0], l2[1], depth + 1).forEach(function (sl) {
      return subLines.push(sl);
    });
    generate(l3[0], l3[1], depth + 1).forEach(function (sl) {
      return subLines.push(sl);
    });
    return subLines;
  }

  var lines = generate(aInit, bInit, 1);
  lines.forEach(function (l) {
    return addLineOnScene(l);
  });
}

/***/ }),

/***/ "./web/app/utils/hashmap.js":
/*!**********************************!*\
  !*** ./web/app/utils/hashmap.js ***!
  \**********************************/
/*! exports provided: HashTable, DoubleHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HashTable", function() { return HashTable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleHelper", function() { return DoubleHelper; });
function HashTable(hashCodeF, equalsF) {
  this.hashCodeF = hashCodeF;
  this.equalsF = equalsF;
  this.setTableSize(8);
  this.size = 0;
}

HashTable.prototype.hash = function (key) {
  return Math.abs(this.hashCodeF(key) % this.table.length);
};

HashTable.prototype.get = function (key) {
  var entry = this._findEntry(key, this._findBucket(key));

  if (entry == null) return null;
  return entry[1];
};

HashTable.prototype.put = function (key, value) {
  if (this.size >= 0.75 * this.table.length) {
    this.rebuild();
  }

  this._put(key, value);
};

HashTable.prototype._findBucket = function (key) {
  var hash = this.hash(key);
  var bucket = this.table[hash];

  if (bucket === null) {
    bucket = [];
    this.table[hash] = bucket;
  }

  return bucket;
};

HashTable.prototype._findEntry = function (key, bucket) {
  for (var i = 0; i < bucket.length; i++) {
    if (this.equalsF(bucket[i][0], key)) {
      return bucket[i];
    }
  }

  return null;
};

HashTable.prototype._put = function (key, value) {
  var bucket = this._findBucket(key);

  var entry = this._findEntry(key, bucket);

  if (entry == null) {
    bucket.push([key, value]);
  } else {
    entry[1] = value;
  }

  this.size++;
};

HashTable.prototype.rebuild = function () {
  this.size = 0;
  var oldTable = this.table;
  this.setTableSize(this.table.length * 2);

  for (var i = 0; i < oldTable.length; i++) {
    var e = oldTable[i];

    if (e != null) {
      for (var j = 0; j < e.length; j++) {
        var bucket = e[j];

        this._put(bucket[0], bucket[1]);
      }
    }
  }
};

HashTable.prototype.getKeys = function () {
  var keys = [];
  this.entries(function (k) {
    keys.push(k);
  });
  return keys;
};

HashTable.prototype.entries = function (callback) {
  for (var i = 0; i < this.table.length; i++) {
    var e = this.table[i];

    if (e != null) {
      for (var j = 0; j < e.length; j++) {
        var bucket = e[j];
        callback(bucket[0], bucket[1]);
      }
    }
  }
};

HashTable.prototype.setTableSize = function (newSize) {
  this.table = [];

  for (var i = 0; i < newSize; i++) {
    this.table[i] = null;
  }
};

function DoubleHelper() {
  this.dv = new DataView(new ArrayBuffer(8));
}

DoubleHelper.prototype.hash = function (v) {
  this.dv.setFloat64(0, v);
  return this.dv.getInt32(0) ^ this.dv.getInt32(4);
};

HashTable.forVector3d = function () {
  var doubleHelper = new DoubleHelper();

  function hash(v) {
    return doubleHelper.hash(v.x) ^ doubleHelper.hash(v.y) ^ doubleHelper.hash(v.z);
  }

  function eq(a, b) {
    return a.x === b.x && a.y === b.y && a.z === b.z;
  }

  return new HashTable(hash, eq);
};

HashTable.forEdge = function () {
  var doubleHelper = new DoubleHelper();

  function hash(v) {
    return doubleHelper.hash(v[0].x) ^ doubleHelper.hash(v[0].y) ^ doubleHelper.hash(v[0].z) ^ doubleHelper.hash(v[1].x) ^ doubleHelper.hash(v[1].y) ^ doubleHelper.hash(v[1].z);
  }

  function veq(a, b) {
    return a.x === b.x && a.y === b.y && a.z === b.z;
  }

  function eq(e1, e2) {
    var a1 = e1[0];
    var b1 = e1[1];
    var a2 = e2[0];
    var b2 = e2[1];
    return veq(a1, a2) && veq(b1, b2) || veq(a1, b2) && veq(b1, a2);
  }

  return new HashTable(hash, eq);
};

HashTable.forVector2d = function () {
  var doubleHelper = new DoubleHelper();

  function hash(v) {
    return doubleHelper.hash(v.x) ^ doubleHelper.hash(v.y);
  }

  function eq(a, b) {
    return a.x === b.x && a.y === b.y;
  }

  return new HashTable(hash, eq);
};

HashTable.forDoubleArray = function () {
  var doubleHelper = new DoubleHelper();

  function hash(v) {
    var hash = 0;

    for (var i = 0; i < v.length; i++) {
      hash ^= v[i];
    }

    return hash;
  }

  function eq(a, b) {
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }

    return true;
  }

  return new HashTable(hash, eq);
};



/***/ }),

/***/ "./web/app/utils/jqueryfy.js":
/*!***********************************!*\
  !*** ./web/app/utils/jqueryfy.js ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
 // Usage of jquery is absolutely deprecated. It exists only to support legacy code(2d sketcher and test framework) and 
// will be gone soon after complete transition to React. Main application never uses jquery.

window.jQuery = window.$ = jquery__WEBPACK_IMPORTED_MODULE_0___default.a;

/***/ }),

/***/ "./web/app/utils/utils.js":
/*!********************************!*\
  !*** ./web/app/utils/utils.js ***!
  \********************************/
/*! exports provided: askNumber, extend, fillArray, constRef, swap, defineIterable, DoubleKeyMap, reversedIndex, rotateArr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "askNumber", function() { return askNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fillArray", function() { return fillArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "constRef", function() { return constRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swap", function() { return swap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defineIterable", function() { return defineIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleKeyMap", function() { return DoubleKeyMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reversedIndex", function() { return reversedIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateArr", function() { return rotateArr; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function askNumber(promptText, initValue, promptCallback, resolver) {
  var promptValueStr = promptCallback(promptText, initValue);

  if (promptValueStr != null) {
    var promptValue = Number(promptValueStr);

    if (promptValue == promptValue) {
      // check for NaN
      return promptValue;
    } else {
      if (!!resolver) {
        promptValue = resolver(promptValueStr);

        if (promptValue == promptValue) {
          return promptValueStr;
        }
      }
    }
  }

  return null;
}
var extend = function extend(func, parent) {
  for (var prop in parent.prototype) {
    if (parent.prototype.hasOwnProperty(prop)) func.prototype[prop] = parent.prototype[prop];
  }
};
function fillArray(a, fromIndex, toIndex, val) {
  for (var i = fromIndex; i < toIndex; i++) {
    a[i] = val;
  }
}
function constRef(value) {
  return function () {
    return value;
  };
}
function swap(arr, i1, i2) {
  var tmp = arr[i1];
  arr[i1] = arr[i2];
  arr[i2] = tmp;
}
function defineIterable(obj, name, iteratorFactory) {
  obj[name] = {};
  obj[name][Symbol.iterator] = iteratorFactory;
}
var DoubleKeyMap =
/*#__PURE__*/
function () {
  function DoubleKeyMap() {
    _classCallCheck(this, DoubleKeyMap);

    this.map = new Map();
  }

  _createClass(DoubleKeyMap, [{
    key: "get",
    value: function get(a, b) {
      var subMap = this.map.get(a);

      if (subMap == null) {
        subMap = this.map.get(b);

        if (subMap != null) {
          return subMap.get(a);
        }

        return null;
      }

      return subMap.get(b);
    }
  }, {
    key: "set",
    value: function set(a, b, value) {
      var subMap = this.map.get(a);

      if (subMap == null) {
        subMap = this.map.get(b);

        if (subMap != null) {
          subMap.set(a, value);
          return;
        }

        subMap = new Map();
        this.map.set(a, subMap);
      }

      subMap.set(b, value);
    }
  }]);

  return DoubleKeyMap;
}();
function reversedIndex(i, n) {
  var lidIdx = n - i;

  if (lidIdx == n) {
    lidIdx = 0;
  }

  return lidIdx;
}
function rotateArr(arr, pivot) {
  function reverse(arr, from, to) {
    to--;

    while (from < to) {
      var t = arr[from];
      arr[from] = arr[to];
      arr[to] = t;
      from++;
      to--;
    }
  }

  reverse(arr, 0, pivot);
  reverse(arr, pivot, arr.length);
  reverse(arr, 0, arr.length);
}

/***/ }),

/***/ "./web/css/app.less":
/*!**************************!*\
  !*** ./web/css/app.less ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../../node_modules/css-loader?-url!../../node_modules/less-loader/dist/cjs.js!./app.less */ "./node_modules/css-loader/index.js?-url!./node_modules/less-loader/dist/cjs.js!./web/css/app.less");
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(/*! ../../node_modules/style-loader/addStyles.js */ "./node_modules/style-loader/addStyles.js")(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(true) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept(/*! !../../node_modules/css-loader?-url!../../node_modules/less-loader/dist/cjs.js!./app.less */ "./node_modules/css-loader/index.js?-url!./node_modules/less-loader/dist/cjs.js!./web/css/app.less", function() {
			var newContent = __webpack_require__(/*! !../../node_modules/css-loader?-url!../../node_modules/less-loader/dist/cjs.js!./app.less */ "./node_modules/css-loader/index.js?-url!./node_modules/less-loader/dist/cjs.js!./web/css/app.less");
			if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ 1:
/*!***********************************************!*\
  !*** multi babel-polyfill ./web/app/sketcher ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! babel-polyfill */"./node_modules/babel-polyfill/lib/index.js");
module.exports = __webpack_require__(/*! ./web/app/sketcher */"./web/app/sketcher.js");


/***/ })

/******/ });
//# sourceMappingURL=sketcher.bundle.js.map